From 2ab709f77e685cfd713084da193eb2eeef655e90 Mon Sep 17 00:00:00 2001
From: Yunguo Wei <yunguo.wei@windriver.com>
Date: Wed, 12 Apr 2017 23:15:46 +0000
Subject: [PATCH] The patches for Redpine RS9113DB drivers

Signed-off-by: Fupan Li <fupan.li@windriver.com>
---
 drivers/net/wireless/rsi/Kconfig            |   49 +-
 drivers/net/wireless/rsi/Makefile           |   60 +-
 drivers/net/wireless/rsi/rsi_91x_coex.c     |  199 +++
 drivers/net/wireless/rsi/rsi_91x_core.c     |  286 +++-
 drivers/net/wireless/rsi/rsi_91x_debugfs.c  |  283 +++-
 drivers/net/wireless/rsi/rsi_91x_hal.c      | 1262 +++++++++++++++++
 drivers/net/wireless/rsi/rsi_91x_hci.c      |  547 +++++++
 drivers/net/wireless/rsi/rsi_91x_mac80211.c | 2038 +++++++++++++++++++++++---
 drivers/net/wireless/rsi/rsi_91x_main.c     |  271 +++-
 drivers/net/wireless/rsi/rsi_91x_mgmt.c     | 2040 +++++++++++++++++++++++----
 drivers/net/wireless/rsi/rsi_91x_ps.c       |  216 +++
 drivers/net/wireless/rsi/rsi_91x_sdio.c     |  675 ++++++++-
 drivers/net/wireless/rsi/rsi_91x_sdio_ops.c |  329 ++---
 drivers/net/wireless/rsi/rsi_91x_usb.c      |  796 ++++++++---
 drivers/net/wireless/rsi/rsi_91x_usb_ops.c  |  207 +--
 drivers/net/wireless/rsi/rsi_boot_params.h  |  144 +-
 drivers/net/wireless/rsi/rsi_coex.h         |   67 +
 drivers/net/wireless/rsi/rsi_common.h       |   62 +-
 drivers/net/wireless/rsi/rsi_debugfs.h      |   38 +-
 drivers/net/wireless/rsi/rsi_hal.h          |  182 +++
 drivers/net/wireless/rsi/rsi_hci.h          |  117 ++
 drivers/net/wireless/rsi/rsi_main.h         |  321 ++++-
 drivers/net/wireless/rsi/rsi_mgmt.h         |  461 ++++--
 drivers/net/wireless/rsi/rsi_ps.h           |   76 +
 drivers/net/wireless/rsi/rsi_sdio.h         |  145 +-
 drivers/net/wireless/rsi/rsi_usb.h          |   77 +-
 26 files changed, 9409 insertions(+), 1539 deletions(-)
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_coex.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_hal.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_hci.c
 create mode 100644 drivers/net/wireless/rsi/rsi_91x_ps.c
 create mode 100644 drivers/net/wireless/rsi/rsi_coex.h
 create mode 100644 drivers/net/wireless/rsi/rsi_hal.h
 create mode 100644 drivers/net/wireless/rsi/rsi_hci.h
 create mode 100644 drivers/net/wireless/rsi/rsi_ps.h

diff --git a/drivers/net/wireless/rsi/Kconfig b/drivers/net/wireless/rsi/Kconfig
index 35245f9..4664d0d 100644
--- a/drivers/net/wireless/rsi/Kconfig
+++ b/drivers/net/wireless/rsi/Kconfig
@@ -1,3 +1,16 @@
+config WLAN_VENDOR_RSI
+	bool "Redpine Signals Inc devices"
+	default y
+	---help---
+	  If you have a wireless card belonging to this class, say Y.
+
+	  Note that the answer to this question doesn't directly affect the
+	  kernel: saying N will just cause the configurator to skip all
+	  the questions about  cards. If you say Y, you will be asked for
+	  your specific card in the following questions.
+
+if WLAN_VENDOR_RSI
+
 config RSI_91X
 	tristate "Redpine Signals Inc 91x WLAN driver support"
 	depends on MAC80211
@@ -11,7 +24,7 @@ config RSI_DEBUGFS
 	default y
 	---help---
 	 Say Y, if you would like to enable debug support. This option
-	 creates debugfs entries
+	 creates debugfs entries.
 
 config RSI_SDIO
 	tristate "Redpine Signals SDIO bus support"
@@ -28,3 +41,37 @@ config RSI_USB
 	---help---
 	  This option enables the USB bus support in rsi drivers.
 	  Select M (recommended), if you have a RSI 1x1 wireless module.
+
+config RSI_BT_ALONE
+	bool "Redpine Signals BT alone (classic/LE) mode support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the BT classic alone upport in rsi drivers.
+	  Say Y, if you want to use this feature.
+
+config RSI_COEX
+	bool "Redpine Signals Wi-Fi BT Coex support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the Wi-Fi BT coex support in rsi drivers.
+	  Select Y, if you have to use this feature.
+
+config RSI_WOW
+	bool "Redpine Signals WoWLAN support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the WoWLAN support.
+	  Say Y if you want to use this feature.
+
+config RSI_P2P
+	bool "Redpine Signals Wi-Fi Direct support"
+	depends on RSI_91X
+	default n
+	---help---
+	  This option enables the Wi-Fi Direct support in rsi drivers.
+	  Select Y, if you have to use this feature.
+
+endif # WLAN_VENDOR_RSI
diff --git a/drivers/net/wireless/rsi/Makefile b/drivers/net/wireless/rsi/Makefile
index 25828b6..2032ab7 100644
--- a/drivers/net/wireless/rsi/Makefile
+++ b/drivers/net/wireless/rsi/Makefile
@@ -1,12 +1,48 @@
-rsi_91x-y			+= rsi_91x_main.o
-rsi_91x-y			+= rsi_91x_core.o
-rsi_91x-y			+= rsi_91x_mac80211.o
-rsi_91x-y			+= rsi_91x_mgmt.o
-rsi_91x-y			+= rsi_91x_pkt.o
-rsi_91x-$(CONFIG_RSI_DEBUGFS)	+= rsi_91x_debugfs.o
-
-rsi_usb-y			+= rsi_91x_usb.o rsi_91x_usb_ops.o
-rsi_sdio-y			+= rsi_91x_sdio.o rsi_91x_sdio_ops.o
-obj-$(CONFIG_RSI_91X) 		+= rsi_91x.o
-obj-$(CONFIG_RSI_SDIO)		+= rsi_sdio.o
-obj-$(CONFIG_RSI_USB)		+= rsi_usb.o
+#/*
+# Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 	1. Redistributions of source code must retain the above copyright
+# 	   notice, this list of conditions and the following disclaimer.
+#
+# 	2. Redistributions in binary form must reproduce the above copyright
+# 	   notice, this list of conditions and the following disclaimer in the
+# 	   documentation and/or other materials provided with the distribution.
+#
+# 	3. Neither the name of the copyright holder nor the names of its
+# 	   contributors may be used to endorse or promote products derived from
+# 	   this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#*/
+
+rsi_91x-y			+= rsi_91x_main.o
+rsi_91x-y			+= rsi_91x_core.o
+rsi_91x-y			+= rsi_91x_mac80211.o
+rsi_91x-y			+= rsi_91x_mgmt.o
+rsi_91x-y			+= rsi_91x_hal.o
+rsi_91x-y			+= rsi_91x_ps.o
+rsi_91x-$(CONFIG_RSI_DEBUGFS)	+= rsi_91x_debugfs.o
+rsi_91x-$(CONFIG_RSI_BT_ALONE)	+= rsi_91x_hci.o
+rsi_91x-$(CONFIG_RSI_COEX)	+= rsi_91x_coex.o
+rsi_91x-$(CONFIG_RSI_COEX)	+= rsi_91x_hci.o
+
+rsi_usb-objs	+= rsi_91x_usb.o rsi_91x_usb_ops.o
+rsi_sdio-objs	+= rsi_91x_sdio.o rsi_91x_sdio_ops.o
+
+obj-$(CONFIG_RSI_91X)           += rsi_91x.o
+obj-$(CONFIG_RSI_SDIO)          += rsi_sdio.o
+obj-$(CONFIG_RSI_USB)           += rsi_usb.o
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_coex.c b/drivers/net/wireless/rsi/rsi_91x_coex.c
new file mode 100644
index 0000000..c75b32c
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_coex.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "rsi_main.h"
+#include "rsi_coex.h"
+#include "rsi_hal.h"
+#include "rsi_mgmt.h"
+
+static u8 rsi_coex_determine_coex_q(struct rsi_coex_ctrl_block *coex_cb)
+{
+	u8 q_num = INVALID_QUEUE;
+
+	if (skb_queue_len(&coex_cb->coex_tx_qs[VIP_Q]) > 0)
+		q_num = VIP_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[COEX_Q]) > 0)
+		q_num = COEX_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[BT_Q]) > 0)
+		q_num = BT_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[ZIGB_Q]) > 0)
+		q_num = ZIGB_Q;
+	if (skb_queue_len(&coex_cb->coex_tx_qs[WLAN_Q]) > 0)
+		q_num = WLAN_Q;
+
+	return q_num;
+}
+
+static void rsi_coex_sched_tx_pkts(struct rsi_coex_ctrl_block *coex_cb)
+{
+	u8 coex_q;
+	struct sk_buff *skb;
+
+	while (1) {
+		coex_q = rsi_coex_determine_coex_q(coex_cb);
+		rsi_dbg(INFO_ZONE, "queue = %d\n", coex_q);
+
+		if (coex_q == INVALID_QUEUE) {
+			rsi_dbg(DATA_TX_ZONE, "No more pkt\n");
+			break;
+		}
+
+		down(&coex_cb->priv->tx_bus_lock);
+
+		if (coex_q == BT_Q) {
+			skb = skb_dequeue(&coex_cb->coex_tx_qs[BT_Q]);
+			rsi_send_bt_pkt(coex_cb->priv, skb);
+		}
+
+		up(&coex_cb->priv->tx_bus_lock);
+	}
+}
+
+/**
+ * rsi_coex_scheduler_thread() - This function is a kernel thread to schedule
+ *			       the coex packets to device
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: None.
+ */
+static void rsi_coex_scheduler_thread(struct rsi_common *common)
+{
+	struct rsi_coex_ctrl_block *coex_cb =
+		(struct rsi_coex_ctrl_block *)common->coex_cb;
+
+	u32 timeout = EVENT_WAIT_FOREVER;
+
+	do {
+		rsi_wait_event(&coex_cb->coex_tx_thread.event, timeout);
+		rsi_reset_event(&coex_cb->coex_tx_thread.event);
+
+		rsi_coex_sched_tx_pkts(coex_cb);
+	} while (atomic_read(&coex_cb->coex_tx_thread.thread_done) == 0);
+
+	complete_and_exit(&coex_cb->coex_tx_thread.completion, 0);
+}
+
+int rsi_coex_recv_pkt(struct rsi_common *common, u8 *msg)
+{
+	u16 msg_type = msg[2];
+
+	if (msg_type == COMMON_CARD_READY_IND) {
+		rsi_dbg(INFO_ZONE, "COMMON CARD READY RECEIVED\n");
+		rsi_handle_card_ready(common);
+	} else if (msg_type == SLEEP_NOTIFY_IND) {
+		rsi_dbg(INFO_ZONE, "\n\n sleep notify RECEIVED\n");
+		rsi_mgmt_pkt_recv(common, msg);
+	}
+
+	return 0;
+}
+
+int rsi_coex_send_pkt(struct rsi_common *common,
+		      struct sk_buff *skb,
+		      u8 hal_queue)
+{
+	struct rsi_coex_ctrl_block *coex_cb =
+		(struct rsi_coex_ctrl_block *)common->coex_cb;
+	struct skb_info *tx_params = NULL;
+	int status = 0;
+
+	/* Add pkt to queue if not WLAN packet */
+	if (hal_queue != RSI_WLAN_Q) {
+		skb_queue_tail(&coex_cb->coex_tx_qs[hal_queue], skb);
+		rsi_set_event(&coex_cb->coex_tx_thread.event);
+		return status;
+	}
+	if (common->iface_down) {
+		tx_params = (struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;
+
+		if (!(tx_params->flags & INTERNAL_MGMT_PKT)) {
+			rsi_indicate_tx_status(common->priv, skb, -EINVAL);
+			return 0;
+		}
+	}
+
+	/* Send packet to hal */
+	if (skb->priority == MGMT_SOFT_Q)
+		status = rsi_send_mgmt_pkt(common, skb);
+	else
+		status = rsi_send_data_pkt(common, skb);
+
+	return 0;
+}
+
+int rsi_coex_init(struct rsi_common *common)
+{
+	struct rsi_coex_ctrl_block *coex_cb = NULL;
+	int cnt;
+
+	coex_cb = kzalloc(sizeof(*coex_cb), GFP_KERNEL);
+	if (!coex_cb)
+		return -ENOMEM;
+
+	common->coex_cb = (void *)coex_cb;
+	coex_cb->priv = common;
+	sema_init(&coex_cb->tx_bus_lock, 1);
+
+	/* Initialize co-ex queues */
+	for (cnt = 0; cnt < NUM_COEX_TX_QUEUES; cnt++)
+		skb_queue_head_init(&coex_cb->coex_tx_qs[cnt]);
+	rsi_init_event(&coex_cb->coex_tx_thread.event);
+
+	/* Initialize co-ex thread */
+	if (rsi_create_kthread(common,
+			       &coex_cb->coex_tx_thread,
+			       rsi_coex_scheduler_thread,
+			       "Coex-Tx-Thread")) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to init tx thrd\n", __func__);
+		goto err;
+	}
+	return 0;
+
+err:
+	return -EINVAL;
+}
+
+void rsi_coex_deinit(struct rsi_common *common)
+{
+	int cnt;
+
+	struct rsi_coex_ctrl_block *coex_cb =
+		(struct rsi_coex_ctrl_block *)common->coex_cb;
+
+	/* Stop the coex tx thread */
+	rsi_kill_thread(&coex_cb->coex_tx_thread);
+
+	/* Empty the coex queue */
+	for (cnt = 0; cnt < NUM_COEX_TX_QUEUES; cnt++)
+		skb_queue_purge(&coex_cb->coex_tx_qs[cnt]);
+
+	/* Free the coex control block */
+	kfree(coex_cb);
+}
diff --git a/drivers/net/wireless/rsi/rsi_91x_core.c b/drivers/net/wireless/rsi/rsi_91x_core.c
index f3d3995..5475fdd 100644
--- a/drivers/net/wireless/rsi/rsi_91x_core.c
+++ b/drivers/net/wireless/rsi/rsi_91x_core.c
@@ -1,21 +1,39 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
+#include "rsi_hal.h"
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
 
 /**
  * rsi_determine_min_weight_queue() - This function determines the queue with
@@ -106,9 +124,9 @@ static u32 rsi_get_num_pkts_dequeue(struct rsi_common *common, u8 q_num)
 
 	do {
 		r_txop = ieee80211_generic_frame_duration(adapter->hw,
-							  adapter->vifs[0],
-							  common->band,
-							  skb->len, &rate);
+					adapter->vifs[adapter->sc_nvifs - 1],
+					common->band,
+					skb->len, &rate);
 		txop -= le16_to_cpu(r_txop);
 		pkt_cnt += 1;
 		/*checking if pkts are still there*/
@@ -134,7 +152,12 @@ static u8 rsi_core_determine_hal_queue(struct rsi_common *common)
 	bool recontend_queue = false;
 	u32 q_len = 0;
 	u8 q_num = INVALID_QUEUE;
-	u8 ii = 0;
+	u8 ii;
+	
+	if (skb_queue_len(&common->tx_queue[MGMT_BEACON_Q])) {
+		q_num = MGMT_BEACON_Q;
+		return q_num;
+	}
 
 	if (skb_queue_len(&common->tx_queue[MGMT_SOFT_Q])) {
 		if (!common->mgmt_q_block)
@@ -142,8 +165,10 @@ static u8 rsi_core_determine_hal_queue(struct rsi_common *common)
 		return q_num;
 	}
 
-	if (common->hw_data_qs_blocked)
+	if (common->hw_data_qs_blocked) {
+		rsi_dbg(INFO_ZONE, "%s: data queue blocked\n", __func__);
 		return q_num;
+	}
 
 	if (common->pkt_cnt != 0) {
 		--common->pkt_cnt;
@@ -210,6 +235,7 @@ static void rsi_core_queue_pkt(struct rsi_common *common,
 			       struct sk_buff *skb)
 {
 	u8 q_num = skb->priority;
+
 	if (q_num >= NUM_SOFT_QUEUES) {
 		rsi_dbg(ERR_ZONE, "%s: Invalid Queue Number: q_num = %d\n",
 			__func__, q_num);
@@ -263,54 +289,122 @@ void rsi_core_qos_processor(struct rsi_common *common)
 		rsi_dbg(DATA_TX_ZONE,
 			"%s: Queue number = %d\n", __func__, q_num);
 
-		if (q_num == INVALID_QUEUE) {
-			rsi_dbg(DATA_TX_ZONE, "%s: No More Pkt\n", __func__);
+		if (q_num == INVALID_QUEUE)
 			break;
-		}
 
-		mutex_lock(&common->tx_rxlock);
+		mutex_lock(&common->tx_lock);
 
 		status = adapter->check_hw_queue_status(adapter, q_num);
-		if ((status <= 0)) {
-			mutex_unlock(&common->tx_rxlock);
+		if (status <= 0) {
+			mutex_unlock(&common->tx_lock);
 			break;
 		}
 
 		if ((q_num < MGMT_SOFT_Q) &&
 		    ((skb_queue_len(&common->tx_queue[q_num])) <=
 		      MIN_DATA_QUEUE_WATER_MARK)) {
+			if (!adapter->hw)
+				break;
 			if (ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))
 				ieee80211_wake_queue(adapter->hw,
 						     WME_AC(q_num));
 		}
 
 		skb = rsi_core_dequeue_pkt(common, q_num);
-		if (skb == NULL) {
+		if (!skb) {
 			rsi_dbg(ERR_ZONE, "skb null\n");
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->tx_lock);
 			break;
 		}
-
+#ifdef CONFIG_RSI_COEX
+		if (q_num == MGMT_BEACON_Q) {
+			status = rsi_send_pkt(common, skb);
+			dev_kfree_skb(skb);
+		} else
+			status = rsi_coex_send_pkt(common, skb, RSI_WLAN_Q);
+#else
 		if (q_num == MGMT_SOFT_Q)
 			status = rsi_send_mgmt_pkt(common, skb);
-		else
+		else if(q_num == MGMT_BEACON_Q) {
+			status = rsi_send_pkt(common, skb);
+			dev_kfree_skb(skb);
+		} else 
 			status = rsi_send_data_pkt(common, skb);
+#endif
 
 		if (status) {
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->tx_lock);
 			break;
 		}
 
 		common->tx_stats.total_tx_pkt_send[q_num]++;
 
 		tstamp_2 = jiffies;
-		mutex_unlock(&common->tx_rxlock);
+		mutex_unlock(&common->tx_lock);
 
 		if (tstamp_2 > tstamp_1 + (300 * HZ / 1000))
 			schedule();
 	}
 }
 
+char *dot11_pkt_type(__le16 frame_control)
+{
+	if (ieee80211_is_beacon(frame_control))
+		return "BEACON";
+	if (ieee80211_is_assoc_req(frame_control))
+		return "ASSOC_REQ";
+	if (ieee80211_is_assoc_resp(frame_control))
+		return "ASSOC_RESP";
+	if (ieee80211_is_reassoc_req(frame_control))
+		return "REASSOC_REQ";
+	if (ieee80211_is_reassoc_resp(frame_control))
+		return "REASSOC_RESP";
+	if (ieee80211_is_auth(frame_control))
+		return "AUTH";
+	if (ieee80211_is_probe_req(frame_control))
+		return "PROBE_REQ";
+	if (ieee80211_is_probe_resp(frame_control))
+		return "PROBE_RESP";
+	if (ieee80211_is_disassoc(frame_control))
+		return "DISASSOC";
+	if (ieee80211_is_deauth(frame_control))
+		return "DEAUTH";
+	if (ieee80211_is_action(frame_control))
+		return "ACTION";
+	if (ieee80211_is_data_qos(frame_control))
+		return "QOS DATA";
+	if (ieee80211_is_pspoll(frame_control))
+		return "PS_POLL";
+	if (ieee80211_is_nullfunc(frame_control))
+		return "NULL_DATA";
+	if (ieee80211_is_qos_nullfunc(frame_control))
+		return "QOS_NULL_DATA";
+
+	if (ieee80211_is_mgmt(frame_control))
+		return "DOT11_MGMT";
+	if (ieee80211_is_data(frame_control))
+		return "DOT11_DATA";
+	if (ieee80211_is_ctl(frame_control))
+		return "DOT11_CTRL";
+
+	return "UNKNOWN";
+}
+EXPORT_SYMBOL_GPL(dot11_pkt_type);
+
+struct rsi_sta *rsi_find_sta(struct rsi_common *common, u8 *mac_addr)
+{
+	int i;
+
+	for (i = 0; i < common->max_stations; i++) {
+		if (!common->stations[i].sta)
+			continue;
+		if (!(memcmp(common->stations[i].sta->addr,
+			     mac_addr, ETH_ALEN)))
+			return &common->stations[i];
+	}
+	return NULL;
+}
+
 /**
  * rsi_core_xmit() - This function transmits the packets received from mac80211
  * @common: Pointer to the driver private structure.
@@ -323,7 +417,8 @@ void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_tx_info *info;
 	struct skb_info *tx_params;
-	struct ieee80211_hdr *tmp_hdr = NULL;
+	struct ieee80211_hdr *wlh = NULL;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
 	u8 q_num, tid = 0;
 
 	if ((!skb) || (!skb->len)) {
@@ -331,36 +426,144 @@ void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)
 			__func__);
 		goto xmit_fail;
 	}
-	info = IEEE80211_SKB_CB(skb);
-	tx_params = (struct skb_info *)info->driver_data;
-	tmp_hdr = (struct ieee80211_hdr *)&skb->data[0];
-
+#ifdef CONFIG_RSI_WOW
+	if (common->suspend_flag) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Blocking Tx_packets when WOWLAN is enabled\n",
+			__func__);
+		goto xmit_fail;
+	}
+#endif
 	if (common->fsm_state != FSM_MAC_INIT_DONE) {
 		rsi_dbg(ERR_ZONE, "%s: FSM state not open\n", __func__);
 		goto xmit_fail;
 	}
 
-	if ((ieee80211_is_mgmt(tmp_hdr->frame_control)) ||
-	    (ieee80211_is_ctl(tmp_hdr->frame_control)) ||
-	    (ieee80211_is_qos_nullfunc(tmp_hdr->frame_control))) {
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+	wlh = (struct ieee80211_hdr *)&skb->data[0];
+
+	if ((ieee80211_is_mgmt(wlh->frame_control)) ||
+	    (ieee80211_is_ctl(wlh->frame_control)) ||
+	    (ieee80211_is_qos_nullfunc(wlh->frame_control))) {
+
+		if ((ieee80211_is_assoc_req(wlh->frame_control)) ||
+	 	    (ieee80211_is_reassoc_req(wlh->frame_control))) {
+			struct ieee80211_bss_conf *bss = NULL;
+
+			bss = &adapter->vifs[0]->bss_conf;
+			common->eapol4_confirm = 0;
+			common->start_bgscan = 0;
+			rsi_send_sta_notify_frame(common, STA_OPMODE,
+						  STA_CONNECTED,
+						  bss->bssid, bss->qos,
+						  bss->aid, 0);
+		}
 		q_num = MGMT_SOFT_Q;
 		skb->priority = q_num;
+
+#ifdef CONFIG_RSI_WOW          
+		if ((ieee80211_is_deauth(wlh->frame_control)) &&
+		    (common->suspend_flag)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Discarding Deauth when WOWLAN is enabled\n",
+				__func__);
+			goto xmit_fail; 
+		}
+#endif
+		rsi_dbg(INFO_ZONE, "Core: TX Dot11 Mgmt Pkt Type: %s\n",
+			dot11_pkt_type(wlh->frame_control));
+#ifndef CONFIG_HW_SCAN_OFFLOAD
+		if (ieee80211_is_probe_req(wlh->frame_control)) {
+			if ((is_broadcast_ether_addr(wlh->addr1)) &&
+			    (skb->data[MIN_802_11_HDR_LEN + 1] == 0) &&
+			    (skb->len < 120)) {
+				memcpy(common->bgscan_probe_req,
+				       skb->data, skb->len);
+				common->bgscan_probe_req_len = skb->len;
+			}
+		}
+#endif
+		if (rsi_prepare_mgmt_desc(common, skb)) {
+			rsi_dbg(ERR_ZONE, "Failed to prepeare desc\n");
+			goto xmit_fail;
+		}
 	} else {
-		if (ieee80211_is_data_qos(tmp_hdr->frame_control)) {
-			tid = (skb->data[24] & IEEE80211_QOS_TID);
+		struct rsi_sta *sta = NULL;
+
+		rsi_dbg(INFO_ZONE, "Core: TX Data Packet\n");
+		rsi_hex_dump(DATA_TX_ZONE, "TX Data Packet",
+			     skb->data, skb->len);
+
+		/* Drop the null packets if bgscan is enabled
+ 		 * as it is already handled in firmware */
+		if ((vif->type == NL80211_IFTYPE_STATION) && (common->bgscan_en)) {
+			if ((ieee80211_is_qos_nullfunc(wlh->frame_control) ||
+			    ieee80211_is_nullfunc(wlh->frame_control))) {
+				++common->tx_stats.total_tx_pkt_freed[skb->priority];
+				rsi_indicate_tx_status(adapter, skb, 0);
+				return;
+			}
+		}
+
+		if (ieee80211_is_data_qos(wlh->frame_control)) {
+			u8 *qos = ieee80211_get_qos_ctl(wlh);
+			
+			tid = *qos & IEEE80211_QOS_CTL_TID_MASK;
 			skb->priority = TID_TO_WME_AC(tid);
+
 		} else {
 			tid = IEEE80211_NONQOS_TID;
 			skb->priority = BE_Q;
 		}
+		if (((vif->type == NL80211_IFTYPE_AP) ||
+		     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+		    (!is_broadcast_ether_addr(wlh->addr1)) &&
+		    (!is_multicast_ether_addr(wlh->addr1))) {
+			sta = rsi_find_sta(common, wlh->addr1);
+			if (!sta)
+				goto xmit_fail;
+		}
+
 		q_num = skb->priority;
 		tx_params->tid = tid;
-		tx_params->sta_id = 0;
+
+		if (sta) {
+#if 0
+			seq = IEEE80211_SN_TO_SEQ(sta->seq_no[skb->priority]);
+
+			wlh->seq_ctrl = cpu_to_le16(seq);
+			sta->seq_no[skb->priority] =
+				ieee80211_sn_inc(sta->seq_no[skb->priority]);
+#endif
+			tx_params->sta_id = sta->sta_id;
+		} else {
+#if 0
+			seq = IEEE80211_SN_TO_SEQ(common->bc_mc_seqno);
+			if ((vif->type == NL80211_IFTYPE_AP) ||
+			    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+				seq = IEEE80211_SN_TO_SEQ(common->bc_mc_seqno);
+				wlh->seq_ctrl = cpu_to_le16(seq);
+				common->bc_mc_seqno =
+					ieee80211_sn_inc(common->bc_mc_seqno);
+			}
+#endif
+			tx_params->sta_id = 0;
+		}
+
+		if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
+			q_num = MGMT_SOFT_Q;
+			skb->priority = q_num;
+		}
+		if (rsi_prepare_data_desc(common, skb)) {
+			rsi_dbg(ERR_ZONE, "Failed to prepare data desc\n");
+			goto xmit_fail;
+		}
 	}
 
 	if ((q_num != MGMT_SOFT_Q) &&
 	    ((skb_queue_len(&common->tx_queue[q_num]) + 1) >=
-	     DATA_QUEUE_WATER_MARK)) {
+	      DATA_QUEUE_WATER_MARK)) {
 		rsi_dbg(ERR_ZONE, "%s: sw queue full\n", __func__);
 		if (!ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))
 			ieee80211_stop_queue(adapter->hw, WME_AC(q_num));
@@ -376,6 +579,7 @@ void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)
 
 xmit_fail:
 	rsi_dbg(ERR_ZONE, "%s: Failed to queue packet\n", __func__);
+
 	/* Dropping pkt here */
 	ieee80211_free_txskb(common->priv->hw, skb);
 }
diff --git a/drivers/net/wireless/rsi/rsi_91x_debugfs.c b/drivers/net/wireless/rsi/rsi_91x_debugfs.c
index 828a042..d8e7bf7 100644
--- a/drivers/net/wireless/rsi/rsi_91x_debugfs.c
+++ b/drivers/net/wireless/rsi/rsi_91x_debugfs.c
@@ -1,21 +1,38 @@
 /**
- * Copyright (c) 2014 Redpine Signals Inc.
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "rsi_debugfs.h"
 #include "rsi_sdio.h"
+#include "rsi_mgmt.h"
+
+extern int g_bgscan_enable;
 
 /**
  * rsi_sdio_stats_read() - This function returns the sdio status of the driver.
@@ -59,7 +76,7 @@ static int rsi_sdio_stats_read(struct seq_file *seq, void *data)
 }
 
 /**
- * rsi_sdio_stats_open() - This funtion calls single open function of seq_file
+ * rsi_sdio_stats_open() - This function calls single open function of seq_file
  *			   to open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -83,24 +100,17 @@ static int rsi_version_read(struct seq_file *seq, void *data)
 {
 	struct rsi_common *common = seq->private;
 
-	common->driver_ver.major = 0;
-	common->driver_ver.minor = 1;
-	common->driver_ver.release_num = 0;
-	common->driver_ver.patch_num = 0;
-	seq_printf(seq, "Driver : %x.%d.%d.%d\nLMAC   : %d.%d.%d.%d\n",
-		   common->driver_ver.major,
-		   common->driver_ver.minor,
-		   common->driver_ver.release_num,
-		   common->driver_ver.patch_num,
-		   common->fw_ver.major,
-		   common->fw_ver.minor,
-		   common->fw_ver.release_num,
-		   common->fw_ver.patch_num);
+	seq_printf(seq, "Driver : %s\nLMAC   : %d.%d.%d.%d\n",
+		   common->driver_ver,
+		   common->lmac_ver.major,
+		   common->lmac_ver.minor,
+		   common->lmac_ver.release_num,
+		   common->lmac_ver.patch_num);
 	return 0;
 }
 
 /**
- * rsi_version_open() - This funtion calls single open function of seq_file to
+ * rsi_version_open() - This function calls single open function of seq_file to
  *			open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -108,7 +118,7 @@ static int rsi_version_read(struct seq_file *seq, void *data)
  * Return: Pointer to the opened file status: 0 on success, ENOMEM on failure.
  */
 static int rsi_version_open(struct inode *inode,
-				 struct file *file)
+			    struct file *file)
 {
 	return single_open(file, rsi_version_read, inode->i_private);
 }
@@ -180,7 +190,7 @@ static int rsi_stats_read(struct seq_file *seq, void *data)
 }
 
 /**
- * rsi_stats_open() - This funtion calls single open function of seq_file to
+ * rsi_stats_open() - This function calls single open function of seq_file to
  *		      open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -194,7 +204,8 @@ static int rsi_stats_open(struct inode *inode,
 }
 
 /**
- * rsi_debug_zone_read() - This function display the currently enabled debug zones.
+ * rsi_debug_zone_read() - This function display the currently
+ *			enabled debug zones.
  * @seq: Pointer to the sequence file structure.
  * @data: Pointer to the data.
  *
@@ -209,7 +220,7 @@ static int rsi_debug_zone_read(struct seq_file *seq, void *data)
 }
 
 /**
- * rsi_debug_read() - This funtion calls single open function of seq_file to
+ * rsi_debug_read() - This function calls single open function of seq_file to
  *		      open file and read contents from it.
  * @inode: Pointer to the inode structure.
  * @file: Pointer to the file structure.
@@ -252,6 +263,217 @@ static ssize_t rsi_debug_zone_write(struct file *filp,
 	return len;
 }
 
+/**
+ * rsi_bgscan_int_read() - This function display the default bgscan param
+ *			   values.
+ * @seq: Pointer to the sequence file structure.
+ * @data: Pointer to the data.
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int rsi_bgscan_int_read(struct seq_file *file, void *data)
+{
+	struct rsi_common *common = file->private;
+	struct bgscan_config_params *params = NULL;
+	int cnt;
+
+	if (!common) {
+		rsi_dbg(ERR_ZONE, "No Interface\n");
+		return -ENODEV;
+	}
+	if (common->iface_down) {
+		rsi_dbg(ERR_ZONE, "Interface Down\n");
+		return -ENODEV;
+	}
+	params = &common->bgscan_info;
+
+	seq_printf(file, "%d %d %d %d %d %d %d %d\n",
+		   common->bgscan_en,
+		   params->bgscan_threshold,
+		   params->roam_threshold,
+		   params->bgscan_periodicity,
+		   params->active_scan_duration,
+		   params->passive_scan_duration,
+		   params->two_probe,
+		   params->num_bg_channels);
+
+	for (cnt = 0; cnt < params->num_bg_channels; cnt++) {
+		if (params->channels2scan[cnt] & (BIT(15)))
+			seq_printf(file, "%d[DFS] ",
+				   (params->channels2scan[cnt] & 0x7FFF));
+		else
+			seq_printf(file, "%d ", params->channels2scan[cnt]);
+	}
+	seq_printf(file, "\n");
+
+	return 0;
+}
+
+static int rsi_bgscan_read(struct inode *inode, struct file *file)
+{
+	return single_open(file, rsi_bgscan_int_read, inode->i_private);
+}
+
+/**
+ * rsi_bgscan_write() - This function gets the bgscan params from user
+ *			    and configures to device.
+ * @file: Pointer to the file structure.
+ * @user_buff: user buffer.
+ * @count: Length of the data written in buffer.
+ * @ppos: offset.
+ *
+ * Return: Number of bytes read.
+ */
+static ssize_t rsi_bgscan_write(struct file *file,
+			        const char __user *user_buff,
+				size_t count,
+				loff_t *ppos)
+
+{
+	struct rsi_common *common = file->f_inode->i_private;
+	struct rsi_hw *adapter = NULL;
+	struct ieee80211_bss_conf *bss = NULL;
+	char bgscan_buf[200];
+	int bgscan_vals[64] = { 0 };
+	int total_bytes, cnt = 0;
+	int bytes_read = 0, t_bytes;
+	int ret;
+
+	if (!common) {
+		rsi_dbg(ERR_ZONE, "No Interface\n");
+		return -ENODEV;
+	}
+	if (common->iface_down) {
+		rsi_dbg(ERR_ZONE, "Interface Down\n");
+		return -ENODEV;
+	}
+	adapter = common->priv;
+	bss = &adapter->vifs[adapter->sc_nvifs - 1]->bss_conf;
+
+	total_bytes = simple_write_to_buffer(bgscan_buf,
+					     sizeof(bgscan_buf) - 1,
+					     ppos, user_buff, count);
+	if (total_bytes < 1)
+		return -EINVAL;
+
+	/* make sure that buf is null terminated */
+	bgscan_buf[sizeof(bgscan_buf) - 1] = '\0';
+
+	ret = sscanf(bgscan_buf, "%d%n",
+		     (int *)&g_bgscan_enable, &t_bytes);
+	if (ret <= 0)
+		return -EINVAL;
+
+	if (!g_bgscan_enable) {
+		/* return here if bgscan is already disabled */
+		if (!common->bgscan_en) {
+#ifdef PLATFORM_X86
+			rsi_dbg(ERR_ZONE, "bgscan already disabled\n");
+#endif
+			return total_bytes;
+		}
+
+		mutex_lock(&common->mutex);
+		if (bss->assoc && !rsi_send_bgscan_params(common, 0)) {
+#ifdef PLATFORM_X86
+			rsi_dbg(ERR_ZONE, "*** bgscan disabled ***\n");
+#endif
+			common->bgscan_en = 0;
+		}
+		mutex_unlock(&common->mutex);
+
+		return total_bytes;
+	} else if (common->bgscan_en) {
+#ifdef PLATFORM_X86
+		rsi_dbg(ERR_ZONE, "bgscan already enabled\n");
+#endif
+		return total_bytes;
+	}
+
+	/* Return if bgscan is already in progress */
+	if (common->bgscan_en)
+		return total_bytes;
+
+	bytes_read += t_bytes;
+	while (1) {
+		ret = sscanf(bgscan_buf + bytes_read, "%d%n",
+			     &bgscan_vals[cnt++],
+			     &t_bytes);
+		if (ret <= 0)
+			break;
+		bytes_read += t_bytes;
+		
+		if ((bgscan_vals[6] > 0) && (cnt > (6 + bgscan_vals[6])))
+			break;
+	}
+	common->bgscan_info.bgscan_threshold = bgscan_vals[0];
+	common->bgscan_info.roam_threshold = bgscan_vals[1];
+	common->bgscan_info.bgscan_periodicity = bgscan_vals[2];
+	common->bgscan_info.active_scan_duration = bgscan_vals[3];
+	common->bgscan_info.passive_scan_duration = bgscan_vals[4];
+	common->bgscan_info.two_probe = bgscan_vals[5];
+	common->bgscan_info.num_user_channels = bgscan_vals[6];
+	memset(&common->bgscan_info.user_channels, 0,
+	       (MAX_BGSCAN_CHANNELS * 2));
+	common->bgscan_info.num_user_channels = 
+		((bgscan_vals[6] > MAX_BGSCAN_CHANNELS) ?
+		 MAX_BGSCAN_CHANNELS : bgscan_vals[6]); 
+	
+	for (cnt = 0; cnt < common->bgscan_info.num_user_channels; cnt++)
+		common->bgscan_info.user_channels[cnt] = bgscan_vals[7 + cnt];
+
+#ifdef PLATFORM_X86
+	rsi_dbg(INFO_ZONE,
+		"bgscan_count = %d, roam_count = %d, periodicity = %d\n",
+		common->bgscan_info.bgscan_threshold,
+		common->bgscan_info.roam_threshold,
+		common->bgscan_info.bgscan_periodicity);
+	rsi_dbg(INFO_ZONE,
+		"active_scan_dur = %d, passive_scan_dur = %d, two_probe = %d\n",
+		common->bgscan_info.active_scan_duration,
+		common->bgscan_info.passive_scan_duration,
+		common->bgscan_info.two_probe);
+	rsi_dbg(INFO_ZONE, "Number of scan channels = %d\n",
+		common->bgscan_info.num_user_channels);
+	rsi_hex_dump(INFO_ZONE, "bgscan channels",
+		     (u8 *)common->bgscan_info.user_channels,
+		     common->bgscan_info.num_user_channels * 2);
+#endif
+
+	/* If connection is not done don't send bgscan params */
+	if (!bss->assoc) {
+#ifdef PLATFORM_X86
+		rsi_dbg(INFO_ZONE, "Station not connected; skip now\n");
+#endif
+		return total_bytes;
+	}
+
+	/* Send bgscan params to device */
+	mutex_lock(&common->mutex);
+	if (!rsi_send_bgscan_params(common, 1)) {
+		if (!rsi_send_bgscan_probe_req(common)) {
+#ifdef PLATFORM_X86
+			rsi_dbg(INFO_ZONE, "Background scan started ===>\n");
+#endif
+			common->bgscan_en = 1;
+		} else {
+#ifdef PLATFORM_X86
+			rsi_dbg(ERR_ZONE, "Failed sending bgscan probe req\n");
+#endif
+			common->bgscan_en = 0;
+			g_bgscan_enable = 0;
+		}
+	
+} else {
+#ifdef PLATFORM_X86
+		rsi_dbg(ERR_ZONE, "Failed sending bgscan params req\n");
+#endif
+	}
+	mutex_unlock(&common->mutex);
+
+	return total_bytes;
+}
+
 #define FOPS(fopen) { \
 	.owner = THIS_MODULE, \
 	.open = (fopen), \
@@ -271,6 +493,7 @@ static const struct rsi_dbg_files dev_debugfs_files[] = {
 	{"version", 0644, FOPS(rsi_version_open),},
 	{"stats", 0644, FOPS(rsi_stats_open),},
 	{"debug_zone", 0666, FOPS_RW(rsi_debug_read, rsi_debug_zone_write),},
+	{"bgscan", 0666, FOPS_RW(rsi_bgscan_read, rsi_bgscan_write),},
 	{"sdio_stats", 0644, FOPS(rsi_sdio_stats_open),},
 };
 
diff --git a/drivers/net/wireless/rsi/rsi_91x_hal.c b/drivers/net/wireless/rsi/rsi_91x_hal.c
new file mode 100644
index 0000000..a383692
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_hal.c
@@ -0,0 +1,1262 @@
+/**
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/firmware.h>
+#include <linux/version.h>
+#include <linux/jiffies.h>
+#include <net/bluetooth/bluetooth.h>
+#include "rsi_mgmt.h"
+#include "rsi_hal.h"
+#include "rsi_sdio.h"
+#include "rsi_common.h"
+#if defined(CONFIG_RSI_COEX) || defined(CONFIG_RSI_BT_ALONE)
+#include "rsi_hci.h"
+#endif
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
+
+/* FLASH Firmware */
+struct ta_metadata metadata_flash_content[] = {
+	{"flash_content", 0x00010000},
+	{"RS9113_WLAN_QSPI.rps", 0x00010000},
+	{"RS9113_WLAN_BT_DUAL_MODE.rps", 0x00010000},
+	{"RS9113_WLAN_ZIGBEE.rps", 0x00010000},
+	{"RS9113_AP_BT_DUAL_MODE.rps", 0x00010000},
+	{"RS9113_WLAN_QSPI.rps", 0x00010000}
+};
+
+/**
+ * rsi_send_pkt() - This function sends the received packet from
+ *			 driver to device.
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_send_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	int status = -EINVAL;
+
+//#ifdef CONFIG_RSI_COEX
+	//down(&coex_cb->tx_bus_lock);
+	down(&common->tx_bus_lock);
+//#endif
+	status = adapter->host_intf_ops->write_pkt(common->priv,
+						   skb->data, skb->len);
+//#ifdef CONFIG_RSI_COEX
+	up(&common->tx_bus_lock);
+//#endif
+	return status;
+}
+
+/**
+ * rsi_prepare_data_desc() - This function prepares the device specific descriptor
+ *			     for the given data packet
+ *
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, negative error code on failure.
+ */
+int rsi_prepare_data_desc(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = NULL;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	int status = -EINVAL;
+	u8 ieee80211_hdr_size = MIN_802_11_HDR_LEN;
+	u8 dword_align_bytes = 0;
+	u8 header_size = 0;
+	__le16 *frame_desc;
+	struct xtended_desc *xtend_desc;
+	u16 seq_num = 0;
+	u8 vap_id = 0;
+
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+
+	header_size = FRAME_DESC_SZ + sizeof(struct xtended_desc);
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE, "%s: Not enough headroom\n", __func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, header_size);
+	dword_align_bytes = ((unsigned long)skb->data & 0x3f);
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE, "%s: Not enough headroom\n", __func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, dword_align_bytes);
+	header_size += dword_align_bytes;
+
+	tx_params->internal_hdr_size = header_size;
+	frame_desc = (__le16 *)&skb->data[0];
+	xtend_desc = (struct xtended_desc *)&skb->data[FRAME_DESC_SZ];
+	memset((u8 *)frame_desc, 0, header_size);
+
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+	seq_num = le16_to_cpu(IEEE80211_SEQ_TO_SN(wh->seq_ctrl));
+	vif = rsi_get_vif(adapter, wh->addr2);
+	vap_id = ((struct vif_priv *)vif->drv_priv)->vap_id;
+
+	frame_desc[2] = cpu_to_le16(header_size - FRAME_DESC_SZ);
+	if (ieee80211_is_data_qos(wh->frame_control)) {
+		ieee80211_hdr_size += 2;
+		frame_desc[6] |= cpu_to_le16(BIT(12));
+	}
+
+	if ((vif->type == NL80211_IFTYPE_STATION) &&
+	    (adapter->ps_state == PS_ENABLED))
+		wh->frame_control |= BIT(12);
+
+	if ((!(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) &&
+	    (common->secinfo.security_enable)) {
+		if (rsi_is_cipher_wep(common))
+			ieee80211_hdr_size += 4;
+		else
+			ieee80211_hdr_size += 8;
+		frame_desc[6] |= cpu_to_le16(BIT(15));
+	}
+
+	frame_desc[0] = cpu_to_le16((skb->len - FRAME_DESC_SZ) |
+				    (RSI_WIFI_DATA_Q << 12));
+	frame_desc[2] |= cpu_to_le16(ieee80211_hdr_size << 8);
+
+	if (common->min_rate != 0xffff) {
+		/* Send fixed rate */
+		frame_desc[3] = cpu_to_le16(RATE_INFO_ENABLE);
+		frame_desc[4] = cpu_to_le16(common->min_rate);
+
+		if (conf_is_ht40(&common->priv->hw->conf))
+			frame_desc[5] = cpu_to_le16(FULL40M_ENABLE);
+
+		if ((common->vif_info[0].sgi) && (common->min_rate & 0x100)) {
+			/* Only MCS rates */
+			frame_desc[4] |= cpu_to_le16(ENABLE_SHORTGI_RATE);
+		}
+	}
+
+	if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
+		rsi_dbg(INFO_ZONE, "*** Tx EAPOL ***\n");
+		
+		frame_desc[3] = cpu_to_le16(RATE_INFO_ENABLE);
+		if (common->band == NL80211_BAND_5GHZ)
+			frame_desc[4] = cpu_to_le16(RSI_RATE_6);
+		else
+			frame_desc[4] = cpu_to_le16(RSI_RATE_1);
+		frame_desc[6] |= cpu_to_le16(BIT(13));
+		frame_desc[1] |= cpu_to_le16(BIT(12));
+		if (vif->type == NL80211_IFTYPE_STATION) {
+		if (common->eapol4_confirm) {
+			/* Eapol Rekeying , Change the priority to Voice _Q
+			 * XXX: Check for AP*/ 
+			skb->priority = VO_Q;
+		} else {
+			frame_desc[0] = cpu_to_le16((skb->len - FRAME_DESC_SZ) |
+						    (RSI_WIFI_MGMT_Q << 12));
+		}
+			if ((skb->len - header_size) == 133) {
+				rsi_dbg(INFO_ZONE, "*** Tx EAPOL 4*****\n");
+				frame_desc[1] |=
+					cpu_to_le16(RSI_DESC_REQUIRE_CFM_TO_HOST);
+				xtend_desc->confirm_frame_type = EAPOL4_CONFIRM;
+			}
+		}
+#define EAPOL_RETRY_CNT 15
+		xtend_desc->retry_cnt = EAPOL_RETRY_CNT;
+	}
+
+	frame_desc[6] |= cpu_to_le16(seq_num);
+	frame_desc[7] = cpu_to_le16(((tx_params->tid & 0xf) << 4) |
+				    (skb->priority & 0xf) |
+				    (tx_params->sta_id << 8));
+
+	if ((is_broadcast_ether_addr(wh->addr1)) ||
+	    (is_multicast_ether_addr(wh->addr1))) {
+		frame_desc[3] = cpu_to_le16(RATE_INFO_ENABLE);
+		frame_desc[3] |= cpu_to_le16(RSI_BROADCAST_PKT);
+		if ((vif->type == NL80211_IFTYPE_AP) ||
+		    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+			if (common->band == NL80211_BAND_5GHZ)
+				frame_desc[4] = cpu_to_le16(RSI_RATE_6);
+			else
+				frame_desc[4] = cpu_to_le16(RSI_RATE_1);
+		}
+		frame_desc[7] = cpu_to_le16(((tx_params->tid & 0xf) << 4) |
+					    (skb->priority & 0xf) |
+					    (vap_id << 8));
+	}
+
+	if (((vif->type == NL80211_IFTYPE_AP) ||
+	     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+	    (ieee80211_has_moredata(wh->frame_control)))
+		frame_desc[3] |= cpu_to_le16(MORE_DATA_PRESENT);
+
+	return 0;
+
+err:
+	++common->tx_stats.total_tx_pkt_freed[skb->priority];
+	rsi_indicate_tx_status(adapter, skb, status);
+	return status;
+}
+
+/**
+ * rsi_prepare_mgmt_desc() - This functions prepares the descriptor for
+ *			     the given management packet.
+ *
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_prepare_mgmt_desc(struct rsi_common *common,struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_conf *conf = &adapter->hw->conf;
+	struct ieee80211_vif *vif = NULL;
+	struct skb_info *tx_params;
+	int status = -EINVAL;
+	__le16 *desc = NULL;
+	struct xtended_desc *xtend_desc = NULL;
+	u8 header_size = 0;
+	u8 vap_id = 0;
+	u32 dword_align_bytes = 0;
+
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+
+	/* Update header size */
+	header_size = FRAME_DESC_SZ + sizeof(struct xtended_desc);
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to add extended descriptor\n",
+			__func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, header_size);
+	dword_align_bytes = ((unsigned long)skb->data & 0x3f);
+	if (dword_align_bytes > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to add dword align\n", __func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, dword_align_bytes);
+	header_size += dword_align_bytes;
+
+	tx_params->internal_hdr_size = header_size;
+	memset(&skb->data[0], 0, header_size);
+
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+	vif = rsi_get_vif(adapter, wh->addr2);
+	vap_id = ((struct vif_priv *)vif->drv_priv)->vap_id;
+
+	desc = (__le16 *)skb->data;
+	xtend_desc = (struct xtended_desc *)&skb->data[FRAME_DESC_SZ];
+
+	if (skb->len > MAX_MGMT_PKT_SIZE) {
+		rsi_dbg(INFO_ZONE, "%s: Dropping mgmt pkt > 512\n", __func__);
+		goto err;
+	}
+
+	desc[0] = cpu_to_le16((skb->len - FRAME_DESC_SZ) |
+			      (RSI_WIFI_MGMT_Q << 12));
+	desc[1] = cpu_to_le16(TX_DOT11_MGMT);
+	desc[2] = cpu_to_le16(MIN_802_11_HDR_LEN << 8);
+	desc[2] |= cpu_to_le16(header_size - FRAME_DESC_SZ);
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	if (ieee80211_is_probe_req(wh->frame_control) && 
+		(common->scan_in_prog))
+	desc[3] = cpu_to_le16(INSERT_SEQ_IN_FW);
+#endif
+	desc[3] |= cpu_to_le16(RATE_INFO_ENABLE);
+	if (wh->addr1[0] & BIT(0))
+		desc[3] |= cpu_to_le16(RSI_BROADCAST_PKT);
+	desc[6] = cpu_to_le16(IEEE80211_SEQ_TO_SN(wh->seq_ctrl));
+
+	if (common->band == NL80211_BAND_2GHZ)
+		if (!common->p2p_enabled)
+			desc[4] = cpu_to_le16(RSI_RATE_1);
+		else
+			desc[4] = cpu_to_le16(RSI_RATE_6);
+	else
+		desc[4] = cpu_to_le16(RSI_RATE_6);
+
+	if (conf_is_ht40(conf)) {
+		desc[5] = cpu_to_le16(FULL40M_ENABLE);
+	}
+
+	if (ieee80211_is_probe_resp(wh->frame_control)) {
+		desc[1] |= cpu_to_le16(ADD_DELTA_TSF_VAP_ID |
+				       FETCH_RETRY_CNT_FRM_HST);
+#define PROBE_RESP_RETRY_CNT	3
+		xtend_desc->retry_cnt = PROBE_RESP_RETRY_CNT;
+	}
+
+	if (((vif->type == NL80211_IFTYPE_AP) ||
+	     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+	    (ieee80211_is_action(wh->frame_control))) {
+		struct rsi_sta *sta = rsi_find_sta(common, wh->addr1);
+
+		if (sta)
+			desc[7] |= cpu_to_le16(sta->sta_id << 8);
+		else
+			goto err;
+	} else
+		desc[7] |= cpu_to_le16(vap_id << 8); /* Station ID */
+	desc[4] |= cpu_to_le16(vap_id << 14);
+
+	return 0;
+
+err:
+	return status;
+}
+
+/**
+ * rsi_send_data_pkt() - This function sends the received data packet from
+ *			 driver to device.
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_send_data_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = NULL;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	struct ieee80211_bss_conf *bss = NULL;
+	int status = -EINVAL;
+	u8 header_size = 0;
+
+	if (!skb)
+		return 0;
+	if (common->iface_down)
+		goto err;
+	info = IEEE80211_SKB_CB(skb);
+	if (!info->control.vif)
+		goto err;
+	bss = &info->control.vif->bss_conf;
+	tx_params = (struct skb_info *)info->driver_data;
+
+	header_size = tx_params->internal_hdr_size;
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+	vif = rsi_get_vif(adapter, wh->addr2);
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		if (!bss->assoc)
+			goto err;
+		if (!ether_addr_equal(wh->addr1, bss->bssid))
+			goto err;
+	}
+
+	rsi_dbg(INFO_ZONE, "hal: Sending data pkt");
+	rsi_hex_dump(DATA_TX_ZONE, "TX data pkt", skb->data, skb->len);
+
+	status = rsi_send_pkt(common, skb);
+	if (status)
+		rsi_dbg(ERR_ZONE, "%s: Failed to write data pkt\n", __func__);
+
+err:
+	++common->tx_stats.total_tx_pkt_freed[skb->priority];
+	rsi_indicate_tx_status(common->priv, skb, status);
+	return status;
+}
+
+/**
+ * rsi_send_mgmt_pkt() - This function prepares sends the given mgmt packet
+ *			 to device.
+ *
+ * @common: Pointer to the driver private structure.
+ * @skb: Pointer to the socket buffer structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_send_mgmt_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_hdr *wh = NULL;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	u8 header_size = 0;
+	int status = -EINVAL;
+	struct ieee80211_bss_conf *bss = NULL;
+	__le16 *desc = NULL;
+	struct xtended_desc *xtend_desc = NULL;
+
+	if (!skb)
+		return 0;
+
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+	header_size = tx_params->internal_hdr_size;
+
+	if (tx_params->flags & INTERNAL_MGMT_PKT) {
+		skb->data[1] |= BIT(7); /* Immediate Wakeup bit*/
+		rsi_hex_dump(MGMT_TX_ZONE,
+			     "Tx Command Packet",
+			     skb->data, skb->len);
+
+		status = rsi_send_pkt(common, skb);
+		if (status) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to write the packet\n",
+				__func__);
+		}
+		dev_kfree_skb(skb);
+		return status;
+	}
+
+	if (common->iface_down)
+		goto out;
+	if (!info->control.vif)
+		goto out;
+	bss = &info->control.vif->bss_conf;
+	wh = (struct ieee80211_hdr *)&skb->data[header_size];
+
+	desc = (__le16 *)skb->data;
+	xtend_desc = (struct xtended_desc *)&skb->data[FRAME_DESC_SZ];
+
+	/* Indicate to firmware to give cfm */
+	if (ieee80211_is_probe_req(wh->frame_control)) {
+		if (!bss->assoc) {
+			rsi_dbg(INFO_ZONE,
+				"%s: blocking mgmt queue\n", __func__);
+			desc[1] |= cpu_to_le16(RSI_DESC_REQUIRE_CFM_TO_HOST);
+			xtend_desc->confirm_frame_type = PROBEREQ_CONFIRM;
+			common->mgmt_q_block = true;
+			rsi_dbg(INFO_ZONE, "Mgmt queue blocked\n");
+		} else if (common->bgscan_en) {
+			if (common->mac80211_cur_channel !=
+			    rsi_get_connected_channel(adapter)) { 
+				/* Drop off channel probe request */
+				status = 0;
+				goto out;
+			} else if (wh->addr1[0] == 0xff) {
+				/* Drop broadcast probe in connected channel*/
+				status = 0;
+				goto out;
+			}
+		}
+		rsi_dbg(MGMT_TX_ZONE, "Sending PROBE REQUEST =====>\n");
+	}
+	
+	rsi_dbg(MGMT_TX_ZONE,
+		"Sending Packet : %s =====>\n",
+		dot11_pkt_type(wh->frame_control));
+
+	rsi_hex_dump(MGMT_TX_ZONE, "Tx Mgmt Packet", skb->data, skb->len);
+	status = rsi_send_pkt(common, skb);
+
+	if (status) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to write the packet\n",
+			__func__);
+	}
+
+out:
+	rsi_indicate_tx_status(common->priv, skb, status);
+	return status;
+}
+
+int rsi_send_bt_pkt(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = common->priv;
+	int status = -EINVAL;
+	u8 header_size = 0;
+	__le16 *frame_desc;
+
+	header_size = FRAME_DESC_SZ;
+	if (header_size > skb_headroom(skb)) {
+		rsi_dbg(ERR_ZONE, "%s: Not enough headroom\n", __func__);
+		status = -ENOSPC;
+		goto err;
+	}
+	skb_push(skb, header_size);
+	frame_desc = (__le16 *)&skb->data[0];
+	memset((u8 *)frame_desc, 0, header_size);
+
+	frame_desc[0] = cpu_to_le16(skb->len - FRAME_DESC_SZ);
+	frame_desc[0] |= (cpu_to_le16(RSI_BT_DATA_Q) & 0x7) << 12;
+
+	frame_desc[7] = cpu_to_le16(bt_cb(skb)->pkt_type);
+
+	rsi_hex_dump(DATA_TX_ZONE, "TX BT pkt", skb->data, skb->len);
+	status = adapter->host_intf_ops->write_pkt(common->priv,
+						   skb->data, skb->len);
+	if (status)
+		rsi_dbg(ERR_ZONE, "%s: Failed to write bt pkt\n", __func__);
+
+err:
+	dev_kfree_skb(skb);
+	return status;
+}
+
+int rsi_prepare_beacon(struct rsi_common *common, struct sk_buff *skb)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)common->priv;
+	struct rsi_mac_frame *bcn_frm = NULL;
+	struct ieee80211_hw *hw = common->priv->hw;
+	struct ieee80211_conf *conf = &hw->conf;
+	struct sk_buff *mac_bcn = NULL;
+	u8 vap_id = 0;
+	int status = 0;
+	u16 tim_offset = 0;
+
+	mac_bcn = ieee80211_beacon_get_tim(adapter->hw,
+					   adapter->vifs[adapter->sc_nvifs - 1],
+					   &tim_offset, NULL);
+	if (!mac_bcn) {
+		rsi_dbg(ERR_ZONE, "Failed to get beacon from mac80211\n");
+		return -EINVAL;
+	}
+
+	common->beacon_cnt++;
+	bcn_frm = (struct rsi_mac_frame *)skb->data;
+	bcn_frm->desc_word[0] = cpu_to_le16(mac_bcn->len |
+					    (RSI_WIFI_DATA_Q << 12));
+	bcn_frm->desc_word[1] = 0; // FIXME: Fill type later
+	bcn_frm->desc_word[2] = cpu_to_le16(MIN_802_11_HDR_LEN << 8);
+	bcn_frm->desc_word[3] = cpu_to_le16(MAC_BBP_INFO | NO_ACK_IND |
+					    BEACON_FRAME | INSERT_TSF |
+					    INSERT_SEQ_NO);
+	bcn_frm->desc_word[3] |= cpu_to_le16(RATE_INFO_ENABLE);
+	bcn_frm->desc_word[4] = cpu_to_le16(vap_id << 14);
+	bcn_frm->desc_word[7] = cpu_to_le16(BEACON_HW_Q);
+	
+	if (conf_is_ht40_plus(conf)) {
+		bcn_frm->desc_word[5] = cpu_to_le16(LOWER_20_ENABLE);
+		bcn_frm->desc_word[5] |= cpu_to_le16(LOWER_20_ENABLE >> 12);
+	} else if (conf_is_ht40_minus(conf)) {
+		bcn_frm->desc_word[5] = cpu_to_le16(UPPER_20_ENABLE);
+		bcn_frm->desc_word[5] |= cpu_to_le16(UPPER_20_ENABLE >> 12);
+	}
+
+	if (common->band == NL80211_BAND_2GHZ) {
+		if (common->p2p_enabled)
+			bcn_frm->desc_word[4] |= cpu_to_le16(RSI_RATE_6);
+		else
+			bcn_frm->desc_word[4] |= cpu_to_le16(RSI_RATE_1);
+	} else
+		bcn_frm->desc_word[4] |= cpu_to_le16(RSI_RATE_6);
+
+	if (mac_bcn->data[tim_offset + 2] == 0)
+		bcn_frm->desc_word[3] |= cpu_to_le16(DTIM_BEACON);
+
+	memcpy(&skb->data[FRAME_DESC_SZ], mac_bcn->data, mac_bcn->len);
+	skb_put(skb, mac_bcn->len + FRAME_DESC_SZ);
+
+	rsi_hex_dump(MGMT_TX_ZONE, "Beacon Frame", skb->data, skb->len);	
+
+	if (mac_bcn)
+		dev_kfree_skb(mac_bcn);
+
+	return status;
+}
+
+/**
+ * bl_cmd_timeout() - This function is called when BL command timed out
+ * @priv: Pointer to the hardware structure.
+ *
+ * Return: NONE.
+ */
+static void bl_cmd_timeout(unsigned long priv)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)priv;
+
+	adapter->blcmd_timer_expired = 1;
+	del_timer(&adapter->bl_cmd_timer);
+}
+
+/**
+ * bl_start_cmd_timer() - This function starts the BL command timer
+ * @adapter: Pointer to the hardware structure.
+ * @timeout: Timeout of the command in milliseconds
+ *
+ * Return: 0 on success.
+ */
+static int bl_start_cmd_timer(struct rsi_hw *adapter, u32 timeout)
+{
+	init_timer(&adapter->bl_cmd_timer);
+	adapter->bl_cmd_timer.data = (unsigned long)adapter;
+	adapter->bl_cmd_timer.function = (void *)&bl_cmd_timeout;
+	adapter->bl_cmd_timer.expires = (msecs_to_jiffies(timeout) + jiffies);
+
+	adapter->blcmd_timer_expired = 0;
+	add_timer(&adapter->bl_cmd_timer);
+
+	return 0;
+}
+
+/**
+ * bl_stop_cmd_timer() - This function stops the BL command timer
+ * @adapter: Pointer to the hardware structure.
+ *
+ * Return: 0 on success.
+ */
+static int bl_stop_cmd_timer(struct rsi_hw *adapter)
+{
+	adapter->blcmd_timer_expired = 0;
+	if (timer_pending(&adapter->bl_cmd_timer))
+		del_timer(&adapter->bl_cmd_timer);
+
+	return 0;
+}
+
+/**
+ * bl_write_cmd() - This function writes the BL command to device
+ * @adapter: Pointer to the hardware structure.
+ * @cmd: Command to write
+ * @exp_resp: Expected Response
+ * @cmd_resp: Received Response
+ *
+ * Return: 0 on success.
+ */
+int bl_write_cmd(struct rsi_hw *adapter, u8 cmd, u8 exp_resp, u16 *cmd_resp)
+{
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	u32 regin_val = 0, regout_val = 0;
+	u8 output = 0;
+	u32 regin_input = 0;
+
+	regin_input = (REGIN_INPUT | adapter->priv->coex_mode);
+
+	while (!adapter->blcmd_timer_expired) {
+		regin_val = 0;
+		if (hif_ops->master_reg_read(adapter,
+					     SWBL_REGIN,
+					     &regin_val,
+					     2) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Command %0x REGIN reading failed..\n",
+				__func__, cmd);
+			goto fail;
+		}
+		mdelay(1);
+		if ((regin_val >> 12) != REGIN_VALID)
+			break;
+	}
+	if (adapter->blcmd_timer_expired) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %0x REGIN reading timed out..\n",
+			__func__, cmd);
+		goto fail;
+	}
+
+	rsi_dbg(INFO_ZONE,
+		"Issuing write to Regin val:%0x sending cmd:%0x\n",
+		regin_val, (cmd | regin_input << 8));
+	if ((hif_ops->master_reg_write(adapter,
+				       SWBL_REGIN,
+				       (cmd | regin_input << 8),
+				       2)) < 0) {
+		goto fail;
+	}
+	mdelay(1);
+
+	if (cmd == LOAD_HOSTED_FW || cmd == JUMP_TO_ZERO_PC) {
+		/* JUMP_TO_ZERO_PC doesn't expect
+		 * any response. So return from here
+		 */
+		return 0;
+	}
+
+	while (!adapter->blcmd_timer_expired) {
+		regout_val = 0;
+		if (hif_ops->master_reg_read(adapter,
+					     SWBL_REGOUT,
+					     &regout_val,
+					     2) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Command %0x REGOUT reading failed..\n",
+				__func__, cmd);
+			goto fail;
+		}
+		mdelay(1);
+		if ((regout_val >> 8) == REGOUT_VALID)
+			break;
+	}
+	if (adapter->blcmd_timer_expired) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %0x REGOUT reading timed out..\n",
+			__func__, cmd);
+		goto fail;
+	}
+
+	*cmd_resp = ((u16 *)&regout_val)[0] & 0xffff;
+
+	output = ((u8 *)&regout_val)[0] & 0xff;
+
+	if ((hif_ops->master_reg_write(adapter,
+				       SWBL_REGOUT,
+				       (cmd | REGOUT_INVALID << 8),
+				       2)) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %0x REGOUT writing failed..\n",
+			__func__, cmd);
+		goto fail;
+	}
+	mdelay(1);
+
+	if (output == exp_resp) {
+		rsi_dbg(INFO_ZONE,
+			"%s: Recvd Expected resp %x for cmd %0x\n",
+			__func__, output, cmd);
+	} else {
+		rsi_dbg(ERR_ZONE,
+			"%s: Recvd resp %x for cmd %0x\n",
+			__func__, output, cmd);
+		goto fail;
+	}
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * bl_cmd() - This function initiates the BL command
+ * @adapter: Pointer to the hardware structure.
+ * @cmd: Command to write
+ * @exp_resp: Expected Response
+ * @str: Command string
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+int bl_cmd(struct rsi_hw *adapter, u8 cmd, u8 exp_resp, char *str)
+{
+	u16 regout_val = 0;
+	u32 timeout = 0;
+
+	if ((cmd == EOF_REACHED) || (cmd == PING_VALID) || (cmd == PONG_VALID))
+		timeout = BL_BURN_TIMEOUT;
+	else
+		timeout = BL_CMD_TIMEOUT;
+
+	bl_start_cmd_timer(adapter, timeout);
+	if (bl_write_cmd(adapter, cmd, exp_resp, &regout_val) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Command %s (%0x) writing failed..\n",
+			__func__, str, cmd);
+		goto fail;
+	}
+	bl_stop_cmd_timer(adapter);
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * bl_write_header() - This function writes the BL header
+ * @adapter: Pointer to the hardware structure.
+ * @flash_content: Flash content
+ * @content_size: Flash content size
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int bl_write_header(struct rsi_hw *adapter,
+			   u8 *flash_content, u32 content_size)
+{
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	struct bl_header bl_hdr;
+	u32 write_addr, write_len;
+
+#define CHECK_SUM_OFFSET 20
+#define LEN_OFFSET 8
+#define ADDR_OFFSET 16
+
+	bl_hdr.flags = 0;
+	bl_hdr.image_no = cpu_to_le32(adapter->priv->coex_mode);
+	bl_hdr.check_sum = cpu_to_le32(
+				*(u32 *)&flash_content[CHECK_SUM_OFFSET]);
+	bl_hdr.flash_start_address = cpu_to_le32(
+					*(u32 *)&flash_content[ADDR_OFFSET]);
+	bl_hdr.flash_len = cpu_to_le32(*(u32 *)&flash_content[LEN_OFFSET]);
+	write_len = sizeof(struct bl_header);
+
+	if (adapter->rsi_host_intf == RSI_HOST_INTF_USB) {
+		write_addr = PING_BUFFER_ADDRESS;
+		if ((hif_ops->write_reg_multiple(adapter,
+						 write_addr,
+						 (u8 *)&bl_hdr,
+						 write_len)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to load Version/CRC structure\n",
+				__func__);
+			goto fail;
+		}
+	} else {
+		write_addr = PING_BUFFER_ADDRESS >> 16;
+		if ((hif_ops->master_access_msword(adapter, write_addr)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Unable to set ms word to common reg\n",
+				__func__);
+			goto fail;
+		}
+		write_addr = SD_REQUEST_MASTER |
+			     (PING_BUFFER_ADDRESS & 0xFFFF);
+		if ((hif_ops->write_reg_multiple(adapter,
+						 write_addr,
+						 (u8 *)&bl_hdr,
+						 write_len)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to load Version/CRC structure\n",
+				__func__);
+			goto fail;
+		}
+	}
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * read_flash_capacity() - This function reads the flash size from device
+ * @adapter: Pointer to the hardware structure.
+ *
+ * Return: flash capacity on success, 0 on failure.
+ */
+static u32 read_flash_capacity(struct rsi_hw *adapter)
+{
+	u32 flash_sz = 0;
+
+	if ((adapter->host_intf_ops->master_reg_read(adapter,
+						     FLASH_SIZE_ADDR,
+						     &flash_sz, 2)) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Flash size reading failed..\n",
+			__func__);
+		return 0;
+	}
+	rsi_dbg(INIT_ZONE, "Flash capacity: %d KiloBytes\n", flash_sz);
+
+	return (flash_sz * 1024); /* Return size in kbytes */
+}
+
+/**
+ * ping_pong_write() - This function writes the flash contents throgh ping
+ *			pong buffers
+ * @adapter: Pointer to the hardware structure.
+ * @cmd: command ping/pong write
+ * @addr: address to write
+ * @size: size
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int ping_pong_write(struct rsi_hw *adapter, u8 cmd, u8 *addr, u32 size)
+{
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	u32 block_size = 0;
+	u32 cmd_addr;
+	u16 cmd_resp = 0, cmd_req = 0;
+	u8 *str;
+
+	if (adapter->rsi_host_intf == RSI_HOST_INTF_SDIO)
+		block_size = 256;
+	else
+		block_size = 252;
+
+	if (cmd == PING_WRITE) {
+		cmd_addr = PING_BUFFER_ADDRESS;
+		cmd_resp = PONG_AVAIL;
+		cmd_req = PING_VALID;
+		str = "PING_VALID";
+	} else {
+		cmd_addr = PONG_BUFFER_ADDRESS;
+		cmd_resp = PING_AVAIL;
+		cmd_req = PONG_VALID;
+		str = "PONG_VALID";
+	}
+
+	if (hif_ops->load_data_master_write(adapter,
+					    cmd_addr,
+					    size,
+					    block_size,
+					    addr)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to write blk at addr %0x\n",
+			__func__, *addr);
+		goto fail;
+	}
+	if (bl_cmd(adapter, cmd_req, cmd_resp, str) < 0) {
+		bl_stop_cmd_timer(adapter);
+		goto fail;
+	}
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * auto_fw_upgrade() - This function loads the firmware to device
+ * @adapter: Pointer to the hardware structure.
+ * @flash_content: Firmware to load
+ * @content_size: Size of the firmware
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int auto_fw_upgrade(struct rsi_hw *adapter,
+			   u8 *flash_content,
+			   u32 content_size)
+{
+	u8 cmd;
+	u8 *temp_flash_content;
+	u32 temp_content_size;
+	u32 num_flash;
+	u32 index;
+	u32 flash_start_address;
+
+	temp_flash_content = flash_content;
+
+	if (content_size > MAX_FLASH_FILE_SIZE) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Flash Content size is more than 400K %u\n",
+			__func__, MAX_FLASH_FILE_SIZE);
+		goto fail;
+	}
+
+	flash_start_address = cpu_to_le32(
+				*(u32 *)&flash_content[FLASHING_START_ADDRESS]);
+	rsi_dbg(INFO_ZONE, "flash start address: %08x\n", flash_start_address);
+
+	if (flash_start_address < FW_IMAGE_MIN_ADDRESS) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Fw image Flash Start Address is less than 64K\n",
+			__func__);
+		goto fail;
+	}
+
+	if (flash_start_address % FLASH_SECTOR_SIZE) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Flash Start Address is not multiple of 4K\n",
+			__func__);
+		goto fail;
+	}
+
+	if ((flash_start_address + content_size) > adapter->flash_capacity) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Flash Content will cross max flash size\n",
+			__func__);
+		goto fail;
+	}
+
+	temp_content_size  = content_size;
+	num_flash = content_size / FLASH_WRITE_CHUNK_SIZE;
+
+	rsi_dbg(INFO_ZONE, "content_size: %d\n", content_size);
+	rsi_dbg(INFO_ZONE, "num_flash: %d\n", num_flash);
+
+	for (index = 0; index <= num_flash; index++) {
+		rsi_dbg(INFO_ZONE, "flash index: %d\n", index);
+		if (index != num_flash) {
+			content_size = FLASH_WRITE_CHUNK_SIZE;
+			rsi_dbg(INFO_ZONE,
+				"QSPI content_size:%d\n",
+				content_size);
+		} else {
+			content_size =
+				temp_content_size % FLASH_WRITE_CHUNK_SIZE;
+			rsi_dbg(INFO_ZONE,
+				"Writing last sector content_size:%d\n",
+				content_size);
+			if (!content_size) {
+				rsi_dbg(INFO_ZONE, "INSTRUCTION SIZE ZERO\n");
+				break;
+			}
+		}
+
+		if (index % 2)
+			cmd = PING_WRITE;
+		else
+			cmd = PONG_WRITE;
+
+		if (ping_pong_write(adapter,
+				    cmd,
+				    flash_content,
+				    content_size)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Unable to load %d block\n",
+				__func__, index);
+			goto fail;
+		}
+
+		rsi_dbg(INFO_ZONE,
+			"%s: Successfully loaded %d instructions\n",
+			__func__, index);
+		flash_content += content_size;
+	}
+
+	if (bl_cmd(adapter, EOF_REACHED, FW_LOADING_SUCCESSFUL,
+		   "EOF_REACHED") < 0) {
+		bl_stop_cmd_timer(adapter);
+		goto fail;
+	}
+	rsi_dbg(INFO_ZONE, "FW loading is done and FW is running..\n");
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+/**
+ * rsi_load_9113_firmware () - This function loads the TA firmware for 9113
+ *				device.
+ * @adapter: Pointer to the rsi hw.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_load_9113_firmware(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+	struct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;
+	const struct firmware *fw_entry = NULL;
+	u32 regout_val = 0;
+	u16 tmp_regout_val = 0;
+	u8 *flash_content = NULL;
+	u32 content_size = 0;
+	struct ta_metadata *metadata_p;
+
+	bl_start_cmd_timer(adapter, BL_CMD_TIMEOUT);
+
+	while (!adapter->blcmd_timer_expired) {
+		if ((hif_ops->master_reg_read(adapter,
+					      SWBL_REGOUT,
+					      &regout_val,
+					      2)) < 0) {
+			rsi_dbg(ERR_ZONE,
+				"%s: REGOUT read failed\n", __func__);
+			goto fail;
+		}
+		mdelay(1);
+		if ((regout_val >> 8) == REGOUT_VALID)
+			break;
+	}
+	if (adapter->blcmd_timer_expired) {
+		rsi_dbg(ERR_ZONE, "%s: REGOUT read timedout\n", __func__);
+		rsi_dbg(ERR_ZONE,
+			"%s: Soft boot loader not present\n", __func__);
+		goto fail;
+	}
+	bl_stop_cmd_timer(adapter);
+
+	rsi_dbg(INFO_ZONE, "Received Board Version Number: %x\n",
+		(regout_val & 0xff));
+
+	if ((hif_ops->master_reg_write(adapter,
+				       SWBL_REGOUT,
+				       (REGOUT_INVALID | REGOUT_INVALID << 8),
+				       2)) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: REGOUT writing failed..\n", __func__);
+		goto fail;
+	}
+	mdelay(1);
+
+	if ((bl_cmd(adapter, CONFIG_AUTO_READ_MODE, CMD_PASS,
+		    "AUTO_READ_CMD")) < 0)
+		goto fail;
+
+	adapter->flash_capacity = read_flash_capacity(adapter);
+	if (adapter->flash_capacity <= 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to read flash size from EEPROM\n",
+			__func__);
+		goto fail;
+	}
+
+	metadata_p = &metadata_flash_content[adapter->priv->coex_mode];
+
+	rsi_dbg(INIT_ZONE, "%s: Loading file %s\n", __func__, metadata_p->name);
+	adapter->fw_file_name = metadata_p->name;
+
+	if ((request_firmware(&fw_entry, metadata_p->name,
+			      adapter->device)) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to open file %s\n",
+			__func__, metadata_p->name);
+		goto fail;
+	}
+	flash_content = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
+	if (!flash_content) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to copy firmware\n", __func__);
+		goto fail;
+	}
+	content_size = fw_entry->size;
+	rsi_dbg(INFO_ZONE, "FW Length = %d bytes\n", content_size);
+
+	/* Get the firmware version */
+	common->lmac_ver.ver.info.fw_ver[0] =
+		flash_content[LMAC_VER_OFFSET] & 0xFF;
+	common->lmac_ver.ver.info.fw_ver[1] =
+		flash_content[LMAC_VER_OFFSET+1] & 0xFF;
+	common->lmac_ver.major = flash_content[LMAC_VER_OFFSET + 2] & 0xFF;
+	common->lmac_ver.release_num =
+		flash_content[LMAC_VER_OFFSET + 3] & 0xFF;
+	common->lmac_ver.minor = flash_content[LMAC_VER_OFFSET + 4] & 0xFF;
+	common->lmac_ver.patch_num = 0;
+	rsi_print_version(common);
+
+	if (bl_write_header(adapter, flash_content, content_size)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: RPS Image header loading failed\n",
+			__func__);
+		goto fail;
+	}
+
+	bl_start_cmd_timer(adapter, BL_CMD_TIMEOUT);
+	if (bl_write_cmd(adapter, CHECK_CRC, CMD_PASS, &tmp_regout_val) < 0) {
+		bl_stop_cmd_timer(adapter);
+		rsi_dbg(ERR_ZONE,
+			"%s: CHECK_CRC Command writing failed..\n",
+			__func__);
+		if ((tmp_regout_val & 0xff) == CMD_FAIL) {
+			rsi_dbg(ERR_ZONE,
+				"CRC Fail.. Proceeding to Upgrade mode\n");
+			goto fw_upgrade;
+		}
+	}
+	bl_stop_cmd_timer(adapter);
+
+	if (bl_cmd(adapter, POLLING_MODE, CMD_PASS, "POLLING_MODE") < 0)
+		goto fail;
+
+load_image_cmd:
+	if ((bl_cmd(adapter,
+		    LOAD_HOSTED_FW,
+		    LOADING_INITIATED,
+		    "LOAD_HOSTED_FW")) < 0)
+		goto fail;
+	rsi_dbg(INFO_ZONE, "Load Image command passed..\n");
+	goto success;
+
+fw_upgrade:
+	if (bl_cmd(adapter, BURN_HOSTED_FW, SEND_RPS_FILE, "FW_UPGRADE") < 0)
+		goto fail;
+
+	rsi_dbg(INFO_ZONE, "Burn Command Pass.. Upgrading the firmware\n");
+
+	if (auto_fw_upgrade(adapter, flash_content, content_size) == 0) {
+		rsi_dbg(ERR_ZONE, "Firmware upgradation Done\n");
+		goto load_image_cmd;
+	}
+	rsi_dbg(ERR_ZONE, "Firmware upgrade failed\n");
+
+	if (bl_cmd(adapter, CONFIG_AUTO_READ_MODE,
+		   CMD_PASS, "AUTO_READ_MODE") < 0)
+		goto fail;
+
+success:
+	rsi_dbg(ERR_ZONE, "***** Firmware Loading successful *****\n");
+	kfree(flash_content);
+	release_firmware(fw_entry);
+	return 0;
+
+fail:
+	rsi_dbg(ERR_ZONE, "##### Firmware loading failed #####\n");
+	kfree(flash_content);
+	release_firmware(fw_entry);
+	return -EINVAL;
+}
+
+/**
+ * rsi_hal_device_init() - This function initializes the Device
+ * @adapter: Pointer to the hardware structure
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_hal_device_init(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+
+#if defined (CONFIG_RSI_COEX) || defined(CONFIG_RSI_BT_ALONE)
+	switch (common->oper_mode) {
+	case DEV_OPMODE_STA_BT_DUAL:
+	case DEV_OPMODE_STA_BT:
+	case DEV_OPMODE_STA_BT_LE:
+	case DEV_OPMODE_BT_ALONE:
+	case DEV_OPMODE_BT_LE_ALONE:
+		common->coex_mode = 2;
+		break;
+	case DEV_OPMODE_AP_BT_DUAL:
+	case DEV_OPMODE_AP_BT:
+		common->coex_mode = 4;
+		break;
+	default:
+		common->oper_mode = 1;
+		common->coex_mode = 1;
+	}
+#else
+	common->oper_mode = 1;
+	common->coex_mode = 1;
+#endif
+
+	rsi_dbg(INFO_ZONE, "%s: oper_mode = %d, coex_mode = %d\n",
+		__func__, common->oper_mode, common->coex_mode);
+
+	adapter->device_model = RSI_DEV_9113;
+	switch (adapter->device_model) {
+	case RSI_DEV_9110:
+		/* TODO: 9110 FW load */
+		break;
+	case RSI_DEV_9113:
+		if (rsi_load_9113_firmware(adapter)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: Failed to load TA instructions\n",
+				__func__);
+			return -EINVAL;
+		}
+		break;
+	case RSI_DEV_9116:
+		/* TODO: Add code for 9116 */
+		break;
+	default:
+		return -EINVAL;
+	}
+	adapter->common_hal_fsm = COMMAN_HAL_WAIT_FOR_CARD_READY;
+
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	adapter->priv->bt_fsm_state = BT_DEVICE_NOT_READY;
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rsi_hal_device_init);
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_hci.c b/drivers/net/wireless/rsi/rsi_91x_hci.c
new file mode 100644
index 0000000..07d94b2
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_hci.c
@@ -0,0 +1,547 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "rsi_hci.h"
+#include "rsi_mgmt.h"
+#include "rsi_coex.h"
+#include "rsi_hal.h"
+
+#define RSI_BT_GENL_FAMILY "RSI-BTgenl"
+#define RSI_USER_A_MAX	(__RSI_USER_A_MAX - 1)
+#define RSI_VERSION_NR	1
+
+static struct nla_policy bt_genl_policy[RSI_USER_A_MAX + 1] = {
+	[RSI_USER_A_MSG] = { .type = NLA_NUL_STRING },
+};
+
+static struct genl_family bt_genl_family = {
+	.id      = 0,
+	.hdrsize = 0,
+	.name    = RSI_BT_GENL_FAMILY,
+	.version = RSI_VERSION_NR,
+	.maxattr = RSI_USER_A_MAX,
+};
+
+static struct genl_ops bt_genl_ops = {
+	.cmd    = RSI_USER_C_CMD,
+	.flags  = 0,
+	.policy = bt_genl_policy,
+	.doit   = rsi_genl_recv,
+	.dumpit = NULL,
+};
+
+/* Global GCB */
+static struct genl_cb *global_gcb;
+
+/**
+ * rsi_hci_open() - This function is called when HCI device is
+ * 						opened 
+ * 
+ * @hdev - pointer to HCI device
+ * @return - 0 on success
+ */
+static int rsi_hci_open(struct hci_dev *hdev)
+{
+	rsi_dbg(ERR_ZONE, "RSI HCI DEVICE \"%s\" open\n", hdev->name);
+
+	if (test_and_set_bit(HCI_RUNNING, &hdev->flags))
+		rsi_dbg(ERR_ZONE, "%s: device `%s' already running\n", 
+				__func__, hdev->name);
+
+	return 0;
+}
+
+/**
+ * rsi_hci_close() - This function is called when HCI device is
+ * 						closed 
+ * 
+ * @hdev - pointer to HCI device
+ * @return - 0 on success
+ */
+static int rsi_hci_close(struct hci_dev *hdev)
+{
+	rsi_dbg(ERR_ZONE, "RSI HCI DEVICE \"%s\" closed\n", hdev->name);
+
+	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
+		rsi_dbg(ERR_ZONE, "%s: device `%s' not running\n",
+				 __func__, hdev->name);
+
+	return 0;
+}
+
+/**
+ * rsi_hci_flush() - This function is called when HCI device is
+ * 						flushed 
+ * 
+ * @hdev - pointer to HCI device
+ * @return - 0 on success; negative error code on failure
+ */
+static int rsi_hci_flush(struct hci_dev *hdev)
+{
+	struct rsi_hci_adapter *h_adapter;
+
+	if (!(h_adapter = hci_get_drvdata(hdev)))
+		return -EFAULT;
+
+	rsi_dbg(ERR_ZONE, "RSI `%s' flush\n", hdev->name);
+
+	return 0;
+}
+
+/**
+ * rsi_hci_send_pkt() - This function is used send the packet received 
+ * 						from HCI layer to co-ex module
+ *
+ * @hdev - pointer to HCI device
+ * @skb - Received packet from HCI
+ * @return - 0 on success; negative error code on failure
+ *  
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION (3, 13, 0)
+static int rsi_hci_send_pkt(struct sk_buff *skb)
+#else
+static int rsi_hci_send_pkt(struct hci_dev *hdev, struct sk_buff *skb)
+#endif
+{
+	struct rsi_hci_adapter *h_adapter;
+	struct sk_buff *new_skb = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION (3, 13, 0)
+	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
+#endif
+	int status = 0;
+
+	if (skb->len <= 0) {
+		rsi_dbg(ERR_ZONE, "Zero length packet\n");
+		//hdev->sta.err_tx++;
+		status = -EINVAL;
+		goto fail;
+	}
+
+	if (!(h_adapter = hci_get_drvdata(hdev))) {
+		//hdev->sta.err_tx++;
+		status = -EFAULT;
+		goto fail;
+	}
+
+#ifdef CONFIG_RSI_WOW
+	/* Stop here when in suspend */
+	if (h_adapter->priv->suspend_flag) {
+		rsi_dbg(INFO_ZONE, "In suspend: Dropping the pkt\n");
+		status = -ENETDOWN;
+		goto fail;
+	}
+#endif
+
+	if (h_adapter->priv->bt_fsm_state != BT_DEVICE_READY) {
+		rsi_dbg(ERR_ZONE, "BT Device not ready\n");
+		status = -ENODEV;
+		goto fail;
+	}
+
+	if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+		status = -EBUSY;
+		goto fail;
+	}
+
+	switch (bt_cb(skb)->pkt_type) {
+		case HCI_COMMAND_PKT:
+			hdev->stat.cmd_tx++;
+			break;
+
+		case HCI_ACLDATA_PKT:
+			hdev->stat.acl_tx++;
+			break;
+
+		case HCI_SCODATA_PKT:
+			hdev->stat.sco_tx++;
+			break;
+
+		default:
+			dev_kfree_skb(skb);
+			status = -EILSEQ;
+			goto fail;
+	}
+
+	if (skb_headroom(skb) < REQUIRED_HEADROOM_FOR_BT_HAL) {
+               /* Re-allocate one more skb with sufficent headroom 
+		 * make copy of input-skb to new one */
+		u16 new_len = skb->len + REQUIRED_HEADROOM_FOR_BT_HAL;
+
+		new_skb = dev_alloc_skb(new_len);
+		if (!new_skb) {
+			rsi_dbg(ERR_ZONE, "%s: Failed to alloc skb\n",
+				__func__);
+			dev_kfree_skb(skb);
+			return -ENOMEM;
+		}
+		skb_reserve(new_skb, REQUIRED_HEADROOM_FOR_BT_HAL);
+                skb_put(new_skb, skb->len);
+		memcpy(new_skb->data, skb->data, skb->len);
+		bt_cb(new_skb)->pkt_type = bt_cb(skb)->pkt_type;
+                dev_kfree_skb(skb);
+                skb = new_skb;
+	}
+
+        rsi_hex_dump(DATA_RX_ZONE, "TX BT Pkt", skb->data, skb->len); 
+
+#ifdef CONFIG_RSI_COEX
+	rsi_coex_send_pkt(h_adapter->priv, skb, BT_Q);
+#else
+        rsi_send_bt_pkt(h_adapter->priv, skb);
+#endif
+	return 0;
+
+fail:
+	dev_kfree_skb(skb);
+	return status;
+}
+
+int rsi_hci_recv_pkt(struct rsi_common *common, u8 *pkt)
+{
+	struct rsi_hci_adapter *h_adapter =
+		(struct rsi_hci_adapter *)common->hci_adapter;
+	struct sk_buff *skb = NULL;
+	struct hci_dev *hdev = NULL;
+	int pkt_len = rsi_get_length(pkt, 0);
+	u8 queue_no = rsi_get_queueno(pkt, 0);
+
+	if ((common->bt_fsm_state == BT_DEVICE_NOT_READY) &&
+	    (pkt[14] == BT_CARD_READY_IND)) {
+		rsi_dbg(INIT_ZONE, "%s: ===> BT Card Ready Received <===\n",
+			__func__);
+
+		rsi_dbg(INFO_ZONE, "Attaching HCI module\n");
+
+		if (rsi_hci_attach(common)) {
+			rsi_dbg(ERR_ZONE, "Failed to attach HCI module\n");
+			return 0;
+		}
+
+		return 0;
+	}
+ 
+	if (common->bt_fsm_state != BT_DEVICE_READY) {
+		rsi_dbg(INFO_ZONE, "BT Device not ready\n");
+		return 0;
+	}
+	
+	if (queue_no == RSI_BT_MGMT_Q) {
+		u8 msg_type = pkt[14] & 0xFF;
+	
+		switch (msg_type) {
+		case RESULT_CONFIRM:
+			rsi_dbg(MGMT_RX_ZONE, "BT Result Confirm\n");
+			return 0;
+		case BT_BER:
+			rsi_dbg(MGMT_RX_ZONE, "BT Ber\n");
+			return 0;
+		case BT_CW:
+			rsi_dbg(MGMT_RX_ZONE, "BT CW\n");
+			return 0;
+		default:
+			break;
+		}
+	}
+
+	skb = dev_alloc_skb(pkt_len);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to alloc skb\n", __func__);
+		return -ENOMEM;
+	}
+        hdev = h_adapter->hdev;
+	memcpy(skb->data, pkt + FRAME_DESC_SZ, pkt_len);
+	skb_put(skb, pkt_len);
+	h_adapter->hdev->stat.byte_rx += skb->len;
+
+	skb->dev = (void *)hdev;
+	bt_cb(skb)->pkt_type = pkt[14];
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+	return hci_recv_frame(skb);
+#else
+	return hci_recv_frame(hdev, skb);
+#endif
+}
+EXPORT_SYMBOL_GPL(rsi_hci_recv_pkt);
+
+/**
+ * rsi_genl_recv() - This function gets the command request from
+ * 					 user space over netlink socket
+ *             
+ * @skb		pointer to sk_buff structure
+ * @info	read command info pointer
+ *
+ * @return	0 on success, negative error code on failure
+ */
+int rsi_genl_recv(struct sk_buff *skb, struct genl_info *info)
+{
+	struct rsi_hci_adapter *h_adapter = NULL;
+	struct genl_cb *gcb;
+	struct nlattr *na;
+	u8 *data;
+	int rc = -1, len, pkttype;
+	u8 dword_align_req_bytes = 0;
+
+	if (!(gcb = global_gcb))
+		return -1;
+
+	if (!(h_adapter = global_gcb->gc_drvpriv))
+		return -1;
+
+	gcb->gc_pid = get_portid(info);
+	gcb->gc_seq = info->snd_seq;
+
+	na = info->attrs[RSI_USER_A_MSG];
+	if (na) {
+		data = (u8 *)nla_data(na);
+		if (!data) {
+			rsi_dbg(ERR_ZONE,
+				"%s: no data recevied on family `%s'\n",
+				__func__, gcb->gc_name);
+			goto err;
+		}
+	} else {
+		rsi_dbg(ERR_ZONE,
+			"%s: netlink attr is NULL on family `%s'\n",
+			 __func__, gcb->gc_name);
+		goto err;
+	}
+	gcb->gc_info = NULL;
+	gcb->gc_skb = NULL;
+
+	pkttype = *(u16 *)&data[0];
+	len = *(u16 *)&data[2];
+
+	data += 16;
+
+	rsi_dbg(ERR_ZONE, "%s: len %x pkt_type %x\n", 
+			__func__, len, pkttype);
+
+	rsi_hex_dump (DATA_RX_ZONE, "BT TX data", data, len);
+
+	skb = dev_alloc_skb(len + REQUIRED_HEADROOM_FOR_BT_HAL);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to alloc skb\n",
+				__func__);
+		return -ENOMEM;
+	}
+	skb_reserve(skb, REQUIRED_HEADROOM_FOR_BT_HAL);
+	dword_align_req_bytes = ((unsigned long)skb->data) & 0x3f;
+	if (dword_align_req_bytes)
+		skb_push(skb, dword_align_req_bytes);
+	memcpy(skb->data, data, len);
+	bt_cb(skb)->pkt_type = pkttype;
+
+#ifdef CONFIG_RSI_COEX
+	return rsi_coex_send_pkt(h_adapter->priv, skb, RSI_BT_Q);
+#else
+        return rsi_send_bt_pkt(h_adapter->priv, skb);
+#endif
+
+err:
+	rsi_dbg(ERR_ZONE, "%s: error(%d) occured\n", __func__, rc);
+	return rc;
+}
+
+
+/**
+ * rsi_hci_attach () - This function initializes HCI interface
+ *				      
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+int rsi_hci_attach(struct rsi_common *common)
+{
+	struct rsi_hci_adapter *h_adapter = NULL;
+	struct genl_cb *gcb = NULL;
+	struct hci_dev *hdev;
+	int status = 0;
+
+	/* Allocate HCI adapter */
+	/* TODO: Check GFP_ATOMIC */
+	h_adapter = kzalloc(sizeof (*h_adapter), GFP_KERNEL);
+	if (!h_adapter) {
+		rsi_dbg (ERR_ZONE, "Failed to alloc HCI adapter\n");
+		return -ENOMEM;
+	}
+	h_adapter->priv = common;
+	
+	/* Create HCI Interface */
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		rsi_dbg (ERR_ZONE, "Failed to alloc HCI device\n");
+		goto err;
+	}
+	h_adapter->hdev = hdev;
+
+	if (common->priv->rsi_host_intf == RSI_HOST_INTF_SDIO)
+		hdev->bus = HCI_SDIO;
+	else
+		hdev->bus = HCI_USB;
+
+	hci_set_drvdata(hdev, h_adapter);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (4, 8, 0)
+	hdev->dev_type = HCI_PRIMARY;
+#else
+	hdev->dev_type = HCI_BREDR;
+#endif
+
+	hdev->open = rsi_hci_open;
+	hdev->close = rsi_hci_close;
+	hdev->flush = rsi_hci_flush;
+	hdev->send = rsi_hci_send_pkt;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION (3, 3, 8)
+	hdev->destruct = rsi_hci_destruct;
+	hdev->owner = THIS_MODULE;
+#endif
+
+        /* Initialize TX queue */
+	skb_queue_head_init(&h_adapter->hci_tx_queue);
+	common->hci_adapter = (void *)h_adapter;
+	
+	status = hci_register_dev(hdev);
+	if (status < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: HCI registration failed with errcode %d\n",
+			__func__, status);
+		goto err;
+	}
+	rsi_dbg(INIT_ZONE, "HCI Interface Created with name \'%s\'\n",
+		hdev->name);
+
+	/* Register for general netlink operations */
+	/* TODO: Check GFP_ATOMIC */
+	gcb = kzalloc(sizeof(*gcb), GFP_KERNEL);
+	if (!gcb) {
+		rsi_dbg (ERR_ZONE, "%s: Failed to alloc genl control block\n",
+				__func__); 
+		goto err;
+	}
+	h_adapter->gcb = gcb;
+	global_gcb = gcb;
+
+	gcb->gc_drvpriv = h_adapter;
+	gcb->gc_family = &bt_genl_family;
+	gcb->gc_policy = &bt_genl_policy[0];
+	gcb->gc_ops = &bt_genl_ops;
+	gcb->gc_n_ops = 1;
+	gcb->gc_name = RSI_BT_GENL_FAMILY;
+	gcb->gc_pid = gcb->gc_done = 0;
+
+	rsi_dbg(INIT_ZONE, "genl-register: nl_family `%s'\n", gcb->gc_name);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+	gcb->gc_family->ops = gcb->gc_ops;
+	gcb->gc_family->n_ops = gcb->gc_n_ops;
+#endif
+
+	if (genl_register_family(gcb->gc_family)) {
+		rsi_dbg(ERR_ZONE, "%s: genl_register_family failed\n",
+			__func__);
+		goto err;
+	}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION (3, 12, 34)
+	if (genl_register_ops(gcb->gc_family, gcb->gc_ops)) {
+		rsi_dbg(ERR_ZONE, "%s: genl_register_ops failed\n", __func__);
+		genl_unregister_family(family);
+		goto err;
+	}
+#endif
+	gcb->gc_done = 1;
+	common->bt_fsm_state = BT_DEVICE_READY;
+	rsi_dbg(ERR_ZONE, " HCI module init done...\n");
+
+	return 0;
+
+err:
+	if (hdev) {
+		hci_unregister_dev(hdev);
+		hci_free_dev(hdev);
+		h_adapter->hdev = NULL;
+	}
+	if (gcb) {
+		genl_unregister_family(gcb->gc_family);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 12, 34)
+		genl_unregister_ops(gcb->gc_family, gcb->gc_ops);
+#endif
+		kfree(gcb);
+	}
+	h_adapter->gcb = NULL;
+	kfree(h_adapter);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(rsi_hci_attach);
+
+/**
+ * rsi_hci_attach () - This function initializes HCI interface
+ *				      
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+void rsi_hci_detach(struct rsi_common *common)
+{
+	struct rsi_hci_adapter *h_adapter = 
+		(struct rsi_hci_adapter *)common->hci_adapter;
+	struct hci_dev *hdev;
+	struct genl_cb *gcb;
+
+	rsi_dbg(INFO_ZONE, "Detaching HCI...\n");
+
+	if (!h_adapter)
+		return;
+
+	hdev = h_adapter->hdev;
+	if (hdev) {
+                //hci_dev_hold(hdev);
+		hci_unregister_dev(hdev);
+                //hci_dev_put(hdev);
+		hci_free_dev(hdev);
+		h_adapter->hdev = NULL;
+	}
+
+	gcb = h_adapter->gcb;
+	if (gcb) {
+		genl_unregister_family(gcb->gc_family);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 12, 34)
+		genl_unregister_ops(gcb->gc_family, gcb->gc_ops);
+#endif
+		h_adapter->gcb = NULL;
+		kfree(gcb);
+	}
+	kfree(h_adapter);
+
+	return;
+}
+EXPORT_SYMBOL_GPL(rsi_hci_detach);
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_mac80211.c b/drivers/net/wireless/rsi/rsi_91x_mac80211.c
index aeaf87b..a7f79e0 100644
--- a/drivers/net/wireless/rsi/rsi_91x_mac80211.c
+++ b/drivers/net/wireless/rsi/rsi_91x_mac80211.c
@@ -1,103 +1,130 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/version.h>
 #include "rsi_debugfs.h"
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
+#include "rsi_ps.h"
+#include "rsi_hal.h"
+
+int g_bgscan_enable;
 
 static const struct ieee80211_channel rsi_2ghz_channels[] = {
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2412,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2412,
 	  .hw_value = 1 }, /* Channel 1 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2417,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2417,
 	  .hw_value = 2 }, /* Channel 2 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2422,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2422,
 	  .hw_value = 3 }, /* Channel 3 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2427,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2427,
 	  .hw_value = 4 }, /* Channel 4 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2432,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2432,
 	  .hw_value = 5 }, /* Channel 5 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2437,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2437,
 	  .hw_value = 6 }, /* Channel 6 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2442,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2442,
 	  .hw_value = 7 }, /* Channel 7 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2447,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2447,
 	  .hw_value = 8 }, /* Channel 8 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2452,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2452,
 	  .hw_value = 9 }, /* Channel 9 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2457,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2457,
 	  .hw_value = 10 }, /* Channel 10 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2462,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2462,
 	  .hw_value = 11 }, /* Channel 11 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2467,
+#ifndef CONFIG_CARACALLA_BOARD
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2467,
+	  .hw_value = 12 }, /* Channel 12 */
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2472,
+	  .hw_value = 13 }, /* Channel 13 */
+#else
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2467, .max_power = 15,
 	  .hw_value = 12 }, /* Channel 12 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2472,
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2472, .max_power = 7,
 	  .hw_value = 13 }, /* Channel 13 */
-	{ .band = IEEE80211_BAND_2GHZ, .center_freq = 2484,
+#endif
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2484,
 	  .hw_value = 14 }, /* Channel 14 */
 };
 
 static const struct ieee80211_channel rsi_5ghz_channels[] = {
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5180,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5180,
 	  .hw_value = 36,  }, /* Channel 36 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5200,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5200,
 	  .hw_value = 40, }, /* Channel 40 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5220,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5220,
 	  .hw_value = 44, }, /* Channel 44 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5240,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5240,
 	  .hw_value = 48, }, /* Channel 48 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5260,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5260,
 	  .hw_value = 52, }, /* Channel 52 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5280,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5280,
 	  .hw_value = 56, }, /* Channel 56 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5300,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5300,
 	  .hw_value = 60, }, /* Channel 60 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5320,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5320,
 	  .hw_value = 64, }, /* Channel 64 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5500,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5500,
 	  .hw_value = 100, }, /* Channel 100 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5520,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5520,
 	  .hw_value = 104, }, /* Channel 104 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5540,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5540,
 	  .hw_value = 108, }, /* Channel 108 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5560,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5560,
 	  .hw_value = 112, }, /* Channel 112 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5580,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5580,
 	  .hw_value = 116, }, /* Channel 116 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5600,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5600,
 	  .hw_value = 120, }, /* Channel 120 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5620,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5620,
 	  .hw_value = 124, }, /* Channel 124 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5640,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5640,
 	  .hw_value = 128, }, /* Channel 128 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5660,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5660,
 	  .hw_value = 132, }, /* Channel 132 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5680,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5680,
 	  .hw_value = 136, }, /* Channel 136 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5700,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5700,
 	  .hw_value = 140, }, /* Channel 140 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5745,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5745,
 	  .hw_value = 149, }, /* Channel 149 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5765,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5765,
 	  .hw_value = 153, }, /* Channel 153 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5785,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5785,
 	  .hw_value = 157, }, /* Channel 157 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5805,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5805,
 	  .hw_value = 161, }, /* Channel 161 */
-	{ .band = IEEE80211_BAND_5GHZ, .center_freq = 5825,
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5825,
 	  .hw_value = 165, }, /* Channel 165 */
 };
 
@@ -121,13 +148,70 @@ const u16 rsi_mcsrates[8] = {
 	RSI_RATE_MCS4, RSI_RATE_MCS5, RSI_RATE_MCS6, RSI_RATE_MCS7
 };
 
+static const u32 rsi_max_ap_stas[16] = {
+	32,	/* 1 - Wi-Fi alone */
+	0,	/* 2 */
+	0,	/* 3 */
+	0,	/* 4 - BT EDR alone */
+	4,	/* 5 - STA + BT EDR */
+	32,	/* 6 - AP + BT EDR */
+	0,	/* 7 */
+	0,	/* 8 - BT LE alone */
+        4,	/* 9 - STA + BE LE */
+	0,	/* 10 */
+	0,	/* 11 */
+	0,	/* 12 */
+	1,	/* 13 - STA + BT Dual */
+	4,	/* 14 - AP + BT Dual */
+};
+
+#ifdef CONFIG_RSI_P2P
+static const struct ieee80211_iface_limit rsi_iface_limits[] = {
+	{
+		.max = 1, 
+		.types = BIT(NL80211_IFTYPE_STATION),
+	},
+	{
+		.max = 1, 
+		.types = BIT(NL80211_IFTYPE_AP) |
+			BIT(NL80211_IFTYPE_P2P_CLIENT) |
+			BIT(NL80211_IFTYPE_P2P_GO),
+	},
+	{
+		.max = 1, 
+		.types = BIT(NL80211_IFTYPE_P2P_DEVICE),
+	},
+};
+
+static const struct ieee80211_iface_combination rsi_iface_combinations[] = {
+	{
+		.num_different_channels = 1, 
+		.max_interfaces = 3, 
+		.limits = rsi_iface_limits,
+		.n_limits = ARRAY_SIZE(rsi_iface_limits),
+	},
+};
+#endif
+
+struct ieee80211_vif *rsi_get_vif(struct rsi_hw *adapter, u8 *mac)
+{
+	u8 i;
+
+	for (i = 0; i < RSI_MAX_VIFS; i++) {
+		if (!adapter->vifs[i])
+			continue;
+		if (!(memcmp(adapter->vifs[i]->addr, mac, ETH_ALEN)))
+			return adapter->vifs[i];
+	}
+	return NULL;
+}
+
 /**
  * rsi_is_cipher_wep() -  This function determines if the cipher is WEP or not.
  * @common: Pointer to the driver private structure.
  *
  * Return: If cipher type is WEP, a value of 1 is returned, else 0.
  */
-
 bool rsi_is_cipher_wep(struct rsi_common *common)
 {
 	if (((common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP104) ||
@@ -150,21 +234,21 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 	struct ieee80211_supported_band *sbands = &adapter->sbands[band];
 	void *channels = NULL;
 
-	if (band == IEEE80211_BAND_2GHZ) {
-		channels = kmalloc(sizeof(rsi_2ghz_channels), GFP_KERNEL);
+	if (band == NL80211_BAND_2GHZ) {
+		channels = kzalloc(sizeof(rsi_2ghz_channels), GFP_KERNEL);
 		memcpy(channels,
 		       rsi_2ghz_channels,
 		       sizeof(rsi_2ghz_channels));
-		sbands->band = IEEE80211_BAND_2GHZ;
+		sbands->band = NL80211_BAND_2GHZ;
 		sbands->n_channels = ARRAY_SIZE(rsi_2ghz_channels);
 		sbands->bitrates = rsi_rates;
 		sbands->n_bitrates = ARRAY_SIZE(rsi_rates);
 	} else {
-		channels = kmalloc(sizeof(rsi_5ghz_channels), GFP_KERNEL);
+		channels = kzalloc(sizeof(rsi_5ghz_channels), GFP_KERNEL);
 		memcpy(channels,
 		       rsi_5ghz_channels,
 		       sizeof(rsi_5ghz_channels));
-		sbands->band = IEEE80211_BAND_5GHZ;
+		sbands->band = NL80211_BAND_5GHZ;
 		sbands->n_channels = ARRAY_SIZE(rsi_5ghz_channels);
 		sbands->bitrates = &rsi_rates[4];
 		sbands->n_bitrates = ARRAY_SIZE(rsi_rates) - 4;
@@ -184,6 +268,159 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 	/* sbands->ht_cap.mcs.rx_highest = 0x82; */
 }
 
+static void rsi_set_min_rate(struct ieee80211_hw *hw,
+			     struct ieee80211_sta *sta,
+			     struct rsi_common *common)
+{
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	u8 band = hw->conf.chandef.chan->band;
+	u8 ii;
+	u32 rate_bitmap;
+	bool matched = false;
+
+	if (vif->type == NL80211_IFTYPE_AP) {
+		common->bitrate_mask[band] = common->fixedrate_mask[band];
+		rate_bitmap = common->bitrate_mask[band];
+	} else {
+		common->bitrate_mask[band] = sta->supp_rates[band];
+		rate_bitmap = (common->fixedrate_mask[band] &
+			       sta->supp_rates[band]);
+	}
+	rsi_dbg(INFO_ZONE, "bitrate_mask = %x\n", common->bitrate_mask[band]);
+	rsi_dbg(INFO_ZONE, "rate_bitmap = %x\n", rate_bitmap);
+
+	if (rate_bitmap & 0xfff) {
+		/* Find out the min rate */
+		for (ii = 0; ii < ARRAY_SIZE(rsi_rates); ii++) {
+			if (rate_bitmap & BIT(ii)) {
+				common->min_rate = rsi_rates[ii].hw_value;
+				matched = true;
+				break;
+			}
+		}
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		common->vif_info[0].is_ht = sta->ht_cap.ht_supported;
+		if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
+		    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))
+			common->vif_info[0].sgi = true;
+	}
+
+	if ((common->vif_info[0].is_ht) && (rate_bitmap >> 12)) {
+		for (ii = 0; ii < ARRAY_SIZE(rsi_mcsrates); ii++) {
+			if ((rate_bitmap >> 12) & BIT(ii)) {
+				common->min_rate = rsi_mcsrates[ii];
+				matched = true;
+				break;
+			}
+		}
+	}
+
+	if (!matched)
+		common->min_rate = 0xffff;
+
+	rsi_dbg(INFO_ZONE, "Min Rate = %d\n", common->min_rate);
+}
+
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+static int rsi_mac80211_hw_scan_start(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif,
+				      struct ieee80211_scan_request *hw_req)
+{
+	struct cfg80211_scan_request *scan_req = &hw_req->req;
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+	int ii =0;
+
+	rsi_dbg(INFO_ZONE, "In %s\n", __func__);
+
+	if (scan_req->n_channels == 0)
+		return -EINVAL;
+
+	/* Scan already in progress. So return */
+	if(common->bgscan_en || common->scan_in_prog) {
+		return -EBUSY;
+	}
+
+	mutex_lock(&common->mutex);
+
+	if (!bss->assoc) {
+		common->scan_request = scan_req;
+		common->scan_vif = vif;
+		common->scan_in_prog = false;
+		queue_work(common->scan_workqueue, &common->scan_work);
+	} else {
+		/* Wait for EAPOL4 completion before starting bg scan */
+		if ((bss->assoc_capability & BIT(4))) {	
+			if (!common->start_bgscan) {
+				return -EBUSY;
+			}
+		}
+		common->bgscan_info.num_user_channels = scan_req->n_channels;
+		for(ii = 0;ii < scan_req->n_channels;ii++) {
+			common->bgscan_info.user_channels[ii] = 
+				scan_req->channels[ii]->hw_value;
+		}
+		if (!rsi_send_bgscan_params(common, 1)) {
+			rsi_send_probe_request(common,scan_req,0,0,1);
+			if (!rsi_send_bgscan_probe_req(common)) {
+				rsi_dbg(INFO_ZONE,
+						"Background scan started\n");
+				common->bgscan_en = 1;
+			}
+		}	
+	}
+	
+	mutex_unlock(&common->mutex);
+        return 0;
+}
+
+static void rsi_mac80211_hw_scan_cancel(struct ieee80211_hw *hw,
+					struct ieee80211_vif *vif)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+	rsi_dbg(INFO_ZONE, "In %s\n", __func__);
+
+	mutex_lock(&common->mutex);
+	common->hw_scan_cancel = true;
+	if(common->scan_in_prog ) {
+		common->scan_in_prog = false;
+		rsi_wait_event(&common->cancel_hw_scan_event,
+			       EVENT_WAIT_FOREVER);
+		rsi_reset_event(&common->cancel_hw_scan_event);
+	}
+	
+	if(common->bgscan_en) {
+		if (bss->assoc) {
+			rsi_wait_event(&common->cancel_hw_scan_event,
+				       EVENT_WAIT_FOREVER);
+			rsi_reset_event(&common->cancel_hw_scan_event);
+		} else {
+			common->bgscan_en = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+			info.aborted = false;
+			ieee80211_scan_completed(adapter->hw, &info);
+#else	
+			ieee80211_scan_completed(adapter->hw, false);
+#endif
+
+		}
+		
+	}
+	common->hw_scan_cancel = false;
+	mutex_unlock(&common->mutex);
+
+}
+#endif
+
 /**
  * rsi_mac80211_detach() - This function is used to de-initialize the
  *			   Mac80211 stack.
@@ -194,14 +431,36 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 void rsi_mac80211_detach(struct rsi_hw *adapter)
 {
 	struct ieee80211_hw *hw = adapter->hw;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
+	enum nl80211_band band;
+#else
+	int band;
+#endif
+
+	rsi_dbg(INFO_ZONE, "Detach mac80211...\n");
 
 	if (hw) {
 		ieee80211_stop_queues(hw);
 		ieee80211_unregister_hw(hw);
 		ieee80211_free_hw(hw);
+		adapter->hw = NULL;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0))
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		struct ieee80211_supported_band *sband =
+					&adapter->sbands[band];
+
+		kfree(sband->channels);
 	}
 
+#ifdef CONFIG_RSI_DEBUGFS
 	rsi_remove_dbgfs(adapter);
+	kfree(adapter->dfsentry);
+#endif
 }
 EXPORT_SYMBOL_GPL(rsi_mac80211_detach);
 
@@ -218,12 +477,20 @@ void rsi_indicate_tx_status(struct rsi_hw *adapter,
 			    int status)
 {
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct skb_info *tx_params;
 
-	memset(info->driver_data, 0, IEEE80211_TX_INFO_DRIVER_DATA_SIZE);
+	if (!adapter->hw) {
+		rsi_dbg(ERR_ZONE, "##### No Hardware #####\n");
+		return;
+	}
 
 	if (!status)
 		info->flags |= IEEE80211_TX_STAT_ACK;
 
+	tx_params = (struct skb_info *)info->driver_data;
+	skb_pull(skb, tx_params->internal_hdr_size);
+	memset(info->driver_data, 0, IEEE80211_TX_INFO_DRIVER_DATA_SIZE);
+
 	ieee80211_tx_status_irqsafe(adapter->hw, skb);
 }
 
@@ -243,8 +510,26 @@ static void rsi_mac80211_tx(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_hdr *wlh = (struct ieee80211_hdr *)skb->data;
+
+#ifdef CONFIG_RSI_WOW
+	if (common->suspend_flag) {
+		ieee80211_free_txskb(common->priv->hw, skb);
+		return;
+	}
+#endif
+	if (ieee80211_is_beacon(wlh->frame_control)) {
+		ieee80211_free_txskb(common->priv->hw, skb);
+		return;
+	}
 
+#ifndef CONFIG_RSI_BT_ALONE
 	rsi_core_xmit(common, skb);
+#else
+#ifndef CONFIG_RSI_COEX
+        ieee80211_free_txskb(common->priv->hw, skb); 
+#endif
+#endif
 }
 
 /**
@@ -260,8 +545,14 @@ static int rsi_mac80211_start(struct ieee80211_hw *hw)
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
 
+	rsi_dbg(ERR_ZONE, "===> Interface UP <===\n");
 	mutex_lock(&common->mutex);
+	
+	common->scan_in_prog = false;
 	common->iface_down = false;
+        wiphy_rfkill_start_polling(hw->wiphy);
+	rsi_send_rx_filter_frame(common, 0);
+
 	mutex_unlock(&common->mutex);
 
 	return 0;
@@ -277,9 +568,22 @@ static void rsi_mac80211_stop(struct ieee80211_hw *hw)
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+	rsi_dbg(ERR_ZONE, "===> Interface DOWN <===\n");
 
 	mutex_lock(&common->mutex);
+	
 	common->iface_down = true;
+	if (common->scan_in_prog) 
+		common->scan_in_prog = false;
+
+	wiphy_rfkill_stop_polling(hw->wiphy);
+
+	/* Block all rx frames */
+	rsi_send_rx_filter_frame(common, 0xffff);
+	
 	mutex_unlock(&common->mutex);
 }
 
@@ -295,23 +599,112 @@ static int rsi_mac80211_add_interface(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif)
 {
 	struct rsi_hw *adapter = hw->priv;
-	struct rsi_common *common = adapter->priv;
-	int ret = -EOPNOTSUPP;
+	struct rsi_common *common = NULL;
+	enum opmode intf_mode;
+	int ret = 0;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+
+	rsi_dbg(INFO_ZONE, "Add Interface Called\n");
+
+	if (!adapter)
+		return -ENODEV;
+	common = adapter->priv;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0))
+	vif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;
+#endif
 
 	mutex_lock(&common->mutex);
+
+	/* Not supporting concurrent mode now */	
+	if (adapter->sc_nvifs > 0) {
+		if ((!common->p2p_enabled) &&
+		    (vif->type != NL80211_IFTYPE_P2P_DEVICE)) {
+			ret = -EINVAL;
+			goto out;
+		}
+		if (adapter->vifs[0]->bss_conf.assoc)
+			return -EOPNOTSUPP;
+	}
+
 	switch (vif->type) {
 	case NL80211_IFTYPE_STATION:
-		if (!adapter->sc_nvifs) {
-			++adapter->sc_nvifs;
-			adapter->vifs[0] = vif;
-			ret = rsi_set_vap_capabilities(common, STA_OPMODE);
-		}
+		rsi_dbg(INFO_ZONE, "Station Mode");
+		intf_mode = STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_AP:
+		rsi_dbg(INFO_ZONE, "AP Mode");
+		intf_mode = AP_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		rsi_dbg(INFO_ZONE, "P2P Device Mode");
+		common->p2p_enabled = 1;
+		intf_mode = STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		rsi_dbg(INFO_ZONE, "P2P GO Mode");
+		intf_mode = P2P_GO_OPMODE;
+		common->p2p_enabled = 1;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		rsi_dbg(INFO_ZONE, "P2P Client Mode");
+		intf_mode = P2P_CLIENT_OPMODE;
+		common->p2p_enabled = 1;
 		break;
 	default:
-		rsi_dbg(ERR_ZONE,
-			"%s: Interface type %d not supported\n", __func__,
-			vif->type);
+		rsi_dbg(ERR_ZONE, "Unsupported mode");
+		ret = -EINVAL;
+		goto out;
+	}
+	if (adapter->sc_nvifs >= RSI_MAX_VIFS)
+		adapter->vifs[adapter->sc_nvifs - 1] = vif;
+	else
+		adapter->vifs[adapter->sc_nvifs++] = vif;
+
+	if (!common->p2p_enabled) {
+		vif_info->vap_id = 0;
+		common->last_vap_id = 0;
+		ret = rsi_set_vap_capabilities(common, intf_mode,
+				common->mac_addr, vif_info->vap_id, VAP_ADD);
+		if (ret) {
+			rsi_dbg(ERR_ZONE, "Failed to set VAP capabilities\n");
+			goto out;
+		}
+	} else {
+		if ((intf_mode == AP_OPMODE) ||
+		    (intf_mode == P2P_GO_OPMODE)) {
+			vif_info->vap_id = common->last_vap_id + 1;
+			ret = rsi_set_vap_capabilities(common,
+						       intf_mode,
+						       vif->addr,
+						       vif_info->vap_id,
+						       VAP_ADD);
+		} else {
+			vif_info->vap_id = common->last_vap_id;
+			ret = rsi_set_vap_capabilities(common,
+						       intf_mode,
+						       vif->addr,
+						       vif_info->vap_id,
+						       VAP_UPDATE);
+			if (ret) {
+				rsi_dbg(ERR_ZONE, "Failed to set VAP capabilities\n");
+				goto out;
+			}
+		}
+	}
+
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		int i;
+
+		common->bc_mc_seqno = 1;
+		rsi_send_rx_filter_frame(common, DISALLOW_BEACONS);
+		common->min_rate = 0xffff;
+		for (i = 0; i < common->max_stations; i++)
+			common->stations[i].sta = NULL;
 	}
+
+out:
 	mutex_unlock(&common->mutex);
 
 	return ret;
@@ -330,14 +723,133 @@ static void rsi_mac80211_remove_interface(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	int i;
+
+	rsi_dbg(INFO_ZONE, "Remove Interface Called\n");
+	
+	if (adapter->sc_nvifs <= 0)
+		return;
+	
+	mutex_lock(&common->mutex);
+
+	for (i = 0; i < RSI_MAX_VIFS; i++) {
+		if (adapter->vifs[i] == vif) {
+			adapter->sc_nvifs--;
+			switch (adapter->vifs[i]->type) {
+				case NL80211_IFTYPE_STATION:
+					rsi_set_vap_capabilities(common,
+								STA_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				case NL80211_IFTYPE_AP:
+					rsi_set_vap_capabilities(common,
+								AP_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				case NL80211_IFTYPE_P2P_CLIENT:
+					rsi_set_vap_capabilities(common,
+								P2P_CLIENT_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				case NL80211_IFTYPE_P2P_GO:
+					rsi_set_vap_capabilities(common,
+								P2P_GO_OPMODE,
+								vif->addr,
+								vif_info->vap_id,
+								VAP_DELETE);
+					break;
+				default:
+					goto out;
+			}
+			adapter->vifs[i] = NULL;
+			break;
+		}
+	}
+
+out:
+	mutex_unlock(&common->mutex);
+}
+
+static int rsi_mac80211_change_interface(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif,
+					 enum nl80211_iftype newtype,
+					 bool newp2p)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)hw->priv;
+	struct rsi_common *common = (struct rsi_common *)adapter->priv;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	int status = 0;
+	enum opmode intf_mode;
+
+	rsi_dbg(INFO_ZONE,
+		"Change Interface: New_type = %d, New_p2p = %d\n",
+		newtype, newp2p);
 
 	mutex_lock(&common->mutex);
-	if (vif->type == NL80211_IFTYPE_STATION)
-		adapter->sc_nvifs--;
 
-	if (!memcmp(adapter->vifs[0], vif, sizeof(struct ieee80211_vif)))
-		adapter->vifs[0] = NULL;
+	vif->type = newtype;
+	vif->p2p = newp2p;
+	
+	switch (newtype) {
+		case NL80211_IFTYPE_AP:
+			rsi_dbg(INFO_ZONE, "Change to AP Mode\n");
+			intf_mode = AP_OPMODE;
+			break;
+		case NL80211_IFTYPE_STATION:
+			intf_mode = STA_OPMODE;
+			rsi_dbg(INFO_ZONE, "Change to Station Mode\n");
+			break;
+		case NL80211_IFTYPE_P2P_CLIENT:
+			rsi_dbg(INFO_ZONE, "Change to P2P Client Mode\n");
+			intf_mode = P2P_CLIENT_OPMODE;
+			break;
+		case NL80211_IFTYPE_P2P_GO:
+			rsi_dbg(INFO_ZONE, "Change to P2P Go Mode\n");
+			intf_mode = P2P_GO_OPMODE;
+			break;
+		default:
+			status = -EINVAL;
+			goto out;
+	}
+//	if (intf_mode == AP_OPMODE) {
+		rsi_set_vap_capabilities(common,
+					 //STA_OPMODE,
+					 common->last_vap_type,
+					 vif->addr,
+					 vif_info->vap_id,
+					 VAP_DELETE);
+		status = rsi_set_vap_capabilities(common,
+						  intf_mode,
+						  vif->addr,
+						  vif_info->vap_id,
+						  VAP_ADD);
+#if 0
+	} else if ((intf_mode != common->last_vap_type) ||
+		   (!ether_addr_equal(vif->addr, common->last_vap_addr))) {
+		status = rsi_set_vap_capabilities(common,
+						  intf_mode,
+						  vif->addr,
+						  vif_info->vap_id,
+						  VAP_UPDATE);
+	}
+#endif
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		common->bc_mc_seqno = 1;
+		rsi_send_rx_filter_frame(common, DISALLOW_BEACONS);
+		common->min_rate = 0xffff;
+	}
+
+out:
 	mutex_unlock(&common->mutex);
+	return status;
 }
 
 /**
@@ -355,25 +867,55 @@ static int rsi_channel_change(struct ieee80211_hw *hw)
 	int status = -EOPNOTSUPP;
 	struct ieee80211_channel *curchan = hw->conf.chandef.chan;
 	u16 channel = curchan->hw_value;
-	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+	struct ieee80211_bss_conf *bss = NULL;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+
+	if (adapter->sc_nvifs <= 0) {
+		rsi_dbg(ERR_ZONE, "%s: No virtual interface found\n", __func__);
+		return -EINVAL;
+	}
+	bss = &vif->bss_conf;
 
 	rsi_dbg(INFO_ZONE,
 		"%s: Set channel: %d MHz type: %d channel_no %d\n",
 		__func__, curchan->center_freq,
 		curchan->flags, channel);
 
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsi_dbg(INFO_ZONE, "Configure channel %d for AP\n", channel);
+		if (rsi_band_check(common, curchan)) {
+			rsi_dbg(ERR_ZONE, "Failed to set band\n");
+			return -EINVAL;
+		}
+		if (rsi_set_channel(common, curchan)) {
+			rsi_dbg(ERR_ZONE, "Failed to set the channel\n");
+			return -EINVAL;
+		}
+		common->ap_channel = curchan;
+		return 0;
+	}
+	common->mac80211_cur_channel = channel;
 	if (bss->assoc) {
+		rsi_dbg(INFO_ZONE, "%s: connected\n", __func__);
+
+		if (common->bgscan_en)
+			return 0;
+
 		if (!common->hw_data_qs_blocked &&
 		    (rsi_get_connected_channel(adapter) != channel)) {
 			rsi_dbg(INFO_ZONE, "blk data q %d\n", channel);
 			if (!rsi_send_block_unblock_frame(common, true))
 				common->hw_data_qs_blocked = true;
 		}
+	} else {
+		rsi_dbg(INFO_ZONE, "assoc status:%d channel:%d\n",
+			bss->assoc, channel);
 	}
 
-	status = rsi_band_check(common);
+	status = rsi_band_check(common, curchan);
 	if (!status)
-		status = rsi_set_channel(adapter->priv, channel);
+		status = rsi_set_channel(adapter->priv, curchan);
 
 	if (bss->assoc) {
 		if (common->hw_data_qs_blocked &&
@@ -394,6 +936,37 @@ static int rsi_channel_change(struct ieee80211_hw *hw)
 }
 
 /**
+ * rsi_config_power() - This function configures tx power in device
+ * @hw: Pointer to the ieee80211_hw structure.
+ *
+ * Return: 0 on success, negative error code on failure.
+ */
+static int rsi_config_power(struct ieee80211_hw *hw)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_conf *conf = &hw->conf;
+	int status;
+
+	if (adapter->sc_nvifs <= 0) {
+		rsi_dbg(ERR_ZONE, "%s: No virtual interface found\n", __func__);
+		return -EINVAL;
+	}
+
+	rsi_dbg(INFO_ZONE,
+		"%s: Set tx power: %d dBM\n", __func__, conf->power_level);
+
+	if (conf->power_level == common->tx_power)
+		return 0;
+
+	common->tx_power = conf->power_level;
+
+	status = rsi_send_radio_params_update(common);
+
+	return status;
+}
+
+/**
  * rsi_mac80211_config() - This function is a handler for configuration
  *			   requests. The stack calls this function to
  *			   change hardware configuration, e.g., channel.
@@ -407,13 +980,63 @@ static int rsi_mac80211_config(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+	struct ieee80211_conf *conf = &hw->conf;
 	int status = -EOPNOTSUPP;
 
 	mutex_lock(&common->mutex);
 
+	/* channel */
 	if (changed & IEEE80211_CONF_CHANGE_CHANNEL)
 		status = rsi_channel_change(hw);
 
+	/* listen interval */
+	if (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {
+		rsi_dbg(INFO_ZONE,
+			"listen_int = %d\n", conf->listen_interval);
+		if (bss->dtim_period < conf->listen_interval)
+			adapter->ps_info.num_bcns_per_lis_int =
+				bss->dtim_period;
+		else
+			adapter->ps_info.num_bcns_per_lis_int =
+				conf->listen_interval;
+	}
+
+	/* tx power */
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		rsi_dbg(INFO_ZONE, "%s: Configuring Power\n", __func__);
+		status = rsi_config_power(hw);
+	}
+
+	/* retry limit */
+	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {
+		/* FIXME */
+	}
+
+	/* Power save parameters */
+	if ((changed & IEEE80211_CONF_CHANGE_PS) &&
+	    (vif->type == NL80211_IFTYPE_STATION)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&adapter->ps_lock, flags);
+		if (conf->flags & IEEE80211_CONF_PS)
+			rsi_enable_ps(adapter);
+		else
+			rsi_disable_ps(adapter);
+		spin_unlock_irqrestore(&adapter->ps_lock, flags);
+	}
+
+	/* RTS threshold */
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
+		rsi_dbg(INFO_ZONE,"RTS threshold\n");
+		if ((common->rts_threshold) <= IEEE80211_MAX_RTS_THRESHOLD) {
+			rsi_dbg(INFO_ZONE,
+				"%s: Sending vap updates....\n", __func__);
+			status = rsi_send_vap_dynamic_update(common);
+		}
+	}
+
 	mutex_unlock(&common->mutex);
 
 	return status;
@@ -428,16 +1051,53 @@ static int rsi_mac80211_config(struct ieee80211_hw *hw,
  */
 u16 rsi_get_connected_channel(struct rsi_hw *adapter)
 {
-	struct ieee80211_vif *vif = adapter->vifs[0];
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	struct rsi_common *common = adapter->priv;
+
+	if (common->iface_down)
+		return -EINVAL;
+	if ((!adapter->vifs[0]) || (!vif))
+		return -EINVAL;
 	if (vif) {
 		struct ieee80211_bss_conf *bss = &vif->bss_conf;
 		struct ieee80211_channel *channel = bss->chandef.chan;
+
+		if (!channel)
+			return 0;
 		return channel->hw_value;
 	}
 
 	return 0;
 }
 
+void rsi_resume_conn_channel(struct rsi_hw *adapter,
+			     struct ieee80211_vif *vif)
+{
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = NULL;
+
+	if (common->iface_down)
+		return;
+	if ((!adapter->vifs[0]) || (!vif))
+		return;
+
+	bss = &vif->bss_conf;
+	if ((bss->assoc) ||
+	    (vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		struct ieee80211_channel *channel = bss->chandef.chan;
+
+		if (!channel)
+			return;
+		
+		rsi_band_check(common, channel);
+
+		rsi_set_channel(common, channel);
+		rsi_dbg(INFO_ZONE, "resumed to channel %d\n",
+			channel->hw_value);
+	}
+}
+
 /**
  * rsi_mac80211_bss_info_changed() - This function is a handler for config
  *				     requests related to BSS parameters that
@@ -456,19 +1116,59 @@ static void rsi_mac80211_bss_info_changed(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+	struct ieee80211_conf *conf = &hw->conf;
+	u16 rx_filter_word = 0;
+
+	rsi_dbg(INFO_ZONE, "%s: BSS status changed; changed=%08x\n",
+		__func__, changed);
 
 	mutex_lock(&common->mutex);
-	if (changed & BSS_CHANGED_ASSOC) {
+
+	if ((changed & BSS_CHANGED_ASSOC) &&
+	    (vif->type == NL80211_IFTYPE_STATION)) {
 		rsi_dbg(INFO_ZONE, "%s: Changed Association status: %d\n",
 			__func__, bss_conf->assoc);
-		rsi_inform_bss_status(common,
-				      bss_conf->assoc,
-				      bss_conf->bssid,
-				      bss_conf->qos,
-				      bss_conf->aid);
+		bss->assoc = bss_conf->assoc;
+		if (bss->assoc) {
+			/* Send the RX filter frame */
+			rx_filter_word = (ALLOW_DATA_ASSOC_PEER |
+					  ALLOW_CTRL_ASSOC_PEER |
+					  ALLOW_MGMT_ASSOC_PEER |
+					  0);
+			rsi_send_rx_filter_frame(common, rx_filter_word);
+		}
+		rsi_dbg(INFO_ZONE,
+			"assoc_status=%d, qos=%d, aid=%d\n",
+			bss->assoc, bss->qos, bss->aid);
+		rsi_dbg(INFO_ZONE,
+				"bssid=%02x:%02x:%02x:%02x:%02x:%02x",
+				bss->bssid[0], bss->bssid[1], bss->bssid[2],
+				bss->bssid[3], bss->bssid[4], bss->bssid[5]);
+
+		/* Send peer notify to device */
+		rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
+		rsi_inform_bss_status(common, STA_OPMODE, bss->assoc,
+				      bss->bssid, bss->qos, bss->aid, NULL, 0,
+				      bss->assoc_capability);
+
+		/* Update DTIM period and listen interval */
+		adapter->ps_info.dtim_interval_duration = bss->dtim_period;
+		adapter->ps_info.listen_interval = conf->listen_interval;
+		rsi_dbg(INFO_ZONE, "Beacon_Int = %d Lis_Int = %d Dtim = %d\n",
+			bss->beacon_int, adapter->ps_info.num_bcns_per_lis_int,
+			bss->dtim_period);
+
+		/* If UAPSD is updated send ps params */
+		if (common->uapsd_bitmap) {
+			rsi_dbg(INFO_ZONE, "Configuring UAPSD\n");
+			rsi_conf_uapsd(adapter);
+		}
 	}
 
-	if (changed & BSS_CHANGED_CQM) {
+	if ((vif->type == NL80211_IFTYPE_STATION) &&
+	    changed & BSS_CHANGED_CQM) {
+		rsi_dbg(INFO_ZONE, "%s: Changed CQM\n", __func__);
 		common->cqm_info.last_cqm_event_rssi = 0;
 		common->cqm_info.rssi_thold = bss_conf->cqm_rssi_thold;
 		common->cqm_info.rssi_hyst = bss_conf->cqm_rssi_hyst;
@@ -476,6 +1176,32 @@ static void rsi_mac80211_bss_info_changed(struct ieee80211_hw *hw,
 			common->cqm_info.rssi_thold,
 			common->cqm_info.rssi_hyst);
 	}
+
+	if (changed & BSS_CHANGED_TXPOWER) {
+		rsi_dbg(INFO_ZONE, "%s: Changed TX power: %d\n",
+			__func__, bss_conf->txpower);
+	}
+
+	if (changed & BSS_CHANGED_BEACON_INT) {
+		rsi_dbg(INFO_ZONE, "%s: Changed Beacon interval: %d\n",
+			__func__, bss_conf->beacon_int);
+		common->beacon_interval = bss->beacon_int; 
+		adapter->ps_info.listen_interval =
+			bss->beacon_int * adapter->ps_info.num_bcns_per_lis_int;
+	}
+
+	if ((changed & BSS_CHANGED_BEACON_ENABLED) &&
+	    ((vif->type == NL80211_IFTYPE_AP) ||
+	     (vif->type == NL80211_IFTYPE_P2P_GO))) {
+		if (bss->enable_beacon) {
+			rsi_dbg(INFO_ZONE, "===> BEACON ENABLED <===\n");
+			common->beacon_enabled = 1;
+		} else {
+			rsi_dbg(INFO_ZONE, "===> BEACON DISABLED <===\n");
+			common->beacon_enabled = 0;
+		}
+	}
+
 	mutex_unlock(&common->mutex);
 }
 
@@ -493,8 +1219,16 @@ static void rsi_mac80211_conf_filter(struct ieee80211_hw *hw,
 				     u32 *total_flags,
 				     u64 multicast)
 {
+#if 0
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	u16 rx_filter_word = 0;
+#endif
+
 	/* Not doing much here as of now */
 	*total_flags &= RSI_SUPP_FILTERS;
+
+//	rsi_send_rx_filter_frame(common, rx_filter_word);
 }
 
 /**
@@ -520,9 +1254,9 @@ static int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,
 		return 0;
 
 	rsi_dbg(INFO_ZONE,
-		"%s: Conf queue %d, aifs: %d, cwmin: %d cwmax: %d, txop: %d\n",
-		__func__, queue, params->aifs,
-		params->cw_min, params->cw_max, params->txop);
+		"[Conf] queue:%d, aifs:%d, cwmin:%d cwmax:%d, txop:%d uapsd:%d\n",
+		queue, params->aifs, params->cw_min, params->cw_max,
+		params->txop, params->uapsd);
 
 	mutex_lock(&common->mutex);
 	/* Map into the way the f/w expects */
@@ -547,8 +1281,11 @@ static int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,
 	memcpy(&common->edca_params[idx],
 	       params,
 	       sizeof(struct ieee80211_tx_queue_params));
-	mutex_unlock(&common->mutex);
 
+	if (params->uapsd)
+		common->uapsd_bitmap |= idx;
+
+	mutex_unlock(&common->mutex);
 	return 0;
 }
 
@@ -562,11 +1299,14 @@ static int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,
  */
 static int rsi_hal_key_config(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
-			      struct ieee80211_key_conf *key)
+			      struct ieee80211_key_conf *key,
+			      struct ieee80211_sta *sta)
 {
 	struct rsi_hw *adapter = hw->priv;
+	struct rsi_sta *rsta = NULL;
 	int status;
 	u8 key_type;
+	s16 sta_id = 0;
 
 	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
 		key_type = RSI_PAIRWISE_KEY;
@@ -575,24 +1315,48 @@ static int rsi_hal_key_config(struct ieee80211_hw *hw,
 
 	rsi_dbg(ERR_ZONE, "%s: Cipher 0x%x key_type: %d key_len: %d\n",
 		__func__, key->cipher, key_type, key->keylen);
+	rsi_dbg(INFO_ZONE, "hw_key_idx %d\n", key->hw_key_idx);
 
-	if ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
-	    (key->cipher == WLAN_CIPHER_SUITE_WEP40)) {
-		status = rsi_hal_load_key(adapter->priv,
-					  key->key,
-					  key->keylen,
-					  RSI_PAIRWISE_KEY,
-					  key->keyidx,
-					  key->cipher);
-		if (status)
-			return status;
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		if (sta){
+			rsta = rsi_find_sta(adapter->priv, sta->addr);
+
+			if (rsta)
+				sta_id = rsta->sta_id;
+		}
+		adapter->priv->key = key;
+	} else {
+		if ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
+		    (key->cipher == WLAN_CIPHER_SUITE_WEP40)) {
+			status = rsi_load_key(adapter->priv,
+					      key->key,
+					      key->keylen,
+					      RSI_PAIRWISE_KEY,
+					      key->keyidx,
+					      key->cipher,
+					      sta_id);
+			if (status)
+				return status;
+		}
+	}
+
+	status = rsi_load_key(adapter->priv,
+			      key->key,
+			      key->keylen,
+			      key_type,
+			      key->keyidx,
+			      key->cipher,
+			      sta_id);
+
+	if ((vif->type == NL80211_IFTYPE_STATION) && (key->key) &&
+	    ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
+	    (key->cipher == WLAN_CIPHER_SUITE_WEP40))) {
+		adapter->priv->start_bgscan = 1;
+		if (!rsi_send_block_unblock_frame(adapter->priv, false))
+			adapter->priv->hw_data_qs_blocked = false;
 	}
-	return rsi_hal_load_key(adapter->priv,
-				key->key,
-				key->keylen,
-				key_type,
-				key->keyidx,
-				key->cipher);
+	return status;
 }
 
 /**
@@ -620,7 +1384,7 @@ static int rsi_mac80211_set_key(struct ieee80211_hw *hw,
 	switch (cmd) {
 	case SET_KEY:
 		secinfo->security_enable = true;
-		status = rsi_hal_key_config(hw, vif, key);
+		status = rsi_hal_key_config(hw, vif, key, sta);
 		if (status) {
 			mutex_unlock(&common->mutex);
 			return status;
@@ -641,7 +1405,7 @@ static int rsi_mac80211_set_key(struct ieee80211_hw *hw,
 		secinfo->security_enable = false;
 		rsi_dbg(ERR_ZONE, "%s: RSI del key\n", __func__);
 		memset(key, 0, sizeof(struct ieee80211_key_conf));
-		status = rsi_hal_key_config(hw, vif, key);
+		status = rsi_hal_key_config(hw, vif, key, sta);
 		break;
 
 	default:
@@ -667,19 +1431,43 @@ static int rsi_mac80211_set_key(struct ieee80211_hw *hw,
  *
  * Return: status: 0 on success, negative error code on failure.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
 static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif,
 				     enum ieee80211_ampdu_mlme_action action,
 				     struct ieee80211_sta *sta,
-				     unsigned short tid,
-				     unsigned short *ssn,
-				     unsigned char buf_size)
-{
-	int status = -EOPNOTSUPP;
-	struct rsi_hw *adapter = hw->priv;
+				     u16 tid,
+				     u16 *ssn,
+				     u8 buf_size)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0))
+static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     enum ieee80211_ampdu_mlme_action action,
+				     struct ieee80211_sta *sta,
+				     u16 tid,
+				     u16 *ssn,
+				     u8 buf_size,
+				     bool amsdu)
+#else
+static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_ampdu_params *params)
+#endif
+{
+	int status = 1;
+	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
-	u16 seq_no = 0;
+  struct rsi_sta *rsta = NULL;
+	u16 seq_no = 0, seq_start = 0;
 	u8 ii = 0;
+	u8 sta_id = 0;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	u16 tid = params->tid;
+	u8 buf_size = params->buf_size;
+	enum ieee80211_ampdu_mlme_action action = params->action;
+	struct ieee80211_sta *sta = params->sta;
+#endif
 
 	for (ii = 0; ii < RSI_MAX_VIFS; ii++) {
 		if (vif == adapter->vifs[ii])
@@ -687,29 +1475,59 @@ static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
 	}
 
 	mutex_lock(&common->mutex);
-	rsi_dbg(INFO_ZONE, "%s: AMPDU action %d called\n", __func__, action);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0))
 	if (ssn != NULL)
 		seq_no = *ssn;
+#else
+	seq_no = params->ssn;
+#endif
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsta = rsi_find_sta(common, sta->addr);
+
+		if (!rsta) {
+			rsi_dbg(ERR_ZONE, "No station mapped\n");
+			return 0;
+		}
+		sta_id = rsta->sta_id;
+	}
+
+	rsi_dbg(INFO_ZONE,
+		"%s: AMPDU action tid=%d ssn=0x%x, buf_size=%d\n",
+		__func__, tid, seq_no, buf_size);
 
 	switch (action) {
 	case IEEE80211_AMPDU_RX_START:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   seq_no,
-							   buf_size,
-							   STA_RX_ADDBA_DONE);
+		rsi_dbg(INFO_ZONE, "AMPDU action RX_START (%d)\n", action);
+		status = rsi_send_aggr_params_frame(common,
+						    tid,
+						    seq_no,
+						    buf_size,
+						    STA_RX_ADDBA_DONE,
+						    sta_id);
 		break;
 
 	case IEEE80211_AMPDU_RX_STOP:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   0,
-							   buf_size,
-							   STA_RX_DELBA);
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action RX_STOP (%d) called\n", action);
+		status = rsi_send_aggr_params_frame(common,
+						    tid,
+						    0,
+						    buf_size,
+						    STA_RX_DELBA,
+						    sta_id);
 		break;
 
 	case IEEE80211_AMPDU_TX_START:
-		common->vif_info[ii].seq_start = seq_no;
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action TX_START (%d) called\n", action);
+		if ((vif->type == NL80211_IFTYPE_STATION) ||
+		    (vif->type == NL80211_IFTYPE_P2P_CLIENT))
+			common->vif_info[ii].seq_start = seq_no;
+		else if ((vif->type == NL80211_IFTYPE_AP) ||
+			 (vif->type == NL80211_IFTYPE_P2P_GO))
+			rsta->seq_start[ii] = seq_no;
 		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
 		status = 0;
 		break;
@@ -717,22 +1535,35 @@ static int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,
 	case IEEE80211_AMPDU_TX_STOP_CONT:
 	case IEEE80211_AMPDU_TX_STOP_FLUSH:
 	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   seq_no,
-							   buf_size,
-							   STA_TX_DELBA);
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action TX_STOP_CONT / TX_STOP_FLUSH /"
+			" TX_STOP_FLUSH_CONT (%d) called\n", action);
+		status = rsi_send_aggr_params_frame(common,
+						    tid,
+						    seq_no,
+						    buf_size,
+						    STA_TX_DELBA,
+						    sta_id);
 		if (!status)
 			ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
 		break;
 
 	case IEEE80211_AMPDU_TX_OPERATIONAL:
-		status = rsi_send_aggregation_params_frame(common,
-							   tid,
-							   common->vif_info[ii]
-								.seq_start,
-							   buf_size,
-							   STA_TX_ADDBA_DONE);
+		rsi_dbg(INFO_ZONE,
+			"AMPDU action TX_OPERATIONAL(%d) called\n",
+			action);
+    if ((vif->type == NL80211_IFTYPE_STATION) ||
+        (vif->type == NL80211_IFTYPE_P2P_CLIENT))
+      seq_start = common->vif_info[ii].seq_start;
+    else if ((vif->type == NL80211_IFTYPE_AP) ||
+        (vif->type == NL80211_IFTYPE_P2P_GO))
+      seq_start = rsta->seq_start[ii];
+		status = rsi_send_aggr_params_frame(common,
+						tid,
+						seq_start,
+						buf_size,
+						STA_TX_ADDBA_DONE,
+						sta_id);
 		break;
 
 	default:
@@ -778,7 +1609,7 @@ static int rsi_mac80211_set_rate_mask(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
-	enum ieee80211_band band = hw->conf.chandef.chan->band;
+	enum nl80211_band band = hw->conf.chandef.chan->band;
 
 	mutex_lock(&common->mutex);
 	common->fixedrate_mask[band] = 0;
@@ -787,8 +1618,7 @@ static int rsi_mac80211_set_rate_mask(struct ieee80211_hw *hw,
 		common->fixedrate_mask[band] =
 			(mask->control[band].ht_mcs[0] << 12);
 	} else {
-		common->fixedrate_mask[band] =
-			mask->control[band].legacy;
+		common->fixedrate_mask[band] = mask->control[band].legacy;
 	}
 	mutex_unlock(&common->mutex);
 
@@ -811,6 +1641,9 @@ static void rsi_perform_cqm(struct rsi_common *common,
 	u32 hyst = common->cqm_info.rssi_hyst;
 	enum nl80211_cqm_rssi_threshold_event event;
 
+	if (common->iface_down)
+		return;
+
 	if (rssi < thold && (last_event == 0 || rssi < (last_event - hyst)))
 		event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
 	else if (rssi > thold &&
@@ -820,9 +1653,22 @@ static void rsi_perform_cqm(struct rsi_common *common,
 		return;
 
 	common->cqm_info.last_cqm_event_rssi = rssi;
-	rsi_dbg(INFO_ZONE, "CQM: Notifying event: %d\n", event);
-	ieee80211_cqm_rssi_notify(adapter->vifs[0], event, GFP_KERNEL);
+	rsi_dbg(INFO_ZONE, "CQM: Notifying event: %s\n",
+		(event == NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW) ? "LOW" : "HIGH");
+	ieee80211_cqm_rssi_notify(adapter->vifs[adapter->sc_nvifs - 1],
+				  event, GFP_KERNEL);
+}
+
+void rsi_indicate_bcnmiss(struct rsi_common *common)
+{
+	struct rsi_hw *adapter = common->priv;
 
+	rsi_dbg(INFO_ZONE, "CQM: Notifying beacon miss\n" );
+
+	if (common->iface_down)
+		return;
+
+	ieee80211_beacon_loss(adapter->vifs[0]);
 	return;
 }
 
@@ -841,7 +1687,9 @@ static void rsi_fill_rx_status(struct ieee80211_hw *hw,
 			       struct rsi_common *common,
 			       struct ieee80211_rx_status *rxs)
 {
-	struct ieee80211_bss_conf *bss = &common->priv->vifs[0]->bss_conf;
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+	struct ieee80211_bss_conf *bss = NULL;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct skb_info *rx_params = (struct skb_info *)info->driver_data;
 	struct ieee80211_hdr *hdr;
@@ -877,17 +1725,22 @@ static void rsi_fill_rx_status(struct ieee80211_hw *hw,
 		rxs->flag |= RX_FLAG_IV_STRIPPED;
 	}
 
+	if (!vif) {
+		rsi_dbg(INFO_ZONE, "No virtual interface\n");
+		return;
+	}
+	bss = &vif->bss_conf;
+
 	/* CQM only for connected AP beacons, the RSSI is a weighted avg */
-	if (bss->assoc && !(memcmp(bss->bssid, hdr->addr2, ETH_ALEN))) {
+	if ((vif->type == NL80211_IFTYPE_STATION) && bss->assoc &&
+	    ether_addr_equal(bss->bssid, hdr->addr2)) {
 		if (ieee80211_is_beacon(hdr->frame_control))
 			rsi_perform_cqm(common, hdr->addr2, rxs->signal);
 	}
-
-	return;
 }
 
 /**
- * rsi_indicate_pkt_to_os() - This function sends recieved packet to mac80211.
+ * rsi_indicate_pkt_to_os() - This function sends received packet to mac80211.
  * @common: Pointer to the driver private structure.
  * @skb: Pointer to the socket buffer structure.
  *
@@ -908,49 +1761,12 @@ void rsi_indicate_pkt_to_os(struct rsi_common *common,
 	/* filling in the ieee80211_rx_status flags */
 	rsi_fill_rx_status(hw, skb, common, rx_status);
 
+	rsi_dbg(INFO_ZONE, "RX Packet Type: %s\n",
+		dot11_pkt_type(skb->data[0]));
+	rsi_hex_dump(DATA_RX_ZONE, "802.11 RX packet", skb->data, skb->len);
 	ieee80211_rx_irqsafe(hw, skb);
 }
 
-static void rsi_set_min_rate(struct ieee80211_hw *hw,
-			     struct ieee80211_sta *sta,
-			     struct rsi_common *common)
-{
-	u8 band = hw->conf.chandef.chan->band;
-	u8 ii;
-	u32 rate_bitmap;
-	bool matched = false;
-
-	common->bitrate_mask[band] = sta->supp_rates[band];
-
-	rate_bitmap = (common->fixedrate_mask[band] & sta->supp_rates[band]);
-
-	if (rate_bitmap & 0xfff) {
-		/* Find out the min rate */
-		for (ii = 0; ii < ARRAY_SIZE(rsi_rates); ii++) {
-			if (rate_bitmap & BIT(ii)) {
-				common->min_rate = rsi_rates[ii].hw_value;
-				matched = true;
-				break;
-			}
-		}
-	}
-
-	common->vif_info[0].is_ht = sta->ht_cap.ht_supported;
-
-	if ((common->vif_info[0].is_ht) && (rate_bitmap >> 12)) {
-		for (ii = 0; ii < ARRAY_SIZE(rsi_mcsrates); ii++) {
-			if ((rate_bitmap >> 12) & BIT(ii)) {
-				common->min_rate = rsi_mcsrates[ii];
-				matched = true;
-				break;
-			}
-		}
-	}
-
-	if (!matched)
-		common->min_rate = 0xffff;
-}
-
 /**
  * rsi_mac80211_sta_add() - This function notifies driver about a peer getting
  *			    connected.
@@ -966,18 +1782,95 @@ static int rsi_mac80211_sta_add(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	bool sta_exist = 0;
+
+	rsi_hex_dump(INFO_ZONE, "Station Add: ", sta->addr, ETH_ALEN);
 
 	mutex_lock(&common->mutex);
 
-	rsi_set_min_rate(hw, sta, common);
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		u8 i, j;
+		int free_index = -1;
+
+		/* Check if max stations reached */
+		if (common->num_stations >= common->max_stations) {
+			rsi_dbg(ERR_ZONE, "Reject: Max Stations exists\n");
+			return -EOPNOTSUPP;
+		}
+
+		/* Send peer notify to device */
+		rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
+		for (i = 0; i < common->max_stations; i++) {
+			if (!common->stations[i].sta) {
+				if (free_index < 0)
+					free_index = i;
+				continue; 
+			}
+			if (!memcmp(common->stations[i].sta->addr,
+				    sta->addr, ETH_ALEN)) {
+				rsi_dbg(INFO_ZONE, "Station exists\n");
+				sta_exist = 1;
+				break;
+			}
+		}
+		if (!sta_exist) {
+			rsi_dbg(INFO_ZONE, "New Station\n");
+			if (free_index >= 0)
+				i = free_index;
+			common->stations[i].sta = sta;
+			common->stations[i].sta_id = i;
+			rsi_inform_bss_status(common, AP_OPMODE, 1, sta->addr,
+					      sta->wme, sta->aid, sta, i, 0);
+		
+			if (common->key &&
+			    ((common->key->cipher == WLAN_CIPHER_SUITE_WEP104) ||
+			    (common->key->cipher == WLAN_CIPHER_SUITE_WEP40))) {
+				rsi_load_key(adapter->priv,
+					     common->key->key,
+					     common->key->keylen,
+					     RSI_PAIRWISE_KEY,
+					     common->key->keyidx,
+					     common->key->cipher,
+					     i);
+			}
+			for (j = 0; j < IEEE80211_NUM_ACS; j++)
+				common->stations[i].seq_no[j] = 1;
+			common->num_stations++;
+		} else {
+			common->stations[i].sta = sta;
+			common->stations[i].sta_id = i;
+			for (j = 0; j < IEEE80211_NUM_ACS; j++)
+				common->stations[i].seq_no[j] = 1;
+		}
+	}
 
 	if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
 	    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40)) {
 		common->vif_info[0].sgi = true;
 	}
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		rsi_set_min_rate(hw, sta, common);
+		if (g_bgscan_enable) {
+			if (!rsi_send_bgscan_params(common, 1)) {
+				if (!rsi_send_bgscan_probe_req(common)) {
+					rsi_dbg(INFO_ZONE,
+						"Bgscan started ===>\n");
+					common->bgscan_en = 1;
+				}
+			}
+		}
+	}
 
-	if (sta->ht_cap.ht_supported)
+	if (sta->ht_cap.ht_supported) {
+		common->vif_info[0].is_ht = true;
+		common->bitrate_mask[NL80211_BAND_2GHZ] =
+				sta->supp_rates[NL80211_BAND_2GHZ];
+		if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
+		    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))
+			common->vif_info[0].sgi = true;
 		ieee80211_start_tx_ba_session(sta, 0, 0);
+	}
 
 	mutex_unlock(&common->mutex);
 
@@ -999,21 +1892,663 @@ static int rsi_mac80211_sta_remove(struct ieee80211_hw *hw,
 {
 	struct rsi_hw *adapter = hw->priv;
 	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &vif->bss_conf;
+//		&adapter->vifs[adapter->sc_nvifs - 1]->bss_conf;
+
+	rsi_hex_dump(INFO_ZONE, "Station Removed: ", sta->addr, ETH_ALEN);
+
+	mutex_lock(&common->mutex);
+	if ((vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		u8 i, j;
+
+		/* Send peer notify to device */
+		rsi_dbg(INFO_ZONE, "Indicate bss status to device\n");
+		for (i = 0; i < common->max_stations; i++) {
+			if (!common->stations[i].sta)
+				continue;
+			if (!memcmp(common->stations[i].sta->addr,
+				    sta->addr, ETH_ALEN)) {
+				rsi_inform_bss_status(common, AP_OPMODE, 0,
+						      sta->addr, sta->wme,
+						      sta->aid, sta, i, 0);
+				common->stations[i].sta = NULL;
+				common->stations[i].sta_id = -1;
+				for (j = 0; j < IEEE80211_NUM_ACS; j++)
+					common->stations[i].seq_no[j] = 0;
+				if (common->num_stations > 0)
+					common->num_stations--;
+				break;
+			}
+		}
+		if (i >= common->max_stations)
+			rsi_dbg(ERR_ZONE, "%s: No station found\n", __func__);
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		/* Resetting all the fields to default values */
+		memcpy((u8 *)bss->bssid, (u8 *)sta->addr, ETH_ALEN);
+		bss->qos = sta->wme;
+		common->bitrate_mask[NL80211_BAND_2GHZ] = 0;
+		common->bitrate_mask[NL80211_BAND_5GHZ] = 0;
+		common->min_rate = 0xffff;
+		common->vif_info[0].is_ht = false;
+		common->vif_info[0].sgi = false;
+		common->vif_info[0].seq_start = 0;
+		common->secinfo.ptk_cipher = 0;
+		common->secinfo.gtk_cipher = 0;
+#ifndef CONFIG_HW_SCAN_OFFLOAD
+		if (common->bgscan_en)
+			common->bgscan_en = 0;
+#endif
+		if (!common->iface_down)
+			rsi_send_rx_filter_frame(common, 0);
+	}
+	mutex_unlock(&common->mutex);
+	return 0;
+}
+
+#ifndef CONFIG_HW_SCAN_OFFLOAD
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 0))
+static void rsi_mac80211_sw_scan_start(struct ieee80211_hw *hw)
+#else
+static void rsi_mac80211_sw_scan_start(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       const u8 *mac_addr)
+#endif
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+
+	if (common->p2p_enabled)
+		return;
+	if (!bss->assoc)
+		return;
+
+	mutex_lock(&common->mutex);
+
+	if (!rsi_send_bgscan_params(common, 1)) {
+		if (!rsi_send_bgscan_probe_req(common)) {
+			rsi_dbg(INFO_ZONE,
+				"Background scan started\n");
+			common->bgscan_en = 1;
+		}
+	}
+	
+	mutex_unlock(&common->mutex);
+
+	return ;
+}
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 0))
+static void rsi_mac80211_sw_scan_stop(struct ieee80211_hw *hw)
+#else
+static void rsi_mac80211_sw_scan_stop(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif)
+#endif
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+
+	if (common->p2p_enabled)
+		return;
+
+	mutex_lock(&common->mutex);
+	
+	if (common->bgscan_en) {
+		if (!rsi_send_bgscan_params(common, 0)) {
+			common->bgscan_en = 0;
+			rsi_dbg(INFO_ZONE,"Bg scan stopped");
+		}
+	}
+
+	mutex_unlock(&common->mutex);
+
+	return;
+}
+#endif
+
+/**
+ * rsi_mac80211_set_antenna() - This function is used to configure
+ *				tx and rx antennas.
+ * @hw: Pointer to the ieee80211_hw structure.
+ * @tx_ant: Bitmap for tx antenna
+ * @rx_ant: Bitmap for rx antenna
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+static int rsi_mac80211_set_antenna(struct ieee80211_hw *hw,
+				    u32 tx_ant, u32 rx_ant)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	u32 antenna = 0;
+
+	if (tx_ant > 1 || rx_ant > 1) {
+		rsi_dbg(ERR_ZONE,
+			"Invalid antenna selection (tx: %d, rx:%d)\n",
+			tx_ant, rx_ant);
+		rsi_dbg(ERR_ZONE,
+			"Use 0 for int_ant, 1 for ext_ant\n");
+		return -EINVAL; 
+	}
+
+	rsi_dbg(INFO_ZONE, "%s: Antenna map Tx %x Rx %d\n",
+			__func__, tx_ant, rx_ant);
+
+	mutex_lock(&common->mutex);
+
+	antenna = tx_ant ? ANTENNA_SEL_UFL : ANTENNA_SEL_INT;
+	if (common->ant_in_use != antenna)
+		if (rsi_set_antenna(common, antenna))
+			goto fail_set_antenna;
+
+	rsi_dbg(INFO_ZONE, "(%s) Antenna path configured successfully\n",
+		tx_ant ? "UFL" : "INT");
+
+	common->ant_in_use = antenna;
+	
+	mutex_unlock(&common->mutex);
+	
+	return 0;
+
+fail_set_antenna:
+	rsi_dbg(ERR_ZONE, "%s: Failed.\n", __func__);
+	mutex_unlock(&common->mutex);
+	return -EINVAL;
+}
+
+/**
+ * rsi_mac80211_get_antenna() - This function is used to configure 
+ * 				tx and rx antennas.
+ *
+ * @hw: Pointer to the ieee80211_hw structure.
+ * @tx_ant: Bitmap for tx antenna
+ * @rx_ant: Bitmap for rx antenna
+ * 
+ * Return: 0 on success, -1 on failure.
+ */
+static int rsi_mac80211_get_antenna(struct ieee80211_hw *hw,
+				    u32 *tx_ant, u32 *rx_ant)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
 
 	mutex_lock(&common->mutex);
-	/* Resetting all the fields to default values */
-	common->bitrate_mask[IEEE80211_BAND_2GHZ] = 0;
-	common->bitrate_mask[IEEE80211_BAND_5GHZ] = 0;
-	common->min_rate = 0xffff;
-	common->vif_info[0].is_ht = false;
-	common->vif_info[0].sgi = false;
-	common->vif_info[0].seq_start = 0;
-	common->secinfo.ptk_cipher = 0;
-	common->secinfo.gtk_cipher = 0;
+
+	*tx_ant = (common->ant_in_use == ANTENNA_SEL_UFL) ? 1 : 0;
+	*rx_ant = 0;
+
 	mutex_unlock(&common->mutex);
+	
+	return 0;	
+}
+
+static const char *regdfs_region_str(enum nl80211_dfs_regions dfs_region)
+{
+        switch (dfs_region) {
+        case NL80211_DFS_UNSET:
+                return "unset";
+        case NL80211_DFS_FCC:
+                return "FCC";
+        case NL80211_DFS_ETSI:
+                return "ETSI";
+        case NL80211_DFS_JP:
+                return "JP";
+        }
+        return "Unknown";
+}
+
+static void rsi_reg_notify(struct wiphy *wiphy,
+			   struct regulatory_request *request)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct rsi_hw * adapter = hw->priv; 
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_channel *ch;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs -1];
+	int i;
+
+	mutex_lock(&common->mutex);
+
+	rsi_dbg(ERR_ZONE, "%s: Updating regulatory for region %s\n",
+		__func__, regdfs_region_str(request->dfs_region));
+
+	sband = wiphy->bands[NL80211_BAND_2GHZ];
+	switch (request->dfs_region) {
+	case NL80211_DFS_FCC:
+		for(i = 0; i < sband->n_channels; i++){
+	 		ch = &sband->channels[i];
+		
+#ifdef CONFIG_CARACALLA_BOARD
+			if ((ch->hw_value == 12) ||
+			    (ch->hw_value == 13)) {
+				if (ch->flags & IEEE80211_CHAN_DISABLED)
+					ch->flags &= ~IEEE80211_CHAN_DISABLED;
+				if (ch->flags & IEEE80211_CHAN_NO_IR)
+					ch->flags &= ~IEEE80211_CHAN_NO_IR;
+				rsi_apply_carcalla_power_values(adapter, vif, ch);
+			}
+#else	
+			if ((ch->hw_value == 12) ||
+			    (ch->hw_value == 13) ||
+			    (ch->hw_value == 14)) {
+				if (!(ch->flags & IEEE80211_CHAN_NO_IR))
+					ch->flags |= IEEE80211_CHAN_NO_IR;
+			}
+#endif
+		}
+		break;
+
+	case NL80211_DFS_UNSET:
+	case NL80211_DFS_ETSI:
+		
+		for(i = 0; i < sband->n_channels; i++){
+	 		ch = &sband->channels[i];
+			
+			if ((ch->hw_value == 12) || (ch->hw_value == 13)) {
+				if (ch->flags & IEEE80211_CHAN_NO_IR)
+					ch->flags &= ~IEEE80211_CHAN_NO_IR;
+#ifdef CONFIG_CARACALLA_BOARD
+				rsi_apply_carcalla_power_values(adapter, vif, ch);
+#endif
+			}
+		       	if (ch->hw_value == 14) {
+				if (!(ch->flags & IEEE80211_CHAN_NO_IR))
+					ch->flags |= IEEE80211_CHAN_NO_IR;
+			}
+		}
+		break;
+
+	case NL80211_DFS_JP:
+		
+		for(i = 0; i < sband->n_channels; i++){
+	 		ch = &sband->channels[i];
+			
+			if ((ch->hw_value == 12) ||
+			    (ch->hw_value == 13) ||
+			    (ch->hw_value == 14)) {
+				if (ch->flags & IEEE80211_CHAN_NO_IR)
+					ch->flags &= ~IEEE80211_CHAN_NO_IR;
+#ifdef CONFIG_CARACALLA_BOARD
+				rsi_apply_carcalla_power_values(adapter, vif, ch);
+#endif
+			}
+		}
+		break;
+
+	default:
+		rsi_dbg(ERR_ZONE,
+			"Wrong Country region code seleted\ndfs_region = %d\n",
+			request->dfs_region);
+		break;
+	}
+
+	if (common->num_supp_bands > 1) {
+		sband = wiphy->bands[NL80211_BAND_5GHZ];
+
+		for (i = 0; i < sband->n_channels; i++) {
+			ch = &sband->channels[i];
+			if (ch->flags & IEEE80211_CHAN_DISABLED)
+				continue;
+
+			if (ch->flags & IEEE80211_CHAN_RADAR)
+				ch->flags |= IEEE80211_CHAN_NO_IR;
+		}
+	}
+
+	rsi_dbg(INFO_ZONE,
+		"country = %s dfs_region = %d\n",
+		request->alpha2, request->dfs_region);
+
+#ifndef CONFIG_HW_SCAN_OFFLOAD 
+	/* If DFS region or country is changed configure back ground scan
+	 * params to device again */
+	if ((adapter->dfs_region != request->dfs_region) ||
+	    (memcmp(adapter->country, request->alpha2, 2))) {
+		if (common->bgscan_en) {
+			rsi_send_bgscan_params(common, 0);
+			common->bgscan_en = 0;
+			mdelay(10);
+			rsi_send_bgscan_params(common, 1);
+			common->bgscan_en = 1;
+		}
+	}
+#endif
+	
+	adapter->dfs_region = request->dfs_region;
+	adapter->country[0] = request->alpha2[0];
+	adapter->country[1] = request->alpha2[1];
+	mutex_unlock(&common->mutex);
+}
 
+void rsi_mac80211_rfkill_poll(struct ieee80211_hw *hw)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	
+	mutex_lock(&common->mutex);
+
+	if (common->fsm_state != FSM_MAC_INIT_DONE)
+		wiphy_rfkill_set_hw_state(hw->wiphy, true);
+	else
+		wiphy_rfkill_set_hw_state(hw->wiphy, false);
+
+	mutex_unlock(&common->mutex);
+}
+
+#ifdef CONFIG_RSI_WOW
+static const struct wiphy_wowlan_support rsi_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY |
+		 WIPHY_WOWLAN_MAGIC_PKT |
+		 WIPHY_WOWLAN_DISCONNECT |
+		 WIPHY_WOWLAN_GTK_REKEY_FAILURE  |
+		 WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
+		 WIPHY_WOWLAN_EAP_IDENTITY_REQ   |
+		 WIPHY_WOWLAN_4WAY_HANDSHAKE,
+	.n_patterns = 0,
+	.pattern_min_len = 1,
+	.pattern_max_len = 0,
+};
+
+static u16 rsi_wow_map_triggers(struct rsi_common *common,
+				struct cfg80211_wowlan *wowlan)
+{
+	u16 wow_triggers = 0;
+
+        rsi_dbg(INFO_ZONE,"Mapping wowlan triggers\n");
+
+	if (wowlan->any)
+		wow_triggers |= RSI_WOW_ANY;
+	if (wowlan->magic_pkt)
+		wow_triggers |= RSI_WOW_MAGIC_PKT;
+	if (wowlan->disconnect)
+		wow_triggers |= RSI_WOW_DISCONNECT;
+	if (wowlan->gtk_rekey_failure || wowlan->eap_identity_req ||
+	    wowlan->four_way_handshake)
+		wow_triggers |= RSI_WOW_GTK_REKEY;
+	
+	return wow_triggers;
+}
+#endif
+
+#ifdef CONFIG_PM
+int rsi_mac80211_suspend(struct ieee80211_hw *hw,
+			 struct cfg80211_wowlan *wowlan)
+{
+#ifdef CONFIG_RSI_WOW
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	u16 triggers = 0;
+       	u16 rx_filter_word = 0;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+#endif
+	int ret = 0;
+
+	rsi_dbg(INFO_ZONE, "***** mac80211 suspend called ******\n");
+
+#ifdef CONFIG_RSI_WOW
+	if (WARN_ON(!wowlan)) {
+		rsi_dbg(ERR_ZONE,
+			"##### WoW triggers not enabled #####\n");
+		ret = -EINVAL;
+		goto fail_wow;
+	}
+
+	triggers = rsi_wow_map_triggers(common, wowlan);
+	if (!triggers) {
+		rsi_dbg(ERR_ZONE, "%s:No valid WoW triggers\n",__func__);
+		ret = -EINVAL;
+		goto fail_wow;
+	}
+	if (!bss->assoc) {
+		rsi_dbg(ERR_ZONE,
+			"Cannot configure WoWLAN (Station not connected)\n");
+		common->suspend_flag = STATION_NOT_CONNECTED;
+		ret = 0;
+		goto fail_wow;
+	}
+
+	/* Send updated vap caps */
+	rsi_send_vap_dynamic_update(common);
+
+	rx_filter_word = (ALLOW_DATA_ASSOC_PEER |
+			  DISALLOW_BEACONS |
+			  0);
+
+
+	rsi_send_wowlan_request(common, triggers, 1);
+	rsi_dbg(INFO_ZONE, "TRIGGERS %x\n", triggers);
+	rsi_send_rx_filter_frame(common, rx_filter_word);
+
+        common->suspend_flag = 1;
+fail_wow:
+#endif
+        return (ret ? 1 : 0);
+}
+
+static int rsi_mac80211_resume(struct ieee80211_hw *hw)
+{
+#ifdef CONFIG_RSI_WOW
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	u16 rx_filter_word = 0;
+        
+	adapter->priv->suspend_flag = 0;
+#endif
+	
+	rsi_dbg(INFO_ZONE, "%s: mac80211 resume\n", __func__);
+
+#ifdef CONFIG_RSI_WOW
+	rsi_send_wowlan_request(common, 0, 0);
+	//rx_filter_word = 0xE ;
+
+	rx_filter_word = (ALLOW_DATA_ASSOC_PEER |
+			  ALLOW_CTRL_ASSOC_PEER |
+			  ALLOW_MGMT_ASSOC_PEER |
+			  0);
+	rsi_send_rx_filter_frame(common, rx_filter_word);
+#endif
 	return 0;
 }
+#endif
+char *rsi_vif_type_to_name(enum nl80211_iftype vif_type)
+{
+	switch (vif_type) {
+	case NL80211_IFTYPE_STATION:
+		return "Station";
+		break;
+	case NL80211_IFTYPE_AP:
+		return "AP";
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		return "P2P_Device";
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return "P2P_Client";
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		return "P2P_GO";
+		break;
+	default:
+		return "Unknown";
+		break;
+	}
+	return "Unknown";
+}
+
+enum opmode rsi_map_vif_type(enum nl80211_iftype vif_type)
+{
+	switch (vif_type) {
+	case NL80211_IFTYPE_STATION:
+		return STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_AP:
+		return AP_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		return STA_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return P2P_CLIENT_OPMODE;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		return P2P_GO_OPMODE;
+		break;
+	default:
+		return UNKNOW_OPMODE;
+	}
+	return UNKNOW_OPMODE;
+}
+
+void rsi_roc_timeout(unsigned long data)
+{
+	struct rsi_common *common = (struct rsi_common *)data;
+	struct ieee80211_vif *vif = common->roc_vif;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	enum opmode intf_mode; 
+
+	rsi_dbg(INFO_ZONE, "Remain on channel expired\n");	
+	
+	mutex_lock(&common->mutex);
+	
+	ieee80211_remain_on_channel_expired(common->priv->hw);
+	
+	if (timer_pending(&common->roc_timer))
+		del_timer(&common->roc_timer);
+
+	if ((vif->type == NL80211_IFTYPE_STATION) ||
+	    (vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsi_dbg(INFO_ZONE, "Resume to connected channel\n");
+		rsi_resume_conn_channel(common->priv, vif);
+	}
+
+	intf_mode = rsi_map_vif_type(vif->type);
+	if ((common->last_vap_type != intf_mode) ||
+	    (!ether_addr_equal(common->last_vap_addr, vif->addr))) {
+		rsi_dbg(INFO_ZONE, "Resume the vap caps to orig mode\n");	
+		if (rsi_set_vap_capabilities(common, intf_mode,
+					     vif->addr,
+					     vif_info->vap_id,
+					     VAP_UPDATE))
+			rsi_dbg(ERR_ZONE, "Failed to update VAP caps\n");
+	}
+
+	mutex_unlock(&common->mutex);
+}
+
+static int rsi_mac80211_cancel_roc(struct ieee80211_hw *hw)
+{
+	struct rsi_hw *adapter = hw->priv;
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_vif *vif = common->roc_vif;
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	enum opmode intf_mode; 
+	
+	rsi_dbg(INFO_ZONE, "Cancel remain on channel\n");
+
+	mutex_lock(&common->mutex);
+	if (!timer_pending(&adapter->priv->roc_timer))
+		return 0;
+
+	if (timer_pending(&adapter->priv->roc_timer))
+		del_timer(&adapter->priv->roc_timer);
+
+	if ((vif->type == NL80211_IFTYPE_STATION) ||
+	    (vif->type == NL80211_IFTYPE_AP) ||
+	    (vif->type == NL80211_IFTYPE_P2P_GO)) {
+		rsi_dbg(INFO_ZONE, "Resume to connected channel\n");
+		rsi_resume_conn_channel(adapter, vif);
+	}
+
+	intf_mode = rsi_map_vif_type(vif->type);
+	if ((common->last_vap_type != intf_mode) ||
+	    (!ether_addr_equal(common->last_vap_addr, vif->addr))) {
+		rsi_dbg(INFO_ZONE, "Resume the vap caps to orig mode\n");
+		if (rsi_set_vap_capabilities(common, intf_mode,
+					     vif->addr, vif_info->vap_id,
+					     VAP_UPDATE))
+			rsi_dbg(ERR_ZONE, "Failed to update VAP caps\n");
+	}
+
+	mutex_unlock(&common->mutex);
+	
+	return 0;
+}
+
+static int rsi_mac80211_roc(struct ieee80211_hw *hw,
+			    struct ieee80211_vif *vif,
+			    struct ieee80211_channel *chan,
+			    int duration,
+			    enum ieee80211_roc_type type)
+{
+	struct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;
+	struct rsi_hw *adapter = (struct rsi_hw *)hw->priv;
+	struct rsi_common *common = (struct rsi_common *)adapter->priv;
+	int status = 0;
+
+	rsi_dbg(INFO_ZONE, "***** Remain on channel *****\n");
+
+	if (common->priv->sc_nvifs <= 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: No virtual interface found\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&common->mutex);
+
+	rsi_dbg(INFO_ZONE,
+		"%s: channel_no: %d duration: %dms\n",
+		__func__, chan->hw_value, duration);
+
+	if (timer_pending(&common->roc_timer)) {
+		rsi_dbg(INFO_ZONE, "Stop on-going ROC\n");
+		del_timer(&common->roc_timer);
+	}
+	common->roc_timer.expires = msecs_to_jiffies(duration) + jiffies;
+        add_timer(&common->roc_timer);	
+
+	/* Configure band */
+	if (rsi_band_check(common, chan)) {
+		rsi_dbg(ERR_ZONE, "Failed to set band\n");
+		status = -EINVAL;
+		goto out;
+	}
+
+	/* Configure channel */
+	if (rsi_set_channel(common, chan)) {
+		rsi_dbg(ERR_ZONE, "Failed to set the channel\n");
+		status = -EINVAL;
+		goto out;
+	}
+
+	/* For listen phase, configure vap as AP mode */
+	if (vif->type == NL80211_IFTYPE_P2P_DEVICE) {
+		rsi_dbg(INFO_ZONE, "Update VAP mode to p2p_client mode\n");	
+		if (rsi_set_vap_capabilities(common, P2P_CLIENT_OPMODE,
+					     vif->addr, vif_info->vap_id,
+					     VAP_UPDATE)) {
+			rsi_dbg(ERR_ZONE,
+				"Failed to update VAP capabilities\n");
+			goto out;
+		}
+	}
+
+	common->roc_vif = vif;
+	ieee80211_ready_on_channel(hw);
+	rsi_dbg(INFO_ZONE, "%s: Ready on channel :%d\n",
+		__func__, chan->hw_value);	
+
+out:
+	mutex_unlock(&common->mutex);
+
+	return status;
+}
+
+
 
 static struct ieee80211_ops mac80211_ops = {
 	.tx = rsi_mac80211_tx,
@@ -1021,6 +2556,7 @@ static struct ieee80211_ops mac80211_ops = {
 	.stop = rsi_mac80211_stop,
 	.add_interface = rsi_mac80211_add_interface,
 	.remove_interface = rsi_mac80211_remove_interface,
+	.change_interface = rsi_mac80211_change_interface,
 	.config = rsi_mac80211_config,
 	.bss_info_changed = rsi_mac80211_bss_info_changed,
 	.conf_tx = rsi_mac80211_conf_tx,
@@ -1031,6 +2567,22 @@ static struct ieee80211_ops mac80211_ops = {
 	.ampdu_action = rsi_mac80211_ampdu_action,
 	.sta_add = rsi_mac80211_sta_add,
 	.sta_remove = rsi_mac80211_sta_remove,
+	.set_antenna = rsi_mac80211_set_antenna,
+	.get_antenna = rsi_mac80211_get_antenna,
+        .rfkill_poll = rsi_mac80211_rfkill_poll,
+#ifdef CONFIG_PM 
+	.suspend = rsi_mac80211_suspend,
+	.resume  = rsi_mac80211_resume,
+#endif
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	.hw_scan          = rsi_mac80211_hw_scan_start,
+	.cancel_hw_scan   = rsi_mac80211_hw_scan_cancel, 
+#else
+	.sw_scan_start = rsi_mac80211_sw_scan_start,
+	.sw_scan_complete = rsi_mac80211_sw_scan_stop,
+#endif
+	.remain_on_channel = rsi_mac80211_roc,
+	.cancel_remain_on_channel = rsi_mac80211_cancel_roc,
 };
 
 /**
@@ -1062,43 +2614,111 @@ int rsi_mac80211_attach(struct rsi_common *common)
 	hw->priv = adapter;
 	adapter->hw = hw;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0))
+	ieee80211_hw_set(hw, SIGNAL_DBM);
+	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
+	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+	ieee80211_hw_set(hw, SUPPORTS_PS);
+	ieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);
+//	ieee80211_hw_set(hw, CONNECTION_MONITOR);
+	ieee80211_hw_set(hw, SPECTRUM_MGMT);
+	ieee80211_hw_set(hw, MFP_CAPABLE);
+#else
 	hw->flags = IEEE80211_HW_SIGNAL_DBM |
 		    IEEE80211_HW_HAS_RATE_CONTROL |
 		    IEEE80211_HW_AMPDU_AGGREGATION |
+		    IEEE80211_HW_SUPPORTS_PS |
+		    IEEE80211_HW_SUPPORTS_DYNAMIC_PS |
+	//	    IEEE80211_HW_CONNECTION_MONITOR |
+		    IEEE80211_HW_SPECTRUM_MGMT |
+		    IEEE80211_HW_MFP_CAPABLE |
 		    0;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_RRM);
+#endif
 
 	hw->queues = MAX_HW_QUEUES;
 	hw->extra_tx_headroom = RSI_NEEDED_HEADROOM;
 
 	hw->max_rates = 1;
 	hw->max_rate_tries = MAX_RETRIES;
-
-	hw->max_tx_aggregation_subframes = 6;
-	rsi_register_rates_channels(adapter, IEEE80211_BAND_2GHZ);
-	rsi_register_rates_channels(adapter, IEEE80211_BAND_5GHZ);
+	hw->uapsd_queues = IEEE80211_MARKALL_UAPSD_QUEUES;
+	hw->uapsd_max_sp_len = IEEE80211_STA_SP_ALL_PKTS;
+//	hw->max_tx_aggregation_subframes = 6;
+	hw->max_tx_aggregation_subframes = 4;
+
+	rsi_register_rates_channels(adapter, NL80211_BAND_2GHZ);
+	wiphy->bands[NL80211_BAND_2GHZ] =
+		&adapter->sbands[NL80211_BAND_2GHZ];
+	if (common->num_supp_bands > 1) {
+		rsi_register_rates_channels(adapter, NL80211_BAND_5GHZ);
+		wiphy->bands[NL80211_BAND_5GHZ] =
+			&adapter->sbands[NL80211_BAND_5GHZ];
+	}
 	hw->rate_control_algorithm = "AARF";
+	hw->sta_data_size = sizeof(struct rsi_sta);
+	hw->vif_data_size = sizeof(struct vif_priv);
+	hw->uapsd_max_sp_len = IEEE80211_WMM_IE_STA_QOSINFO_SP_2;
 
 	SET_IEEE80211_PERM_ADDR(hw, common->mac_addr);
 	ether_addr_copy(hw->wiphy->addr_mask, addr_mask);
 
-	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+				 BIT(NL80211_IFTYPE_AP) |
+				 BIT(NL80211_IFTYPE_P2P_DEVICE) |
+				 BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				 BIT(NL80211_IFTYPE_P2P_GO);
 	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
 	wiphy->retry_short = RETRY_SHORT;
 	wiphy->retry_long  = RETRY_LONG;
 	wiphy->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
 	wiphy->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
-	wiphy->flags = 0;
-
-	wiphy->available_antennas_rx = 1;
 	wiphy->available_antennas_tx = 1;
-	wiphy->bands[IEEE80211_BAND_2GHZ] =
-		&adapter->sbands[IEEE80211_BAND_2GHZ];
-	wiphy->bands[IEEE80211_BAND_5GHZ] =
-		&adapter->sbands[IEEE80211_BAND_5GHZ];
+	wiphy->available_antennas_rx = 1;
+
+	wiphy->max_ap_assoc_sta = rsi_max_ap_stas[common->oper_mode - 1];
+	common->max_stations = wiphy->max_ap_assoc_sta;
+	rsi_dbg(ERR_ZONE, "Max Stations Allowed = %d\n", common->max_stations);
+
+	wiphy->max_scan_ssids = 16;
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+	wiphy->max_scan_ie_len = 256;
+#endif	
+	/* AP Parameters */
+	wiphy->flags = WIPHY_FLAG_REPORTS_OBSS;
+	wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+
+	/*wiphy->regulatory_flags = (REGULATORY_STRICT_REG |
+				   REGULATORY_CUSTOM_REG);
+	wiphy_apply_custom_regulatory(wiphy,&rsi_regdom);*/
+	wiphy->reg_notifier = rsi_reg_notify;
+
+#ifdef CONFIG_RSI_WOW
+	wiphy->wowlan = &rsi_wowlan_support;
+#endif
+
+	wiphy->flags |= WIPHY_FLAG_NETNS_OK;
+
+#ifdef CONFIG_RSI_P2P
+	/* Wi-Fi direct related parameters */
+	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX;
+	wiphy->max_remain_on_channel_duration = 10000;
+	hw->max_listen_interval = 10;
+	wiphy->iface_combinations = rsi_iface_combinations;
+	wiphy->n_iface_combinations = ARRAY_SIZE(rsi_iface_combinations);
+	wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;
+//	wiphy->features |= (NL80211_FEATURE_P2P_GO_CTWIN |
+//			    NL80211_FEATURE_P2P_GO_OPPPS);
+#endif
 
 	status = ieee80211_register_hw(hw);
-	if (status)
+	if (status) {
+		rsi_dbg(ERR_ZONE, "Failed to register to mac80211\n");
 		return status;
+	}
 
 	return rsi_init_dbgfs(adapter);
 }
diff --git a/drivers/net/wireless/rsi/rsi_91x_main.c b/drivers/net/wireless/rsi/rsi_91x_main.c
index 8810862..cbc179d 100644
--- a/drivers/net/wireless/rsi/rsi_91x_main.c
+++ b/drivers/net/wireless/rsi/rsi_91x_main.c
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -20,15 +34,22 @@
 #include <linux/firmware.h>
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
-
-u32 rsi_zone_enabled = /* INFO_ZONE |
-			INIT_ZONE |
-			MGMT_TX_ZONE |
-			MGMT_RX_ZONE |
-			DATA_TX_ZONE |
-			DATA_RX_ZONE |
-			FSM_ZONE |
-			ISR_ZONE | */
+#include "rsi_hal.h"
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+#include "rsi_hci.h"
+#endif
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
+
+u32 rsi_zone_enabled =	//INFO_ZONE |
+			//INIT_ZONE |
+			//MGMT_TX_ZONE |
+			//MGMT_RX_ZONE |
+			//DATA_TX_ZONE |
+			//DATA_RX_ZONE |
+			//FSM_ZONE |
+			//ISR_ZONE |
 			ERR_ZONE |
 			0;
 EXPORT_SYMBOL_GPL(rsi_zone_enabled);
@@ -57,6 +78,72 @@ void rsi_dbg(u32 zone, const char *fmt, ...)
 EXPORT_SYMBOL_GPL(rsi_dbg);
 
 /**
+ * rsi_hex_dump() - This function prints the packet (/msg) in hex bytes.
+ * @zone: Zone of interest for output message.
+ * @msg_str: Message to be printed with packet
+ * @msg: Packet to be printed
+ * @len: Length of the packet
+ *
+ * Return: none
+ */
+void rsi_hex_dump(u32 zone, char *msg_str, const u8 *msg, u32 len)
+{
+	int ii;
+
+	if (!(zone & rsi_zone_enabled))
+		return;
+	printk("%s: (length = %d)\n", msg_str, len);
+	for (ii = 0; ii < len; ii++) {
+		if (ii && !(ii % 16))
+			printk("\n");
+		printk("%02x ", msg[ii]);
+	}
+	printk("\n");
+}
+EXPORT_SYMBOL_GPL(rsi_hex_dump);
+
+char *opmode_str(int oper_mode)
+{
+	switch (oper_mode) {
+	case DEV_OPMODE_WIFI_ALONE:
+	       return "Wi-Fi alone";
+	case DEV_OPMODE_BT_ALONE:
+	       return "BT EDR alone";
+	case DEV_OPMODE_BT_LE_ALONE:
+	       return "BT LE alone";
+	case DEV_OPMODE_STA_BT:
+	       return "Wi-Fi STA + BT EDR";
+	case DEV_OPMODE_STA_BT_LE:
+	       return "Wi-Fi STA + BT LE";
+	case DEV_OPMODE_STA_BT_DUAL:
+	       return "Wi-Fi STA + BT DUAL";
+	case DEV_OPMODE_AP_BT:
+	       return "Wi-Fi AP + BT EDR";
+	case DEV_OPMODE_AP_BT_DUAL:
+	       return "Wi-Fi AP + BT DUAL";
+	}
+	return "Unknown";
+}
+
+void rsi_print_version(struct rsi_common *common)
+{
+	memcpy(common->driver_ver, DRV_VER, ARRAY_SIZE(DRV_VER));
+	common->driver_ver[ARRAY_SIZE(DRV_VER)] = '\0';
+
+	rsi_dbg(ERR_ZONE, "================================================\n");
+	rsi_dbg(ERR_ZONE, "================ RSI Version Info ==============\n");
+	rsi_dbg(ERR_ZONE, "================================================\n");
+	rsi_dbg(ERR_ZONE, "FW Version\t: %d.%d.%d\n",
+		common->lmac_ver.major, common->lmac_ver.minor,
+		common->lmac_ver.release_num);
+	rsi_dbg(ERR_ZONE, "Driver Version\t: %s", common->driver_ver);
+	rsi_dbg(ERR_ZONE, "Operating mode\t: %d [%s]",
+		common->oper_mode, opmode_str(common->oper_mode));
+	rsi_dbg(ERR_ZONE, "Firmware file\t: %s", common->priv->fw_file_name);
+	rsi_dbg(ERR_ZONE, "================================================\n");
+}
+
+/**
  * rsi_prepare_skb() - This function prepares the skb.
  * @common: Pointer to the driver private structure.
  * @buffer: Pointer to the packet data.
@@ -86,7 +173,7 @@ static struct sk_buff *rsi_prepare_skb(struct rsi_common *common,
 
 	pkt_len -= extended_desc;
 	skb = dev_alloc_skb(pkt_len + FRAME_DESC_SZ);
-	if (skb == NULL)
+	if (!skb)
 		return NULL;
 
 	payload_offset = (extended_desc + FRAME_DESC_SZ);
@@ -96,6 +183,7 @@ static struct sk_buff *rsi_prepare_skb(struct rsi_common *common,
 	info = IEEE80211_SKB_CB(skb);
 	rx_params = (struct skb_info *)info->driver_data;
 	rx_params->rssi = rsi_get_rssi(buffer);
+
 	rx_params->channel = rsi_get_connected_channel(common->priv);
 
 	return skb;
@@ -108,30 +196,53 @@ static struct sk_buff *rsi_prepare_skb(struct rsi_common *common,
  *
  * Return: 0 on success, -1 on failure.
  */
-int rsi_read_pkt(struct rsi_common *common, s32 rcv_pkt_len)
+int rsi_read_pkt(struct rsi_common *common, u8 *rx_pkt, s32 rcv_pkt_len)
 {
 	u8 *frame_desc = NULL, extended_desc = 0;
-	u32 index, length = 0, queueno = 0;
+	u32 index = 0, length = 0, queueno = 0;
 	u16 actual_length = 0, offset;
 	struct sk_buff *skb = NULL;
 
-	index = 0;
 	do {
-		frame_desc = &common->rx_data_pkt[index];
+		frame_desc = &rx_pkt[index];
 		actual_length = *(u16 *)&frame_desc[0];
 		offset = *(u16 *)&frame_desc[2];
 
+		if ((actual_length < (4 + FRAME_DESC_SZ)) || (offset < 4)) {
+			rsi_dbg(ERR_ZONE,
+				"%s: actual_length (%d) is less than 20 or"
+				" offset(%d) is less than 4\n",
+				__func__, actual_length, offset);
+			break;
+		}
 		queueno = rsi_get_queueno(frame_desc, offset);
 		length = rsi_get_length(frame_desc, offset);
-		extended_desc = rsi_get_extended_desc(frame_desc, offset);
+		if (queueno == RSI_WIFI_DATA_Q || queueno == RSI_WIFI_MGMT_Q)
+			extended_desc = rsi_get_extended_desc(frame_desc,
+							      offset);
 
 		switch (queueno) {
+		case RSI_COEX_Q:
+			rsi_hex_dump(MGMT_RX_ZONE,
+				     "RX Command co ex packet",
+				     frame_desc + offset,
+				     FRAME_DESC_SZ + length);
+#ifdef CONFIG_RSI_COEX
+			rsi_coex_recv_pkt(common, (frame_desc + offset));
+#else
+			rsi_mgmt_pkt_recv(common, (frame_desc + offset));
+#endif
+			break;
 		case RSI_WIFI_DATA_Q:
+			rsi_hex_dump(DATA_RX_ZONE,
+				     "RX Data pkt",
+				     frame_desc + offset,
+				     FRAME_DESC_SZ + length);
 			skb = rsi_prepare_skb(common,
 					      (frame_desc + offset),
 					      length,
 					      extended_desc);
-			if (skb == NULL)
+			if (!skb)
 				goto fail;
 
 			rsi_indicate_pkt_to_os(common, skb);
@@ -140,6 +251,16 @@ int rsi_read_pkt(struct rsi_common *common, s32 rcv_pkt_len)
 		case RSI_WIFI_MGMT_Q:
 			rsi_mgmt_pkt_recv(common, (frame_desc + offset));
 			break;
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+		case RSI_BT_MGMT_Q:
+		case RSI_BT_DATA_Q:
+			rsi_hex_dump(DATA_RX_ZONE,
+				     "RX BT Pkt",
+				     frame_desc + offset,
+				     FRAME_DESC_SZ + length);
+			rsi_hci_recv_pkt(common, frame_desc + offset);
+			break;
+#endif
 
 		default:
 			rsi_dbg(ERR_ZONE, "%s: pkt from invalid queue: %d\n",
@@ -181,6 +302,36 @@ static void rsi_tx_scheduler_thread(struct rsi_common *common)
 	complete_and_exit(&common->tx_thread.completion, 0);
 }
 
+#ifdef CONFIG_SDIO_INTR_POLL
+void rsi_sdio_intr_poll_scheduler_thread(struct rsi_common *common)
+{
+        struct rsi_hw *adapter = common->priv;
+        int status = 0;
+
+        do {
+                status = adapter->check_intr_status_reg(adapter);
+                if (adapter->isr_pending)
+                        adapter->isr_pending = 0;
+                msleep(20);
+
+        } while (atomic_read(&common->sdio_intr_poll_thread.thread_done) == 0);
+        complete_and_exit(&common->sdio_intr_poll_thread.completion, 0);
+}
+
+void init_sdio_intr_status_poll_thread(struct rsi_common *common)
+{
+	rsi_init_event(&common->sdio_intr_poll_thread.event);
+	if (rsi_create_kthread(common,
+			       &common->sdio_intr_poll_thread,
+			       rsi_sdio_intr_poll_scheduler_thread,
+			       "Sdio Intr poll-Thread")) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to init sdio intr poll thrd\n",
+				__func__);
+	}
+}
+EXPORT_SYMBOL_GPL(init_sdio_intr_status_poll_thread);
+#endif
+
 /**
  * rsi_91x_init() - This function initializes os interface operations.
  * @void: Void.
@@ -198,23 +349,32 @@ struct rsi_hw *rsi_91x_init(void)
 		return NULL;
 
 	adapter->priv = kzalloc(sizeof(*common), GFP_KERNEL);
-	if (adapter->priv == NULL) {
-		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of memory\n",
+	if (!adapter->priv) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of priv\n",
 			__func__);
 		kfree(adapter);
 		return NULL;
-	} else {
-		common = adapter->priv;
-		common->priv = adapter;
 	}
+	common = adapter->priv;
+	common->priv = adapter;
 
 	for (ii = 0; ii < NUM_SOFT_QUEUES; ii++)
 		skb_queue_head_init(&common->tx_queue[ii]);
 
 	rsi_init_event(&common->tx_thread.event);
+	rsi_init_event(&common->bcn_thread.event);
+	rsi_init_event(&common->chan_set_event);
+	rsi_init_event(&common->probe_cfm_event);
+	rsi_init_event(&common->chan_change_event);
+	rsi_init_event(&common->cancel_hw_scan_event);
 	mutex_init(&common->mutex);
-	mutex_init(&common->tx_rxlock);
+	mutex_init(&common->tx_lock);
+	mutex_init(&common->rx_lock);
+	sema_init(&common->tx_bus_lock, 1);
 
+	common->scan_workqueue = 
+		create_singlethread_workqueue("rsi_scan_worker");
+	INIT_WORK(&common->scan_work, rsi_scan_start);
 	if (rsi_create_kthread(common,
 			       &common->tx_thread,
 			       rsi_tx_scheduler_thread,
@@ -223,6 +383,37 @@ struct rsi_hw *rsi_91x_init(void)
 		goto err;
 	}
 
+#if 0
+#ifdef CONFIG_CARACALLA_BOARD
+	if (rsi_create_kthread(common,
+			       &common->bcn_thread,
+			       rsi_bcn_scheduler_thread,
+			       "Beacon-Thread")) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to init bcn thrd\n", __func__);
+		goto err;
+	}
+#endif
+#endif
+
+#ifdef CONFIG_RSI_COEX
+	if (rsi_coex_init(common)) {
+		rsi_dbg(ERR_ZONE, "Failed to init COEX module\n");
+		goto err;
+	}
+#endif
+	/* Power save related */
+	rsi_default_ps_params(adapter);
+	spin_lock_init(&adapter->ps_lock);
+	common->uapsd_bitmap = 0;
+
+	/* BGScan related */
+	init_bgscan_params(common);
+
+	/* Wi-Fi direct related */
+	common->roc_timer.data = (unsigned long)common;
+	common->roc_timer.function = (void *)&rsi_roc_timeout;
+	init_timer(&common->roc_timer);
+
 	common->init_done = true;
 	return adapter;
 
@@ -244,13 +435,21 @@ void rsi_91x_deinit(struct rsi_hw *adapter)
 	struct rsi_common *common = adapter->priv;
 	u8 ii;
 
-	rsi_dbg(INFO_ZONE, "%s: Performing deinit os ops\n", __func__);
+	rsi_dbg(INFO_ZONE, "%s: Deinit core module...\n", __func__);
 
+	flush_workqueue(common->scan_workqueue);
+	destroy_workqueue(common->scan_workqueue);
 	rsi_kill_thread(&common->tx_thread);
+//#ifdef CONFIG_CARACALLA_BOARD
+//	rsi_kill_thread(&common->bcn_thread);
+//#endif
 
 	for (ii = 0; ii < NUM_SOFT_QUEUES; ii++)
 		skb_queue_purge(&common->tx_queue[ii]);
 
+#ifdef CONFIG_RSI_COEX
+	rsi_coex_deinit(common);
+#endif
 	common->init_done = false;
 
 	kfree(common);
@@ -291,5 +490,5 @@ module_exit(rsi_91x_hal_module_exit);
 MODULE_AUTHOR("Redpine Signals Inc");
 MODULE_DESCRIPTION("Station driver for RSI 91x devices");
 MODULE_SUPPORTED_DEVICE("RSI-91x");
-MODULE_VERSION("0.1");
+MODULE_VERSION(DRV_VER);
 MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/wireless/rsi/rsi_91x_mgmt.c b/drivers/net/wireless/rsi/rsi_91x_mgmt.c
index 8d110fd..3f9aae6 100644
--- a/drivers/net/wireless/rsi/rsi_91x_mgmt.c
+++ b/drivers/net/wireless/rsi/rsi_91x_mgmt.c
@@ -1,23 +1,52 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/etherdevice.h>
 #include "rsi_mgmt.h"
 #include "rsi_common.h"
+#include "rsi_ps.h"
+#include "rsi_hal.h"
+#ifdef CONFIG_RSI_COEX
+#include "rsi_coex.h"
+#endif
+
+struct rsi_config_vals dev_config_vals[] = {
+	{
+		.lp_ps_handshake = 0,
+		.ulp_ps_handshake = 0,
+		.sleep_config_params = 0,
+		.ext_pa_or_bt_coex_en = 0,
+	},
+};
 
+/* Bootup Parameters for 20MHz */
 static struct bootup_params boot_params_20 = {
 	.magic_number = cpu_to_le16(0x5aa5),
 	.crystal_good_time = 0x0,
@@ -28,14 +57,15 @@ static struct bootup_params boot_params_20 = {
 	.rtls_timestamp_en = 0x0,
 	.host_spi_intr_cfg = 0x0,
 	.device_clk_info = {{
+		/* WLAN params */
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|
-					      (TA_PLL_M_VAL_20)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_20 << 8) |
+							 (TAPLL_M_VAL_20)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_20),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|
+				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8) |
 							 (PLL960_N_VAL_20)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),
 				.pll_reg_3 = 0x0,
@@ -45,21 +75,27 @@ static struct bootup_params boot_params_20 = {
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = cpu_to_le16(BIT(3)),
-			.bbp_lmac_clk_reg_val = cpu_to_le16(0x121),
-			.umac_clock_reg_config = 0x0,
-			.qspi_uart_clock_reg_config = 0x0
+			.switch_umac_clk = 0x1,
+			.switch_qspi_clk = 0x1,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x1,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
+			.bbp_lmac_clk_reg_val = cpu_to_le16(0x111),
+			.umac_clock_reg_config = cpu_to_le16(0x48),
+			.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)
 		}
 	},
+	/* Bluetooth params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|
-							 (TA_PLL_M_VAL_20)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_20 << 8) |
+							 (TAPLL_M_VAL_20)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_20),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|
+				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8) |
 							 (PLL960_N_VAL_20)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),
 				.pll_reg_3 = 0x0,
@@ -69,21 +105,27 @@ static struct bootup_params boot_params_20 = {
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
 	},
+	/* Zigbee params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_20 << 8)|
-							 (TA_PLL_M_VAL_20)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_20),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_20 << 8) |
+							 (TAPLL_M_VAL_20)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_20),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8)|
+				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_20 << 8) |
 							 (PLL960_N_VAL_20)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_20),
 				.pll_reg_3 = 0x0,
@@ -93,12 +135,18 @@ static struct bootup_params boot_params_20 = {
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
 	} },
+	/* ULP Params */
 	.buckboost_wakeup_cnt = 0x0,
 	.pmu_wakeup_wait = 0x0,
 	.shutdown_wait_time = 0x0,
@@ -106,9 +154,13 @@ static struct bootup_params boot_params_20 = {
 	.wdt_prog_value = 0x0,
 	.wdt_soc_rst_delay = 0x0,
 	.dcdc_operation_mode = 0x0,
-	.soc_reset_wait_cnt = 0x0
+	.soc_reset_wait_cnt = 0x0,
+	.waiting_time_at_fresh_sleep = 0x0,
+	.max_threshold_to_avoid_sleep = 0x0,
+	.beacon_resedue_alg_en = 0,
 };
 
+/* Bootup parameters for 40MHz */
 static struct bootup_params boot_params_40 = {
 	.magic_number = cpu_to_le16(0x5aa5),
 	.crystal_good_time = 0x0,
@@ -119,14 +171,15 @@ static struct bootup_params boot_params_40 = {
 	.rtls_timestamp_en = 0x0,
 	.host_spi_intr_cfg = 0x0,
 	.device_clk_info = {{
+		/* WLAN params */
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|
-							 (TA_PLL_M_VAL_40)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_40 << 8) |
+							 (TAPLL_M_VAL_40)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_40),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|
+				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8) |
 							 (PLL960_N_VAL_40)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),
 				.pll_reg_3 = 0x0,
@@ -136,21 +189,27 @@ static struct bootup_params boot_params_40 = {
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = cpu_to_le16(0x09),
+			.switch_umac_clk = 0x1,
+			.switch_qspi_clk = 0x1,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x1,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = cpu_to_le16(0x1121),
 			.umac_clock_reg_config = cpu_to_le16(0x48),
-			.qspi_uart_clock_reg_config = 0x0
+			.qspi_uart_clock_reg_config = cpu_to_le16(0x1211)
 		}
 	},
+	/* Bluetooth Params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|
-							 (TA_PLL_M_VAL_40)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_40 << 8) |
+							 (TAPLL_M_VAL_40)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_40),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|
+				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8) |
 							 (PLL960_N_VAL_40)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),
 				.pll_reg_3 = 0x0,
@@ -160,21 +219,27 @@ static struct bootup_params boot_params_40 = {
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
 	},
+	/* Zigbee Params */
 	{
 		.pll_config_g = {
 			.tapll_info_g = {
-				.pll_reg_1 = cpu_to_le16((TA_PLL_N_VAL_40 << 8)|
-							 (TA_PLL_M_VAL_40)),
-				.pll_reg_2 = cpu_to_le16(TA_PLL_P_VAL_40),
+				.pll_reg_1 = cpu_to_le16((TAPLL_N_VAL_40 << 8) |
+							 (TAPLL_M_VAL_40)),
+				.pll_reg_2 = cpu_to_le16(TAPLL_P_VAL_40),
 			},
 			.pll960_info_g = {
-				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8)|
+				.pll_reg_1 = cpu_to_le16((PLL960_P_VAL_40 << 8) |
 							 (PLL960_N_VAL_40)),
 				.pll_reg_2 = cpu_to_le16(PLL960_M_VAL_40),
 				.pll_reg_3 = 0x0,
@@ -184,12 +249,18 @@ static struct bootup_params boot_params_40 = {
 			}
 		},
 		.switch_clk_g = {
-			.switch_clk_info = 0x0,
+			.switch_umac_clk = 0x0,
+			.switch_qspi_clk = 0x0,
+			.switch_slp_clk_2_32 = 0x0,
+			.switch_bbp_lmac_clk_reg = 0x0,
+			.switch_mem_ctrl_cfg = 0x0,
+			.reserved = 0x0,
 			.bbp_lmac_clk_reg_val = 0x0,
 			.umac_clock_reg_config = 0x0,
 			.qspi_uart_clock_reg_config = 0x0
 		}
 	} },
+	/* ULP Params */
 	.buckboost_wakeup_cnt = 0x0,
 	.pmu_wakeup_wait = 0x0,
 	.shutdown_wait_time = 0x0,
@@ -197,7 +268,44 @@ static struct bootup_params boot_params_40 = {
 	.wdt_prog_value = 0x0,
 	.wdt_soc_rst_delay = 0x0,
 	.dcdc_operation_mode = 0x0,
-	.soc_reset_wait_cnt = 0x0
+	.soc_reset_wait_cnt = 0x0,
+	.waiting_time_at_fresh_sleep = 0x0,
+	.max_threshold_to_avoid_sleep = 0x0,
+	.beacon_resedue_alg_en = 0,
+};
+
+#define UNUSED_GPIO	1
+#define USED_GPIO	0
+struct rsi_ulp_gpio_vals unused_ulp_gpio_bitmap = {
+	.motion_sensor_gpio_ulp_wakeup = UNUSED_GPIO,
+	.sleep_ind_from_device = UNUSED_GPIO,
+	.ulp_gpio_2 = UNUSED_GPIO,
+	.push_button_ulp_wakeup = UNUSED_GPIO,
+};
+
+struct rsi_soc_gpio_vals unused_soc_gpio_bitmap = {
+	.pspi_csn_0		= USED_GPIO,	//GPIO_0
+	.pspi_csn_1		= USED_GPIO,	//GPIO_1
+	.host_wakeup_intr	= UNUSED_GPIO,	//GPIO_2
+	.pspi_data_0		= USED_GPIO,	//GPIO_3
+	.pspi_data_1		= USED_GPIO,	//GPIO_4
+	.pspi_data_2		= USED_GPIO,	//GPIO_5
+	.pspi_data_3		= USED_GPIO,	//GPIO_6
+	.i2c_scl		= USED_GPIO,	//GPIO_7
+	.i2c_sda		= USED_GPIO,	//GPIO_8
+	.uart1_rx		= UNUSED_GPIO,	//GPIO_9
+	.uart1_tx		= UNUSED_GPIO,	//GPIO_10
+	.uart1_rts_i2s_clk	= UNUSED_GPIO,	//GPIO_11
+	.uart1_cts_i2s_ws	= UNUSED_GPIO,	//GPIO_12
+	.dbg_uart_rx_i2s_din	= UNUSED_GPIO,	//GPIO_13
+	.dbg_uart_tx_i2s_dout	= UNUSED_GPIO,	//GPIO_14
+	.lp_wakeup_boot_bypass	= UNUSED_GPIO,	//GPIO_15
+	.led_0			= USED_GPIO,	//GPIO_16
+	.btcoex_wlan_active_ext_pa_ant_sel_A = UNUSED_GPIO, //GPIO_17
+	.btcoex_bt_priority_ext_pa_ant_sel_B = UNUSED_GPIO, //GPIO_18
+	.btcoex_bt_active_ext_pa_on_off = UNUSED_GPIO, //GPIO_19
+	.rf_reset		= USED_GPIO, //GPIO_20
+	.sleep_ind_from_device	= UNUSED_GPIO,
 };
 
 static u16 mcs[] = {13, 26, 39, 52, 78, 104, 117, 130};
@@ -210,7 +318,7 @@ static u16 mcs[] = {13, 26, 39, 52, 78, 104, 117, 130};
  */
 static void rsi_set_default_parameters(struct rsi_common *common)
 {
-	common->band = IEEE80211_BAND_2GHZ;
+	common->band = NL80211_BAND_2GHZ;
 	common->channel_width = BW_20MHZ;
 	common->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
 	common->channel = 1;
@@ -218,6 +326,61 @@ static void rsi_set_default_parameters(struct rsi_common *common)
 	common->fsm_state = FSM_CARD_NOT_READY;
 	common->iface_down = true;
 	common->endpoint = EP_2GHZ_20MHZ;
+	common->driver_mode = 1; /* End-to-End Mode */
+
+	common->ta_aggr = 0;
+	common->skip_fw_load = 0; /* Default disable skipping fw loading */
+	common->lp_ps_handshake_mode = 0; /* Default No HandShake mode*/
+	common->ulp_ps_handshake_mode = 2; /* Default PKT HandShake mode*/
+	common->rf_power_val = 0; /* Default 1.9V */
+	common->device_gpio_type = TA_GPIO; /* Default TA GPIO */
+	common->country_code = 840; /* Default US */
+	common->wlan_rf_power_mode = 0;
+	common->bt_rf_power_mode = 0;
+	common->obm_ant_sel_val = 2;
+	common->antenna_diversity = 0;
+	common->tx_power = RSI_TXPOWER_MAX;
+	common->dtim_cnt = 2;
+	common->beacon_interval = 100;
+	common->antenna_gain[0] = 0;
+	common->antenna_gain[1] = 0;
+}
+
+void init_bgscan_params(struct rsi_common *common)
+{
+	common->bgscan_info.bgscan_threshold = 0;
+	common->bgscan_info.roam_threshold = 10;
+	common->bgscan_info.bgscan_periodicity = 30;
+	common->bgscan_info.num_bg_channels = 0;
+	common->bgscan_info.two_probe = 1;
+	common->bgscan_info.active_scan_duration = 20;
+	common->bgscan_info.passive_scan_duration = 70;
+	common->bgscan_info.channels2scan[0] = 1;
+	common->bgscan_info.channels2scan[1] = 2;
+	common->bgscan_info.channels2scan[2] = 3;
+	common->bgscan_info.channels2scan[3] = 4;
+	common->bgscan_info.channels2scan[4] = 5;
+	common->bgscan_info.channels2scan[5] = 6;
+	common->bgscan_info.channels2scan[6] = 7;
+	common->bgscan_info.channels2scan[7] = 8;
+	common->bgscan_info.channels2scan[8] = 9;
+	common->bgscan_info.channels2scan[9] = 10;
+	common->bgscan_info.channels2scan[10] = 11;
+//	common->bgscan_info.channels2scan[11] = 12;
+//	common->bgscan_info.channels2scan[12] = 13;
+//	common->bgscan_info.channels2scan[13] = 14;
+#if 0
+	common->bgscan_info.channels2scan[11] = 36;
+	common->bgscan_info.channels2scan[12] = 40;
+	common->bgscan_info.channels2scan[13] = 44;
+	common->bgscan_info.channels2scan[14] = 48;
+	common->bgscan_info.channels2scan[15] = 52;
+	common->bgscan_info.channels2scan[16] = 56;
+	common->bgscan_info.channels2scan[17] = 60;
+	common->bgscan_info.channels2scan[18] = 64;
+	common->bgscan_info.channels2scan[19] = 100;
+	common->bgscan_info.channels2scan[20] = 104;
+#endif
 }
 
 /**
@@ -255,12 +418,14 @@ static int rsi_send_internal_mgmt_frame(struct rsi_common *common,
 {
 	struct skb_info *tx_params;
 
-	if (skb == NULL) {
-		rsi_dbg(ERR_ZONE, "%s: Unable to allocate skb\n", __func__);
-		return -ENOMEM;
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: SKB is NULL\n", __func__);
+		return -EINVAL;
 	}
+	skb->data[1] |= BIT(7);
 	tx_params = (struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;
 	tx_params->flags |= INTERNAL_MGMT_PKT;
+	skb->priority = MGMT_SOFT_Q;
 	skb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);
 	rsi_set_event(&common->tx_thread.event);
 	return 0;
@@ -278,7 +443,7 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 	struct rsi_radio_caps *radio_caps;
 	struct rsi_hw *adapter = common->priv;
 	u16 inx = 0;
-	u8 ii;
+	int ii;
 	u8 radio_id = 0;
 	u16 gc[20] = {0xf0, 0xf0, 0xf0, 0xf0,
 		      0xf0, 0xf0, 0xf0, 0xf0,
@@ -290,26 +455,24 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 	rsi_dbg(INFO_ZONE, "%s: Sending rate symbol req frame\n", __func__);
 
 	skb = dev_alloc_skb(sizeof(struct rsi_radio_caps));
-
-	if (!skb) {
-		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
-			__func__);
+	if (!skb)
 		return -ENOMEM;
-	}
 
 	memset(skb->data, 0, sizeof(struct rsi_radio_caps));
 	radio_caps = (struct rsi_radio_caps *)skb->data;
 
 	radio_caps->desc_word[1] = cpu_to_le16(RADIO_CAPABILITIES);
-	radio_caps->desc_word[4] = cpu_to_le16(RSI_RF_TYPE << 8);
+	radio_caps->desc_word[4] = cpu_to_le16(common->channel);
+	radio_caps->desc_word[4] |= cpu_to_le16(RSI_RF_TYPE << 8);
 
+	radio_caps->desc_word[7] |= cpu_to_le16(RSI_LMAC_CLOCK_80MHZ);
 	if (common->channel_width == BW_40MHZ) {
-		radio_caps->desc_word[7] |= cpu_to_le16(RSI_LMAC_CLOCK_80MHZ);
 		radio_caps->desc_word[7] |= cpu_to_le16(RSI_ENABLE_40MHZ);
 
 		if (common->fsm_state == FSM_MAC_INIT_DONE) {
 			struct ieee80211_hw *hw = adapter->hw;
 			struct ieee80211_conf *conf = &hw->conf;
+
 			if (conf_is_ht40_plus(conf)) {
 				radio_caps->desc_word[5] =
 					cpu_to_le16(LOWER_20_ENABLE);
@@ -345,7 +508,7 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 		radio_caps->qos_params[ii].txop_q = 0;
 	}
 
-	for (ii = 0; ii < MAX_HW_QUEUES - 4; ii++) {
+	for (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {
 		radio_caps->qos_params[ii].cont_win_min_q =
 			cpu_to_le16(common->edca_params[ii].cw_min);
 		radio_caps->qos_params[ii].cont_win_max_q =
@@ -356,6 +519,10 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 			cpu_to_le16(common->edca_params[ii].txop);
 	}
 
+	radio_caps->qos_params[BROADCAST_HW_Q].txop_q = 0xffff;
+	radio_caps->qos_params[MGMT_HW_Q].txop_q = 0;
+	radio_caps->qos_params[BEACON_HW_Q].txop_q = 0xffff;
+
 	memcpy(&common->rate_pwr[0], &gc[0], 40);
 	for (ii = 0; ii < 20; ii++)
 		radio_caps->gcpd_per_rate[inx++] =
@@ -363,8 +530,7 @@ static int rsi_load_radio_caps(struct rsi_common *common)
 
 	radio_caps->desc_word[0] = cpu_to_le16((sizeof(struct rsi_radio_caps) -
 						FRAME_DESC_SZ) |
-					       (RSI_WIFI_MGMT_Q << 12));
-
+						(RSI_WIFI_MGMT_Q << 12));
 
 	skb_put(skb, (sizeof(struct rsi_radio_caps)));
 
@@ -375,15 +541,14 @@ static int rsi_load_radio_caps(struct rsi_common *common)
  * rsi_mgmt_pkt_to_core() - This function is the entry point for Mgmt module.
  * @common: Pointer to the driver private structure.
  * @msg: Pointer to received packet.
- * @msg_len: Length of the recieved packet.
- * @type: Type of recieved packet.
+ * @msg_len: Length of the received packet.
+ * @type: Type of received packet.
  *
  * Return: 0 on success, -1 on failure.
  */
 static int rsi_mgmt_pkt_to_core(struct rsi_common *common,
 				u8 *msg,
-				s32 msg_len,
-				u8 type)
+				s32 msg_len)
 {
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_tx_info *info;
@@ -392,48 +557,51 @@ static int rsi_mgmt_pkt_to_core(struct rsi_common *common,
 	u8 pkt_recv;
 	struct sk_buff *skb;
 	char *buffer;
+	struct ieee80211_hdr *wlh;
 
-	if (type == RX_DOT11_MGMT) {
-		if (!adapter->sc_nvifs)
-			return -ENOLINK;
+	if (!adapter->sc_nvifs)
+		return -ENOLINK;
 
-		msg_len -= pad_bytes;
-		if ((msg_len <= 0) || (!msg)) {
-			rsi_dbg(MGMT_RX_ZONE,
-				"%s: Invalid rx msg of len = %d\n",
-				__func__, msg_len);
-			return -EINVAL;
-		}
+	if (common->iface_down)
+		return -ENODEV;
 
-		skb = dev_alloc_skb(msg_len);
-		if (!skb) {
-			rsi_dbg(ERR_ZONE, "%s: Failed to allocate skb\n",
-				__func__);
-			return -ENOMEM;
-		}
+	msg_len -= pad_bytes;
+	if ((msg_len <= 0) || (!msg)) {
+		rsi_dbg(MGMT_RX_ZONE,
+			"%s: Invalid rx msg of len = %d\n",
+			__func__, msg_len);
+		return -EINVAL;
+	}
 
-		buffer = skb_put(skb, msg_len);
+	skb = dev_alloc_skb(msg_len);
+	if (!skb)
+		return -ENOMEM;
 
-		memcpy(buffer,
-		       (u8 *)(msg +  FRAME_DESC_SZ + pad_bytes),
-		       msg_len);
+	buffer = skb_put(skb, msg_len);
 
-		pkt_recv = buffer[0];
+	memcpy(buffer,
+		(u8 *)(msg +  FRAME_DESC_SZ + pad_bytes),
+		msg_len);
 
-		info = IEEE80211_SKB_CB(skb);
-		rx_params = (struct skb_info *)info->driver_data;
-		rx_params->rssi = rsi_get_rssi(msg);
-		rx_params->channel = rsi_get_channel(msg);
-		rsi_indicate_pkt_to_os(common, skb);
-	} else {
-		rsi_dbg(MGMT_TX_ZONE, "%s: Internal Packet\n", __func__);
-	}
+	pkt_recv = buffer[0];
+
+	info = IEEE80211_SKB_CB(skb);
+	rx_params = (struct skb_info *)info->driver_data;
+	rx_params->rssi = rsi_get_rssi(msg);
+	rx_params->channel = rsi_get_channel(msg);
+	rsi_dbg(MGMT_RX_ZONE,
+		"%s: rssi=%d channel=%d\n",
+		__func__, rx_params->rssi, rx_params->channel);
+	wlh = (struct ieee80211_hdr *)skb->data;
+	rsi_dbg(INFO_ZONE, "RX Dot11 Mgmt Pkt Type: %s\n",
+		dot11_pkt_type(wlh->frame_control));
+	rsi_indicate_pkt_to_os(common, skb);
 
 	return 0;
 }
 
 /**
- * rsi_hal_send_sta_notify_frame() - This function sends the station notify
+ * rsi_send_sta_notify_frame() - This function sends the station notify
  *				     frame to firmware.
  * @common: Pointer to the driver private structure.
  * @opmode: Operating mode of device.
@@ -444,32 +612,38 @@ static int rsi_mgmt_pkt_to_core(struct rsi_common *common,
  *
  * Return: status: 0 on success, corresponding negative error code on failure.
  */
-static int rsi_hal_send_sta_notify_frame(struct rsi_common *common,
-					 u8 opmode,
-					 u8 notify_event,
-					 const unsigned char *bssid,
-					 u8 qos_enable,
-					 u16 aid)
+int rsi_send_sta_notify_frame(struct rsi_common *common,
+			      enum opmode opmode,
+			      u8 notify_event,
+			      const unsigned char *bssid,
+			      u8 qos_enable,
+			      u16 aid,
+			      u16 sta_id)
 {
+	struct rsi_hw *adapter = common->priv;
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
 	struct sk_buff *skb = NULL;
 	struct rsi_peer_notify *peer_notify;
-	u16 vap_id = 0;
 	int status;
+	u16 vap_id = 0;
+	int frame_len = sizeof(*peer_notify);
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending sta notify frame\n", __func__);
-
-	skb = dev_alloc_skb(sizeof(struct rsi_peer_notify));
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending station notify frame\n", __func__);
 
+	skb = dev_alloc_skb(frame_len);
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
 			__func__);
 		return -ENOMEM;
 	}
+	memset(skb->data, 0, frame_len);
 
-	memset(skb->data, 0, sizeof(struct rsi_peer_notify));
 	peer_notify = (struct rsi_peer_notify *)skb->data;
 
-	peer_notify->command = cpu_to_le16(opmode << 1);
+	if (opmode == STA_OPMODE)
+		peer_notify->command = cpu_to_le16(PEER_TYPE_AP << 1);
+	else if (opmode == AP_OPMODE)
+		peer_notify->command = cpu_to_le16(PEER_TYPE_STA << 1);
 
 	switch (notify_event) {
 	case STA_CONNECTED:
@@ -481,31 +655,30 @@ static int rsi_hal_send_sta_notify_frame(struct rsi_common *common,
 	default:
 		break;
 	}
-
 	peer_notify->command |= cpu_to_le16((aid & 0xfff) << 4);
 	ether_addr_copy(peer_notify->mac_addr, bssid);
-
+	peer_notify->mpdu_density = cpu_to_le16(0x08); //FIXME check this
 	peer_notify->sta_flags = cpu_to_le32((qos_enable) ? 1 : 0);
-
-	peer_notify->desc_word[0] =
-		cpu_to_le16((sizeof(struct rsi_peer_notify) - FRAME_DESC_SZ) |
-			    (RSI_WIFI_MGMT_Q << 12));
+	peer_notify->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+						(RSI_WIFI_MGMT_Q << 12));
 	peer_notify->desc_word[1] = cpu_to_le16(PEER_NOTIFY);
-	peer_notify->desc_word[7] |= cpu_to_le16(vap_id << 8);
-
-	skb_put(skb, sizeof(struct rsi_peer_notify));
+	peer_notify->desc_word[7] |= cpu_to_le16(sta_id | vap_id << 8);
 
+	skb_put(skb, frame_len);
 	status = rsi_send_internal_mgmt_frame(common, skb);
 
-	if (!status && qos_enable) {
+	if ((vif->type == NL80211_IFTYPE_STATION) &&
+	    (!status) && qos_enable) {
 		rsi_set_contention_vals(common);
+		mdelay(1);
 		status = rsi_load_radio_caps(common);
 	}
+
 	return status;
 }
 
 /**
- * rsi_send_aggregation_params_frame() - This function sends the ampdu
+ * rsi_send_aggr_params_frame() - This function sends the ampdu
  *					 indication frame to firmware.
  * @common: Pointer to the driver private structure.
  * @tid: traffic identifier.
@@ -515,18 +688,19 @@ static int rsi_hal_send_sta_notify_frame(struct rsi_common *common,
  *
  * Return: 0 on success, corresponding negative error code on failure.
  */
-int rsi_send_aggregation_params_frame(struct rsi_common *common,
-				      u16 tid,
-				      u16 ssn,
-				      u8 buf_size,
-				      u8 event)
+int rsi_send_aggr_params_frame(struct rsi_common *common,
+			       u16 tid,
+			       u16 ssn,
+			       u8 buf_size,
+			       u8 event,
+			       u8 sta_id)
 {
 	struct sk_buff *skb = NULL;
 	struct rsi_mac_frame *mgmt_frame;
 	u8 peer_id = 0;
+//	u8 window_size = 1;
 
 	skb = dev_alloc_skb(FRAME_DESC_SZ);
-
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
 			__func__);
@@ -536,7 +710,9 @@ int rsi_send_aggregation_params_frame(struct rsi_common *common,
 	memset(skb->data, 0, FRAME_DESC_SZ);
 	mgmt_frame = (struct rsi_mac_frame *)skb->data;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending AMPDU indication frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending AMPDU indication frame\n",
+		__func__);
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(AMPDU_IND);
@@ -544,8 +720,11 @@ int rsi_send_aggregation_params_frame(struct rsi_common *common,
 	if (event == STA_TX_ADDBA_DONE) {
 		mgmt_frame->desc_word[4] = cpu_to_le16(ssn);
 		mgmt_frame->desc_word[5] = cpu_to_le16(buf_size);
+		//mgmt_frame->desc_word[5] = cpu_to_le16(window_size);
 		mgmt_frame->desc_word[7] =
-		cpu_to_le16((tid | (START_AMPDU_AGGR << 4) | (peer_id << 8)));
+			cpu_to_le16((tid |
+				    (START_AMPDU_AGGR << 4) |
+				    (peer_id << 8)));
 	} else if (event == STA_RX_ADDBA_DONE) {
 		mgmt_frame->desc_word[4] = cpu_to_le16(ssn);
 		mgmt_frame->desc_word[7] = cpu_to_le16(tid |
@@ -575,12 +754,12 @@ int rsi_send_aggregation_params_frame(struct rsi_common *common,
  *
  * Return: 0 on success, corresponding negative error code on failure.
  */
-static int rsi_program_bb_rf(struct rsi_common *common)
+int rsi_program_bb_rf(struct rsi_common *common)
 {
 	struct sk_buff *skb;
 	struct rsi_mac_frame *mgmt_frame;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending program BB/RF frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending BB/RF program frame\n", __func__);
 
 	skb = dev_alloc_skb(FRAME_DESC_SZ);
 	if (!skb) {
@@ -595,6 +774,7 @@ static int rsi_program_bb_rf(struct rsi_common *common)
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(BBP_PROG_IN_TA);
 	mgmt_frame->desc_word[4] = cpu_to_le16(common->endpoint);
+	mgmt_frame->desc_word[3] = cpu_to_le16(common->rf_pwr_mode);
 
 	if (common->rf_reset) {
 		mgmt_frame->desc_word[7] =  cpu_to_le16(RF_RESET_ENABLE);
@@ -605,6 +785,7 @@ static int rsi_program_bb_rf(struct rsi_common *common)
 	common->bb_rf_prog_count = 1;
 	mgmt_frame->desc_word[7] |= cpu_to_le16(PUT_BBP_RESET |
 				     BBP_REG_WRITE | (RSI_RF_TYPE << 4));
+
 	skb_put(skb, FRAME_DESC_SZ);
 
 	return rsi_send_internal_mgmt_frame(common, skb);
@@ -617,17 +798,24 @@ static int rsi_program_bb_rf(struct rsi_common *common)
  *
  * Return: 0 on success, corresponding negative error code on failure.
  */
-int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode)
+int rsi_set_vap_capabilities(struct rsi_common *common,
+			     enum opmode mode,
+			     u8 *mac_addr,
+			     u8 vap_id,
+			     u8 vap_status)
 {
 	struct sk_buff *skb = NULL;
 	struct rsi_vap_caps *vap_caps;
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_hw *hw = adapter->hw;
 	struct ieee80211_conf *conf = &hw->conf;
-	u16 vap_id = 0;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending VAP capabilities frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending VAP capabilities frame\n", __func__);
 
+	rsi_dbg(INFO_ZONE, "Config VAP: id=%d mode=%d status=%d ",
+		vap_id, mode, vap_status);
+	rsi_hex_dump(INFO_ZONE, "mac", mac_addr, 6);
 	skb = dev_alloc_skb(sizeof(struct rsi_vap_caps));
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
@@ -642,46 +830,63 @@ int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode)
 					     FRAME_DESC_SZ) |
 					     (RSI_WIFI_MGMT_Q << 12));
 	vap_caps->desc_word[1] = cpu_to_le16(VAP_CAPABILITIES);
+	vap_caps->desc_word[2] = cpu_to_le16(vap_status << 8);
 	vap_caps->desc_word[4] = cpu_to_le16(mode |
 					     (common->channel_width << 8));
 	vap_caps->desc_word[7] = cpu_to_le16((vap_id << 8) |
 					     (common->mac_id << 4) |
 					     common->radio_id);
 
-	memcpy(vap_caps->mac_addr, common->mac_addr, IEEE80211_ADDR_LEN);
+	memcpy(vap_caps->mac_addr, mac_addr, IEEE80211_ADDR_LEN);
 	vap_caps->keep_alive_period = cpu_to_le16(90);
 	vap_caps->frag_threshold = cpu_to_le16(IEEE80211_MAX_FRAG_THRESHOLD);
 
 	vap_caps->rts_threshold = cpu_to_le16(common->rts_threshold);
-	vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);
 
-	if (common->band == IEEE80211_BAND_5GHZ) {
+	if (common->band == NL80211_BAND_5GHZ) {
 		vap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_6);
-		if (conf_is_ht40(&common->priv->hw->conf)) {
-			vap_caps->default_ctrl_rate |=
-				cpu_to_le32(FULL40M_ENABLE << 16);
-		}
+		vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);
 	} else {
+		if (common->p2p_enabled) {
+			vap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_6);
+			vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_6);
+		} else {
 		vap_caps->default_ctrl_rate = cpu_to_le32(RSI_RATE_1);
+		vap_caps->default_mgmt_rate = cpu_to_le32(RSI_RATE_1);
+	}
+	}
+
+	if (conf_is_ht40(conf)) {
 		if (conf_is_ht40_minus(conf))
 			vap_caps->default_ctrl_rate |=
 				cpu_to_le32(UPPER_20_ENABLE << 16);
 		else if (conf_is_ht40_plus(conf))
 			vap_caps->default_ctrl_rate |=
 				cpu_to_le32(LOWER_20_ENABLE << 16);
+		else
+			vap_caps->default_ctrl_rate |=
+				cpu_to_le32(FULL40M_ENABLE << 16);
 	}
 
 	vap_caps->default_data_rate = 0;
-	vap_caps->beacon_interval = cpu_to_le16(200);
-	vap_caps->dtim_period = cpu_to_le16(4);
+	vap_caps->beacon_interval = cpu_to_le16(common->beacon_interval);
+	vap_caps->dtim_period = cpu_to_le16(common->dtim_cnt);
+#ifdef RSI_HW_CONN_MONITOR
+	vap_caps->beacon_miss_threshold = cpu_to_le16(10);
+#else
+	if (mode == AP_OPMODE)
+		vap_caps->beacon_miss_threshold = cpu_to_le16(10);
+#endif
 
 	skb_put(skb, sizeof(*vap_caps));
 
+	common->last_vap_type = mode;
+	ether_addr_copy(common->last_vap_addr, mac_addr);
 	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
 /**
- * rsi_hal_load_key() - This function is used to load keys within the firmware.
+ * rsi_load_key() - This function is used to load keys within the firmware.
  * @common: Pointer to the driver private structure.
  * @data: Pointer to the key data.
  * @key_len: Key length to be loaded.
@@ -691,16 +896,20 @@ int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode)
  *
  * Return: 0 on success, -1 on failure.
  */
-int rsi_hal_load_key(struct rsi_common *common,
-		     u8 *data,
-		     u16 key_len,
-		     u8 key_type,
-		     u8 key_id,
-		     u32 cipher)
+int rsi_load_key(struct rsi_common *common,
+		 u8 *data,
+		 u16 key_len,
+		 u8 key_type,
+		 u8 key_id,
+		 u32 cipher,
+		 s16 sta_id)
 {
+	struct ieee80211_vif *vif = common->priv->vifs[common->priv->sc_nvifs - 1];
 	struct sk_buff *skb = NULL;
 	struct rsi_set_key *set_key;
 	u16 key_descriptor = 0;
+	u8 key_t1 = 0;
+	u8 vap_id = 0;
 
 	rsi_dbg(MGMT_TX_ZONE, "%s: Sending load key frame\n", __func__);
 
@@ -714,44 +923,174 @@ int rsi_hal_load_key(struct rsi_common *common,
 	memset(skb->data, 0, sizeof(struct rsi_set_key));
 	set_key = (struct rsi_set_key *)skb->data;
 
+	switch (key_type) {
+	case RSI_GROUP_KEY:
+		key_t1 = 1 << 1;
+		if ((vif->type == NL80211_IFTYPE_AP) ||
+		    (vif->type == NL80211_IFTYPE_P2P_GO))
+			key_descriptor = BIT(7);
+		break;
+	case RSI_PAIRWISE_KEY:
+		if (((vif->type == NL80211_IFTYPE_AP) ||
+		     (vif->type == NL80211_IFTYPE_P2P_GO)) &&
+		    (sta_id >= common->max_stations)) {
+			rsi_dbg(INFO_ZONE, "Invalid Sta_id %d\n", sta_id);
+			return -1;
+		}
+		key_t1 = 0 << 1;
+		if ((cipher != WLAN_CIPHER_SUITE_WEP40) &&
+		    (cipher != WLAN_CIPHER_SUITE_WEP104))
+			key_id = 0;
+		break;
+	}
 	if ((cipher == WLAN_CIPHER_SUITE_WEP40) ||
 	    (cipher == WLAN_CIPHER_SUITE_WEP104)) {
-		key_len += 1;
 		key_descriptor |= BIT(2);
-		if (key_len >= 13)
+		if (key_len >= 13) {
 			key_descriptor |= BIT(3);
+		}
 	} else if (cipher != KEY_TYPE_CLEAR) {
 		key_descriptor |= BIT(4);
-		if (key_type == RSI_PAIRWISE_KEY)
-			key_id = 0;
 		if (cipher == WLAN_CIPHER_SUITE_TKIP)
 			key_descriptor |= BIT(5);
 	}
-	key_descriptor |= (key_type | BIT(13) | (key_id << 14));
+	key_descriptor |= (key_t1 | BIT(13) | (key_id << 14));
 
 	set_key->desc_word[0] = cpu_to_le16((sizeof(struct rsi_set_key) -
 					    FRAME_DESC_SZ) |
 					    (RSI_WIFI_MGMT_Q << 12));
 	set_key->desc_word[1] = cpu_to_le16(SET_KEY_REQ);
 	set_key->desc_word[4] = cpu_to_le16(key_descriptor);
+	set_key->desc_word[7] = cpu_to_le16(sta_id | (vap_id << 8));
 
-	if ((cipher == WLAN_CIPHER_SUITE_WEP40) ||
-	    (cipher == WLAN_CIPHER_SUITE_WEP104)) {
-		memcpy(&set_key->key[key_id][1],
-		       data,
-		       key_len * 2);
+	if (data) {
+		if ((cipher == WLAN_CIPHER_SUITE_WEP40) ||
+		    (cipher == WLAN_CIPHER_SUITE_WEP104)) {
+			memcpy(&set_key->key[key_id][1], data, key_len * 2);
+		} else {
+			memcpy(&set_key->key[0][0], data, key_len);
+		}
+		memcpy(set_key->tx_mic_key, &data[16], 8);
+		memcpy(set_key->rx_mic_key, &data[24], 8);
 	} else {
-		memcpy(&set_key->key[0][0], data, key_len);
+		memset(&set_key[FRAME_DESC_SZ], 0,
+		       sizeof(struct rsi_set_key) - FRAME_DESC_SZ);				
 	}
 
-	memcpy(set_key->tx_mic_key, &data[16], 8);
-	memcpy(set_key->rx_mic_key, &data[24], 8);
-
 	skb_put(skb, sizeof(struct rsi_set_key));
 
 	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
+/**
+ * rsi_send_common_dev_params() - This function send the common device
+ *				configuration parameters to device.
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, -1 on failure.
+ */
+int rsi_send_common_dev_params(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	u32 *soc_gpio, len;
+	u16 *frame, *ulp_gpio, *desc;
+
+	rsi_dbg(INFO_ZONE, "Sending common dev config params\n");
+
+	len = 0x20;
+
+	skb = dev_alloc_skb(len + FRAME_DESC_SZ);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, len + FRAME_DESC_SZ);
+
+	desc = (u16 *)&skb->data[0];
+	frame = (u16 *)&skb->data[FRAME_DESC_SZ];
+
+	desc[0] = cpu_to_le16(len | (RSI_COEX_Q << 12));
+	desc[1] = cpu_to_le16(COMMON_DEV_CONFIG);
+
+	frame[0] = (u16)common->lp_ps_handshake_mode;
+	frame[0] |= (u16)common->ulp_ps_handshake_mode << 8;
+
+	ulp_gpio = (u16 *)&unused_ulp_gpio_bitmap;
+	soc_gpio = (u32 *)&unused_soc_gpio_bitmap;
+
+	frame[1] |= (*ulp_gpio) << 8;
+	*(u32 *)&frame[2] = *soc_gpio;
+	frame[4] |= cpu_to_le16((u16)common->oper_mode << 8);
+	frame[5] |= cpu_to_le16((u16)common->wlan_rf_power_mode);
+	frame[5] |= cpu_to_le16((u16)common->bt_rf_power_mode << 8);
+	frame[6] |= cpu_to_le16((u16)common->driver_mode << 8);
+	frame[7] = cpu_to_le16(3); //((u16 )d_assets->region_code);
+	frame[7] |= cpu_to_le16((u16)common->obm_ant_sel_val << 8);
+
+	skb_put(skb, len + FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+#if 0
+int rsi_send_common_dev_params(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	u32 *unused_soc_gpio;
+	u32 frame_len = 0;
+	struct rsi_config_vals *dev_cfgs = NULL;
+
+	frame_len = sizeof(struct rsi_config_vals);
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending common device config params frame\n",
+		__func__);
+	skb = dev_alloc_skb(frame_len);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to allocate skb\n", __func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, frame_len);
+
+	dev_cfgs = (struct rsi_config_vals *)&skb->data[0];
+	memset(dev_cfgs, 0, (sizeof(struct rsi_config_vals)));
+
+	dev_cfgs->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+					     (RSI_COEX_Q << 12));
+	dev_cfgs->desc_word[1] = cpu_to_le16(COMMON_DEV_CONFIG);
+
+	dev_cfgs->lp_ps_handshake = common->lp_ps_handshake_mode;
+	dev_cfgs->ulp_ps_handshake = common->ulp_ps_handshake_mode;
+
+	if (common->host_wakeup_intr_enable) {
+		dev_cfgs->sleep_config_params |=
+			common->host_wakeup_intr_enable;
+		dev_cfgs->sleep_config_params |= BIT(2);
+		if (common->host_wakeup_intr_active_high)
+			dev_cfgs->sleep_config_params |= BIT(3);
+	}
+
+	dev_config_vals[0].opermode = common->coex_mode;
+
+	if (dev_config_vals[0].ext_pa_or_bt_coex_en)
+		dev_cfgs->ext_pa_or_bt_coex_en =
+			dev_config_vals[0].ext_pa_or_bt_coex_en;
+	dev_cfgs->opermode = dev_config_vals[0].opermode;
+	dev_cfgs->wlan_rf_pwr_mode = common->wlan_rf_power_mode;
+	dev_cfgs->driver_mode = common->driver_mode;
+	dev_cfgs->region_code = 0; /* Default US */
+	dev_cfgs->antenna_sel_val = common->obm_ant_sel_val;
+
+	unused_soc_gpio = (u32 *)&unused_soc_gpio_bitmap;
+	dev_cfgs->unused_soc_gpio_bitmap = *unused_soc_gpio;
+
+	skb_put(skb, frame_len);
+
+	rsi_hex_dump(ERR_ZONE, "common dev config params ",
+		     skb->data, skb->len);
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+#endif
+
 /*
  * rsi_load_bootup_params() - This function send bootup params to the firmware.
  * @common: Pointer to the driver private structure.
@@ -780,7 +1119,8 @@ static int rsi_load_bootup_params(struct rsi_common *common)
 		memcpy(&boot_params->bootup_params,
 		       &boot_params_40,
 		       sizeof(struct bootup_params));
-		rsi_dbg(MGMT_TX_ZONE, "%s: Packet 40MHZ <=== %d\n", __func__,
+		rsi_dbg(MGMT_TX_ZONE,
+			"%s: Packet 40MHZ <=== %d\n", __func__,
 			UMAC_CLK_40BW);
 		boot_params->desc_word[7] = cpu_to_le16(UMAC_CLK_40BW);
 	} else {
@@ -839,7 +1179,13 @@ static int rsi_send_reset_mac(struct rsi_common *common)
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(RESET_MAC_REQ);
-	mgmt_frame->desc_word[4] = cpu_to_le16(RETRY_COUNT << 8);
+	mgmt_frame->desc_word[4] |= cpu_to_le16(RETRY_COUNT << 8);
+
+	/*TA level aggregation of pkts to host */
+	mgmt_frame->desc_word[3] |=  common->ta_aggr << 8;
+
+	if (common->antenna_diversity)
+		mgmt_frame->desc_word[6] = common->antenna_diversity;
 
 	skb_put(skb, FRAME_DESC_SZ);
 
@@ -852,13 +1198,13 @@ static int rsi_send_reset_mac(struct rsi_common *common)
  *
  * Return: 0 on success, corresponding error code on failure.
  */
-int rsi_band_check(struct rsi_common *common)
+int rsi_band_check(struct rsi_common *common,
+		   struct ieee80211_channel *curchan)
 {
 	struct rsi_hw *adapter = common->priv;
 	struct ieee80211_hw *hw = adapter->hw;
 	u8 prev_bw = common->channel_width;
 	u8 prev_ep = common->endpoint;
-	struct ieee80211_channel *curchan = hw->conf.chandef.chan;
 	int status = 0;
 
 	if (common->band != curchan->band) {
@@ -872,7 +1218,7 @@ int rsi_band_check(struct rsi_common *common)
 	else
 		common->channel_width = BW_40MHZ;
 
-	if (common->band == IEEE80211_BAND_2GHZ) {
+	if (common->band == NL80211_BAND_2GHZ) {
 		if (common->channel_width)
 			common->endpoint = EP_2GHZ_40MHZ;
 		else
@@ -903,6 +1249,43 @@ int rsi_band_check(struct rsi_common *common)
 	return status;
 }
 
+#ifdef CONFIG_CARACALLA_BOARD
+void rsi_apply_carcalla_power_values(struct rsi_hw *adapter,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_channel *channel)
+{
+	u16 max_power = 20;
+
+	if (!conf_is_ht(&adapter->hw->conf)) {
+		if (vif->bss_conf.basic_rates == 0xf) {
+			if (channel->hw_value == 12)
+				max_power = 15;
+			else if (channel->hw_value == 13)
+				max_power = 7; 
+		} else {
+			if (channel->hw_value == 12)
+				max_power = 8; 
+			else if (channel->hw_value == 13)
+				max_power = 7; 
+		}
+	} else if (conf_is_ht20(&adapter->hw->conf)) {
+		if (channel->hw_value == 12)
+			max_power = 7; 
+		else if (channel->hw_value == 13)
+			max_power = 5; 
+	} else {
+		if (channel->hw_value == 6)
+			max_power = 9; 
+		else if (channel->hw_value == 9)
+			max_power = 5; 
+		else if (channel->hw_value == 10)
+			max_power = 4; 
+	}
+	channel->max_power = max_power;
+	channel->max_reg_power = max_power;
+}
+#endif
+
 /**
  * rsi_set_channel() - This function programs the channel.
  * @common: Pointer to the driver private structure.
@@ -910,8 +1293,13 @@ int rsi_band_check(struct rsi_common *common)
  *
  * Return: 0 on success, corresponding error code on failure.
  */
-int rsi_set_channel(struct rsi_common *common, u16 channel)
+int rsi_set_channel(struct rsi_common *common,
+		    struct ieee80211_channel *channel)
 {
+	struct rsi_hw *adapter = common->priv;
+#ifdef CONFIG_CARACALLA_BOARD
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
+#endif
 	struct sk_buff *skb = NULL;
 	struct rsi_mac_frame *mgmt_frame;
 
@@ -925,24 +1313,215 @@ int rsi_set_channel(struct rsi_common *common, u16 channel)
 		return -ENOMEM;
 	}
 
+	if (!channel) {
+		dev_kfree_skb(skb);
+		return 0;
+	}
 	memset(skb->data, 0, FRAME_DESC_SZ);
 	mgmt_frame = (struct rsi_mac_frame *)skb->data;
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(SCAN_REQUEST);
-	mgmt_frame->desc_word[4] = cpu_to_le16(channel);
+	mgmt_frame->desc_word[4] = cpu_to_le16(channel->hw_value);
+
+#if 0
+	channel->max_antenna_gain = common->antenna_gain;
+	mgmt_frame->desc_word[4] |=
+		cpu_to_le16(((char)(channel->max_antenna_gain)) << 8);
+	mgmt_frame->desc_word[5] =
+		cpu_to_le16((char)(channel->max_antenna_gain));
+#endif
+	mgmt_frame->desc_word[4] |=
+		cpu_to_le16(common->antenna_gain[0] << 8);
+	mgmt_frame->desc_word[5] =
+		cpu_to_le16(common->antenna_gain[1]);
 
 	mgmt_frame->desc_word[7] = cpu_to_le16(PUT_BBP_RESET |
 					       BBP_REG_WRITE |
 					       (RSI_RF_TYPE << 4));
 
-	mgmt_frame->desc_word[5] = cpu_to_le16(0x01);
-	mgmt_frame->desc_word[6] = cpu_to_le16(0x12);
+	if ((channel->flags & IEEE80211_CHAN_NO_IR) ||
+	    (channel->flags & IEEE80211_CHAN_RADAR)) {
+		mgmt_frame->desc_word[4] |= BIT(15);
+	} else {
+		if (common->tx_power < channel->max_power)
+			mgmt_frame->desc_word[6] =
+				cpu_to_le16(common->tx_power);
+		else
+			mgmt_frame->desc_word[6] =
+				cpu_to_le16(channel->max_power);
+	}
+#ifdef CONFIG_CARACALLA_BOARD
+	rsi_apply_carcalla_power_values(adapter, vif, channel);
+	mgmt_frame->desc_word[6] = cpu_to_le16(channel->max_power);
+
+	if ((channel->hw_value == 12) || (channel->hw_value == 13))
+		mgmt_frame->desc_word[7] = cpu_to_le16(TARGET_BOARD_CARACALLA);
+	if (conf_is_ht40(&adapter->hw->conf)) {
+		if ((channel->hw_value == 6) ||
+		    (channel->hw_value == 9) ||
+		    (channel->hw_value == 10))
+		mgmt_frame->desc_word[7] = cpu_to_le16(TARGET_BOARD_CARACALLA);
+	}
+#endif
+	rsi_dbg(INFO_ZONE, "reg_domain = %d, TX power = %d\n",
+		adapter->dfs_region, mgmt_frame->desc_word[6]);
+	mgmt_frame->desc_word[7] |= cpu_to_le16(adapter->dfs_region);
 
 	if (common->channel_width == BW_40MHZ)
 		mgmt_frame->desc_word[5] |= cpu_to_le16(0x1 << 8);
 
-	common->channel = channel;
+	common->channel = channel->hw_value;
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_send_radio_params_update() - This function sends the radio
+ *				parameters update to device
+ * @common: Pointer to the driver private structure.
+ * @channel: Channel value to be set.
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+int rsi_send_radio_params_update(struct rsi_common *common)
+{
+	struct rsi_mac_frame *mgmt_frame;
+	struct sk_buff *skb = NULL;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending Radio Params update frame\n", __func__);
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	mgmt_frame = (struct rsi_mac_frame *)skb->data;
+
+	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+	mgmt_frame->desc_word[1] = cpu_to_le16(RADIO_PARAMS_UPDATE);
+	mgmt_frame->desc_word[3] = cpu_to_le16(BIT(0));
+
+	mgmt_frame->desc_word[3] |= cpu_to_le16(common->tx_power << 8);
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_send_vap_dynamic_update() - This function programs the threshold.
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+int rsi_send_vap_dynamic_update(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	struct rsi_dynamic_s *dynamic_frame = NULL;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending vap update indication frame\n", __func__);
+
+	skb = dev_alloc_skb(sizeof(struct rsi_dynamic_s));
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, sizeof(struct rsi_dynamic_s));
+	dynamic_frame = (struct rsi_dynamic_s *)skb->data;
+
+	dynamic_frame->desc_word[0] = cpu_to_le16(
+					(sizeof(dynamic_frame->frame_body)) |
+					(RSI_WIFI_MGMT_Q << 12));
+	dynamic_frame->desc_word[1] = cpu_to_le16(VAP_DYNAMIC_UPDATE);
+	dynamic_frame->desc_word[4] = cpu_to_le16(common->rts_threshold);
+#if 0
+	dynamic_frame->desc_word[5] = cpu_to_le16(common->frag_threshold);
+	dynamic_frame->desc_word[5] = cpu_to_le16(2352);
+#endif
+
+#ifdef CONFIG_RSI_WOW
+//	if (common->suspend_flag) {
+	if (1) {
+		dynamic_frame->desc_word[6] =
+			cpu_to_le16(24); /* bmiss_threshold */
+		dynamic_frame->frame_body.keep_alive_period =
+			cpu_to_le16(5);
+	} else
+		dynamic_frame->frame_body.keep_alive_period = cpu_to_le16(90);
+#else
+	dynamic_frame->frame_body.keep_alive_period = cpu_to_le16(90);
+#endif
+
+#if 0
+	dynamic_frame->frame_body.mgmt_rate = cpu_to_le32(RSI_RATE_6);
+
+	dynamic_frame->desc_word[2] |= cpu_to_le32(BIT(1));/* Self cts enable */
+
+	dynamic_frame->desc_word[3] |= cpu_to_le16(BIT(0));/* fixed rate */
+	dynamic_frame->frame_body.data_rate = cpu_to_le16(0);
+#endif
+
+	dynamic_frame->desc_word[7] |= cpu_to_le16((0 << 8)); /* vap id */
+
+	skb_put(skb, sizeof(struct rsi_dynamic_s));
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_flash_read() - This function sends the frash read frame to device
+ * @adapter: Pointer to the hardware structure.
+ *
+ * Return: status: 0 on success, -1 on failure.
+ */
+int rsi_flash_read(struct rsi_hw *adapter)
+{
+	struct rsi_common *common = adapter->priv;
+	struct rsi_mac_frame *cmd_frame = NULL;
+	struct sk_buff *skb;
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending flash read frame\n", __func__);
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb)
+		return -ENOMEM;
+
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	cmd_frame = (struct rsi_mac_frame *)skb->data;
+
+	/* FrameType */
+	cmd_frame->desc_word[1] = cpu_to_le16(EEPROM_READ);
+
+	/* Format of length and offset differs for
+	 * autoflashing and swbl flashing
+	 */
+	cmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+
+	/* Number of bytes to read */
+	rsi_dbg(INFO_ZONE, " eeprom length  0x%x, %d\n",
+		adapter->eeprom.length, adapter->eeprom.length);
+	cmd_frame->desc_word[3] = cpu_to_le16(adapter->eeprom.length << 4);
+
+	cmd_frame->desc_word[2] |= cpu_to_le16(3 << 8);
+	if (adapter->eeprom_init) {
+		rsi_dbg(INFO_ZONE, "spi init sent");
+		cmd_frame->desc_word[2] |= cpu_to_le16(BIT(13));
+	}
+
+	/* Address to read */
+	cmd_frame->desc_word[4] = cpu_to_le16(adapter->eeprom.offset);
+	cmd_frame->desc_word[5] = cpu_to_le16(adapter->eeprom.offset >> 16);
+	cmd_frame->desc_word[6] = cpu_to_le16(0); //delay = 0
 
 	skb_put(skb, FRAME_DESC_SZ);
 
@@ -980,6 +1559,7 @@ static int rsi_compare(const void *a, const void *b)
 static bool rsi_map_rates(u16 rate, int *offset)
 {
 	int kk;
+
 	for (kk = 0; kk < ARRAY_SIZE(rsi_mcsrates); kk++) {
 		if (rate == mcs[kk]) {
 			*offset = kk;
@@ -1003,8 +1583,11 @@ static bool rsi_map_rates(u16 rate, int *offset)
  *
  * Return: 0 on success, corresponding error code on failure.
  */
-static int rsi_send_auto_rate_request(struct rsi_common *common)
+static int rsi_send_auto_rate_request(struct rsi_common *common,
+				      struct ieee80211_sta *sta,
+				      u16 sta_id)
 {
+	struct ieee80211_vif *vif = common->priv->vifs[0];
 	struct sk_buff *skb;
 	struct rsi_auto_rate *auto_rate;
 	int ii = 0, jj = 0, kk = 0;
@@ -1012,26 +1595,29 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	u8 band = hw->conf.chandef.chan->band;
 	u8 num_supported_rates = 0;
 	u8 rate_table_offset, rate_offset = 0;
-	u32 rate_bitmap = common->bitrate_mask[band];
-
+	u32 rate_bitmap = 0;
 	u16 *selected_rates, min_rate;
+	bool is_ht = false, is_sgi = false;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending auto rate request frame\n", __func__);
 
-	skb = dev_alloc_skb(sizeof(struct rsi_auto_rate));
+	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);
 	if (!skb) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
 			__func__);
 		return -ENOMEM;
 	}
 
-	selected_rates = kmalloc(2 * RSI_TBL_SZ, GFP_KERNEL);
+	memset(skb->data, 0, MAX_MGMT_PKT_SIZE);
+
+	selected_rates = kzalloc(2 * RSI_TBL_SZ, GFP_KERNEL);
 	if (!selected_rates) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of mem\n",
 			__func__);
 		dev_kfree_skb(skb);
 		return -ENOMEM;
 	}
-
-	memset(skb->data, 0, sizeof(struct rsi_auto_rate));
 	memset(selected_rates, 0, 2 * RSI_TBL_SZ);
 
 	auto_rate = (struct rsi_auto_rate *)skb->data;
@@ -1045,13 +1631,34 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	auto_rate->desc_word[1] = cpu_to_le16(AUTO_RATE_IND);
 
 	if (common->channel_width == BW_40MHZ)
-		auto_rate->desc_word[7] |= cpu_to_le16(1);
+		auto_rate->desc_word[7] = cpu_to_le16(1);
+	auto_rate->desc_word[7] |= cpu_to_le16(sta_id << 8);
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		rate_bitmap = common->bitrate_mask[band];
+		is_ht = common->vif_info[0].is_ht;
+		is_sgi = common->vif_info[0].sgi;
+	} else {
+		rate_bitmap = sta->supp_rates[band];
+		is_ht = sta->ht_cap.ht_supported;
+		if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||
+		    (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))
+			is_sgi = true;
+	}
+	rsi_dbg(INFO_ZONE, "rate_bitmap = %x\n", rate_bitmap);
+	rsi_dbg(INFO_ZONE, "is_ht = %d\n", is_ht);
 
-	if (band == IEEE80211_BAND_2GHZ) {
-		min_rate = RSI_RATE_1;
+	if (band == NL80211_BAND_2GHZ) {
+		if ((rate_bitmap == 0) && (is_ht))
+			min_rate = RSI_RATE_MCS0;
+		else
+			min_rate = RSI_RATE_1;
 		rate_table_offset = 0;
 	} else {
-		min_rate = RSI_RATE_6;
+		if ((rate_bitmap == 0) && (is_ht))
+			min_rate = RSI_RATE_MCS0;
+		else
+			min_rate = RSI_RATE_6;
 		rate_table_offset = 4;
 	}
 
@@ -1065,7 +1672,7 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	}
 	num_supported_rates = jj;
 
-	if (common->vif_info[0].is_ht) {
+	if (is_ht) {
 		for (ii = 0; ii < ARRAY_SIZE(mcs); ii++)
 			selected_rates[jj++] = mcs[ii];
 		num_supported_rates += ARRAY_SIZE(mcs);
@@ -1086,13 +1693,16 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 	}
 
 	/* loading HT rates in the bottom half of the auto rate table */
-	if (common->vif_info[0].is_ht) {
+	if (is_ht) {
 		for (ii = rate_offset, kk = ARRAY_SIZE(rsi_mcsrates) - 1;
 		     ii < rate_offset + 2 * ARRAY_SIZE(rsi_mcsrates); ii++) {
-			if (common->vif_info[0].sgi ||
-			    conf_is_ht40(&common->priv->hw->conf))
+			if (is_sgi || conf_is_ht40(&common->priv->hw->conf)) {
+				auto_rate->supported_rates[ii++] =
+					cpu_to_le16(rsi_mcsrates[kk]/* | BIT(9)*/);
+			} else {
 				auto_rate->supported_rates[ii++] =
-					cpu_to_le16(rsi_mcsrates[kk] | BIT(9));
+					cpu_to_le16(rsi_mcsrates[kk]);
+			}
 			auto_rate->supported_rates[ii] =
 				cpu_to_le16(rsi_mcsrates[kk--]);
 		}
@@ -1108,70 +1718,287 @@ static int rsi_send_auto_rate_request(struct rsi_common *common)
 
 	auto_rate->num_supported_rates = cpu_to_le16(num_supported_rates * 2);
 	auto_rate->moderate_rate_inx = cpu_to_le16(num_supported_rates / 2);
-	auto_rate->desc_word[7] |= cpu_to_le16(0 << 8);
 	num_supported_rates *= 2;
 
 	auto_rate->desc_word[0] = cpu_to_le16((sizeof(*auto_rate) -
-					       FRAME_DESC_SZ) |
-					       (RSI_WIFI_MGMT_Q << 12));
+					      FRAME_DESC_SZ) |
+					      (RSI_WIFI_MGMT_Q << 12));
 
-	skb_put(skb,
-		sizeof(struct rsi_auto_rate));
+	skb_put(skb, sizeof(struct rsi_auto_rate));
 	kfree(selected_rates);
 
 	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
 /**
- * rsi_inform_bss_status() - This function informs about bss status with the
- *			     help of sta notify params by sending an internal
- *			     management frame to firmware.
- * @common: Pointer to the driver private structure.
- * @status: Bss status type.
- * @bssid: Bssid.
- * @qos_enable: Qos is enabled.
- * @aid: Aid (unique for all STAs).
+ * rsi_validate_bgscan_channels() - This function is used to validate
+ *				the user configured bgscan channels for
+ *				current regulatory domain
+ * @chn_num: It holds the user or default channel for validation.
  *
- * Return: None.
+ * Return: 0 on success, corresponding error code on failure.
  */
-void rsi_inform_bss_status(struct rsi_common *common,
-			   u8 status,
-			   const unsigned char *bssid,
-			   u8 qos_enable,
-			   u16 aid)
+void rsi_validate_bgscan_channels(struct rsi_hw *adapter,
+				  struct bgscan_config_params *params)
 {
-	if (status) {
-		rsi_hal_send_sta_notify_frame(common,
-					      RSI_IFTYPE_STATION,
-					      STA_CONNECTED,
-					      bssid,
-					      qos_enable,
-					      aid);
-		if (common->min_rate == 0xffff)
-			rsi_send_auto_rate_request(common);
-	} else {
-		rsi_hal_send_sta_notify_frame(common,
-					      RSI_IFTYPE_STATION,
-					      STA_DISCONNECTED,
-					      bssid,
-					      qos_enable,
-					      aid);
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	struct wiphy *wiphy = adapter->hw->wiphy; 
+	u16 bgscan_channels[MAX_BGSCAN_CHANNELS] = {1, 2, 3, 4, 5, 6, 7, 8, 9,
+						    10, 11, 12, 13, 14, 36, 40,
+						    44, 48, 52, 56, 60, 64, 100,
+						    104, 108, 112, 116, 120, 124,
+						    128, 132, 136, 140, 149, 153,
+						    157, 161, 165};
+
+	int ch_num, i;
+	int num_valid_chs = 0, cnt;
+
+	/* If user passes 0 for num of bgscan channels, take all channels */
+	if (params->num_user_channels == 0) {
+		if (adapter->priv->num_supp_bands > 1)
+			params->num_user_channels = MAX_BGSCAN_CHANNELS;
+		else
+			params->num_user_channels = 14;
+
+		for (cnt = 0; cnt < params->num_user_channels; cnt++)
+			params->user_channels[cnt] = bgscan_channels[cnt];
+	}
+
+	rsi_dbg(INFO_ZONE, "Final bgscan channels:\n");
+	for (cnt = 0; cnt < params->num_user_channels; cnt++) {
+		ch_num = params->user_channels[cnt];
+
+		if ((ch_num < 1) ||
+		    ((ch_num > 14) && (ch_num < 36)) ||
+		    ((ch_num > 64) && (ch_num < 100)) ||
+		    ((ch_num > 140) && (ch_num < 149)) ||
+		    (ch_num > 165))
+			continue;
+		if ((ch_num >= 36) && (ch_num < 149) && (ch_num % 4))
+			continue;
+
+		if (ch_num > 14)
+			sband = wiphy->bands[NL80211_BAND_5GHZ];
+		else
+			sband = wiphy->bands[NL80211_BAND_2GHZ];
+
+		for (i = 0; i < sband->n_channels; i++) {
+			ch = &sband->channels[i];
+
+			if (ch->hw_value == ch_num)
+				break;
+		}
+		if (i >= sband->n_channels)
+			continue;
+
+		/* Check channel availablity for the current reg domain */
+		if (ch->flags & IEEE80211_CHAN_DISABLED)
+			continue;
+
+		params->channels2scan[num_valid_chs] = ch_num;
+		rsi_dbg(INFO_ZONE, "%d ", ch_num);
+		if ((ch->flags & IEEE80211_CHAN_NO_IR) ||
+		    (ch->flags & IEEE80211_CHAN_RADAR)) {
+			if((ch->flags & IEEE80211_CHAN_RADAR))
+				rsi_dbg(INFO_ZONE, "[DFS]");
+			params->channels2scan[num_valid_chs] |=
+				(cpu_to_le16(BIT(15))); /* DFS indication */
+		}
+		num_valid_chs++;
+		printk(" ");
 	}
+	printk("\n");
+	params->num_bg_channels = num_valid_chs;
 }
 
 /**
- * rsi_eeprom_read() - This function sends a frame to read the mac address
- *		       from the eeprom.
+ * rsi_send_bgscan_params() - This function sends the background
+ *			      scan parameters to firmware.
+ * @common: Pointer to the driver private structure.
+ * @enable: bgscan enable/disable
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+int rsi_send_bgscan_params(struct rsi_common *common, int enable)
+{
+	struct rsi_bgscan_params *bgscan;
+	struct bgscan_config_params *info = &common->bgscan_info;
+	struct sk_buff *skb;
+	u16 frame_len = sizeof(*bgscan);
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending bgscan params frame\n", __func__);
+
+	rsi_validate_bgscan_channels(common->priv, info);
+	if (!info->num_bg_channels) {
+		rsi_dbg(ERR_ZONE, "##### No valid bgscan channels #####\n");
+		return -1;
+	}
+	
+	skb = dev_alloc_skb(frame_len);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, frame_len);
+
+	bgscan = (struct rsi_bgscan_params *)skb->data;
+
+	bgscan->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+					   (RSI_WIFI_MGMT_Q << 12));
+	bgscan->desc_word[1] = cpu_to_le16(BG_SCAN_PARAMS);
+
+	bgscan->bgscan_threshold = cpu_to_le16(info->bgscan_threshold);
+	bgscan->roam_threshold = cpu_to_le16(info->roam_threshold);
+	if (enable) {
+		bgscan->bgscan_periodicity =
+			cpu_to_le16(info->bgscan_periodicity);
+	}
+	bgscan->active_scan_duration =
+			cpu_to_le16(info->active_scan_duration);
+	bgscan->passive_scan_duration =
+			cpu_to_le16(info->passive_scan_duration);
+	bgscan->two_probe = info->two_probe;
+
+	memcpy(bgscan->channels2scan,
+	       info->channels2scan,
+	       info->num_bg_channels * 2);
+	bgscan->num_bg_channels = info->num_bg_channels;
+
+	skb_put(skb, frame_len);
+
+	rsi_hex_dump(MGMT_TX_ZONE, "bgscan params req", skb->data, skb->len);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_send_bgscan_probe_req() - This function sends the background
+ *                               scan probe request to firmware.
+ * @common: Pointer to the driver private structure.
+ *
+ * Return: 0 on success, corresponding error code on failure.
+ */
+int rsi_send_bgscan_probe_req(struct rsi_common *common)
+{
+	struct rsi_bgscan_probe *bgscan;
+	struct sk_buff *skb;
+	u16 frame_len = sizeof(*bgscan);
+	u16 len = 1500;
+	u16 pbreq_len = 0;
+
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending bgscan probe req frame\n", __func__);
+
+	skb = dev_alloc_skb(frame_len + len);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, frame_len + len);
+
+	bgscan = (struct rsi_bgscan_probe *)skb->data;
+
+	bgscan->desc_word[1] = cpu_to_le16(BG_SCAN_PROBE_REQ);
+	bgscan->flags = cpu_to_le16(HOST_BG_SCAN_TRIG);
+	if (common->band == NL80211_BAND_5GHZ) {
+		bgscan->mgmt_rate = cpu_to_le16(RSI_RATE_6);
+		bgscan->channel_num = cpu_to_le16(40);
+	} else {
+		bgscan->mgmt_rate = cpu_to_le16(RSI_RATE_1);
+		bgscan->channel_num = cpu_to_le16(11);
+	}
+
+	bgscan->channel_scan_time = cpu_to_le16(20);
+	if (common->bgscan_probe_req_len > 0) {
+		pbreq_len = common->bgscan_probe_req_len;
+		bgscan->probe_req_length = pbreq_len;
+		memcpy(&skb->data[frame_len], common->bgscan_probe_req,
+		       common->bgscan_probe_req_len);
+	}
+
+	bgscan->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ + pbreq_len) |
+					   (RSI_WIFI_MGMT_Q << 12));
+
+	skb_put(skb, frame_len + pbreq_len);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_inform_bss_status() - This function informs about bss status with the
+ *			     help of sta notify params by sending an internal
+ *			     management frame to firmware.
+ * @common: Pointer to the driver private structure.
+ * @status: Bss status type.
+ * @bssid: Bssid.
+ * @qos_enable: Qos is enabled.
+ * @aid: Aid (unique for all STAs).
+ *
+ * Return: None.
+ */
+void rsi_inform_bss_status(struct rsi_common *common,
+			   enum opmode opmode,
+			   u8 status,
+			   const u8 *bssid,
+			   u8 qos_enable,
+			   u16 aid,
+			   struct ieee80211_sta *sta,
+			   u16 sta_id, u16 assoc_cap)
+{
+	if (status) {
+		if (opmode == STA_OPMODE)
+			common->hw_data_qs_blocked = true;
+		rsi_send_sta_notify_frame(common,
+					  opmode,
+					  STA_CONNECTED,
+					  bssid,
+					  qos_enable,
+					  aid,
+					  sta_id);
+		if (common->min_rate == 0xffff) {
+			rsi_dbg(INFO_ZONE, "Send auto rate request\n");
+			rsi_send_auto_rate_request(common, sta, sta_id);
+		}
+		if (opmode == STA_OPMODE) {
+			if (!(assoc_cap & BIT(4))) {	
+				rsi_dbg(INFO_ZONE, "unblock data in Open case\n");
+				if (!rsi_send_block_unblock_frame(common, false))
+					common->hw_data_qs_blocked = false;
+			}
+		}
+	} else {
+		if (opmode == STA_OPMODE)
+			common->hw_data_qs_blocked = true;
+#ifdef CONFIG_RSI_WOW
+		if (!common->suspend_flag) {
+#endif
+		rsi_send_sta_notify_frame(common,
+					  opmode,
+					  STA_DISCONNECTED,
+					  bssid,
+					  qos_enable,
+					  aid,
+					  sta_id);
+#ifdef CONFIG_RSI_WOW
+		}
+#endif
+		if (opmode == STA_OPMODE)
+			rsi_send_block_unblock_frame(common, true);
+	}
+}
+
+/**
+ * rsi_eeprom_read() - This function sends a frame to read the mac address
+ *		       from the eeprom.
  * @common: Pointer to the driver private structure.
  *
  * Return: 0 on success, -1 on failure.
  */
 static int rsi_eeprom_read(struct rsi_common *common)
 {
-	struct rsi_mac_frame *mgmt_frame;
+	struct rsi_mac_frame *mgmt_frame = NULL;
+	struct rsi_hw *adapter = common->priv;
 	struct sk_buff *skb;
 
-	rsi_dbg(MGMT_TX_ZONE, "%s: Sending EEPROM read req frame\n", __func__);
+	rsi_dbg(MGMT_TX_ZONE,
+		"%s: Sending EEPROM read req frame\n", __func__);
 
 	skb = dev_alloc_skb(FRAME_DESC_SZ);
 	if (!skb) {
@@ -1184,15 +2011,17 @@ static int rsi_eeprom_read(struct rsi_common *common)
 	mgmt_frame = (struct rsi_mac_frame *)skb->data;
 
 	/* FrameType */
-	mgmt_frame->desc_word[1] = cpu_to_le16(EEPROM_READ_TYPE);
+	mgmt_frame->desc_word[1] = cpu_to_le16(EEPROM_READ);
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+
 	/* Number of bytes to read */
-	mgmt_frame->desc_word[3] = cpu_to_le16(ETH_ALEN +
-					       WLAN_MAC_MAGIC_WORD_LEN +
-					       WLAN_HOST_MODE_LEN +
-					       WLAN_FW_VERSION_LEN);
-	/* Address to read */
-	mgmt_frame->desc_word[4] = cpu_to_le16(WLAN_MAC_EEPROM_ADDR);
+	mgmt_frame->desc_word[3] = cpu_to_le16(adapter->eeprom.length << 4);
+	mgmt_frame->desc_word[2] |= cpu_to_le16(3 << 8);
+
+	/* Address to read*/
+	mgmt_frame->desc_word[4] = cpu_to_le16(adapter->eeprom.offset);
+	mgmt_frame->desc_word[5] = cpu_to_le16(adapter->eeprom.offset >> 16);
+	mgmt_frame->desc_word[6] = cpu_to_le16(0); //delay = 0
 
 	skb_put(skb, FRAME_DESC_SZ);
 
@@ -1226,45 +2055,279 @@ int rsi_send_block_unblock_frame(struct rsi_common *common, bool block_event)
 
 	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
 	mgmt_frame->desc_word[1] = cpu_to_le16(BLOCK_HW_QUEUE);
+	mgmt_frame->desc_word[3] = cpu_to_le16(0x1);
 
 	if (block_event == true) {
 		rsi_dbg(INFO_ZONE, "blocking the data qs\n");
 		mgmt_frame->desc_word[4] = cpu_to_le16(0xf);
+		mgmt_frame->desc_word[4] |= cpu_to_le16(0xf << 4);
 	} else {
 		rsi_dbg(INFO_ZONE, "unblocking the data qs\n");
 		mgmt_frame->desc_word[5] = cpu_to_le16(0xf);
+		mgmt_frame->desc_word[5] |= cpu_to_le16(0xf << 4);
 	}
 
 	skb_put(skb, FRAME_DESC_SZ);
 
 	return rsi_send_internal_mgmt_frame(common, skb);
+}
 
+/**
+ * This function sends a frame to filter the RX packets
+ *
+ * @param common Pointer to the driver private structure.
+ * @param rx_filter_word - Flags of filter packets
+ * @return 0 on success, -1 on failure.
+ */
+int rsi_send_rx_filter_frame(struct rsi_common *common, u16 rx_filter_word)
+{
+	struct rsi_mac_frame *mgmt_frame;
+	struct sk_buff *skb;
+
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sending RX filter frame\n", __func__);
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	mgmt_frame = (struct rsi_mac_frame *)skb->data;
+
+	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+	mgmt_frame->desc_word[1] = cpu_to_le16(SET_RX_FILTER);
+	mgmt_frame->desc_word[4] = cpu_to_le16(rx_filter_word);
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+EXPORT_SYMBOL_GPL(rsi_send_rx_filter_frame); 
+
+/**
+ * rsi_send_ps_request() - Sends power save request.
+ *
+ * @adapter: pointer to rsi_hw structure.
+ * @enable: enable or disable power save.
+ *
+ * returns: 0 on success, negative error code on failure
+ */
+int rsi_send_ps_request(struct rsi_hw *adapter, bool enable)
+{
+	struct rsi_common *common = adapter->priv;
+	struct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;
+	struct rsi_request_ps *ps = NULL;
+	struct rsi_ps_info *ps_info = NULL;
+	struct sk_buff *skb = NULL;
+	int frame_len = sizeof(*ps);
+
+	skb = dev_alloc_skb(frame_len);
+	if (!skb)
+		return -ENOMEM;
+	memset(skb->data, 0, frame_len);
+
+	ps = (struct rsi_request_ps *)&skb->data[0];
+	ps_info = &adapter->ps_info;
+
+	ps->desc_word[0] = cpu_to_le16((frame_len - FRAME_DESC_SZ) |
+				       (RSI_WIFI_MGMT_Q << 12));
+	ps->desc_word[1] = cpu_to_le16(WAKEUP_SLEEP_REQUEST);
+	if (enable) {
+		ps->ps_sleep.enable = 1;
+		ps->desc_word[6] = SLEEP_REQUEST;
+	} else {
+		ps->ps_sleep.enable = 0;
+		ps->desc_word[0] |= BIT(15);
+		ps->desc_word[6] = WAKEUP_REQUEST;
+	}
+
+	if (common->uapsd_bitmap) {
+//		ps->ps_mimic_support = 1;
+		ps->ps_uapsd_acs = common->uapsd_bitmap;
+	}
+
+	ps->ps_sleep.sleep_type = ps_info->sleep_type;
+	ps->ps_sleep.num_bcns_per_lis_int =
+		cpu_to_le16(ps_info->num_bcns_per_lis_int);
+	ps->ps_sleep.sleep_duration =
+		cpu_to_le32(ps_info->deep_sleep_wakeup_period);
+
+	if (bss->assoc)
+		ps->ps_sleep.connected_sleep = CONNECTED_SLEEP;
+	else
+		ps->ps_sleep.connected_sleep = DEEP_SLEEP;
+
+	ps->ps_listen_interval = cpu_to_le32(ps_info->listen_interval);
+	ps->ps_dtim_interval_duration =
+		cpu_to_le32(ps_info->dtim_interval_duration);
+
+	if (ps->ps_listen_interval > ps->ps_dtim_interval_duration)
+		ps->ps_listen_interval = 0;
+
+	ps->ps_num_dtim_intervals = cpu_to_le32(ps_info->num_dtims_per_sleep);
+
+	skb_put(skb, frame_len);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
+}
+
+/**
+ * rsi_set_antenna() - This fuction handles antenna selection functionality.
+ *
+ * @common: Pointer to the driver private structure.
+ * @antenna: bitmap for tx antenna selection
+ *
+ * Return: 0 on Success, < 0 on failure
+ */
+int rsi_set_antenna(struct rsi_common *common,
+		    u8 antenna)
+{
+	struct rsi_mac_frame *mgmt_frame;
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb(FRAME_DESC_SZ);
+	if (!skb) {
+		rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	memset(skb->data, 0, FRAME_DESC_SZ);
+	mgmt_frame = (struct rsi_mac_frame *)skb->data;
+
+	mgmt_frame->desc_word[1] = cpu_to_le16(ANT_SEL_FRAME);
+	mgmt_frame->desc_word[2] = cpu_to_le16(1 << 8); /* Antenna selection
+							   type */
+	mgmt_frame->desc_word[3] = cpu_to_le16(antenna & 0x00ff);
+	mgmt_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+
+	skb_put(skb, FRAME_DESC_SZ);
+
+	return rsi_send_internal_mgmt_frame(common, skb);
 }
 
+#ifdef CONFIG_RSI_WOW 
+int rsi_send_wowlan_request(struct rsi_common *common, u16 flags,
+		            u16 sleep_status)
+{
+        struct rsi_wowlan_req *cmd_frame;
+        struct sk_buff *skb;
+        u8 length;
+        u8 sourceid[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+        rsi_dbg(ERR_ZONE, "%s: Sending wowlan request frame\n", __func__);
+
+        skb = dev_alloc_skb(sizeof(*cmd_frame));
+        if (!skb) {
+                rsi_dbg(ERR_ZONE, "%s: Failed in allocation of skb\n",
+                                __func__);
+                return -ENOMEM;
+        }
+        memset(skb->data, 0, sizeof(*cmd_frame));
+        cmd_frame = (struct rsi_wowlan_req *)skb->data;
+
+        cmd_frame->desc_word[0] = cpu_to_le16(RSI_WIFI_MGMT_Q << 12);
+        cmd_frame->desc_word[1] |= cpu_to_le16(WOWLAN_CONFIG_PARAMS);
+ 
+        memcpy(cmd_frame->sourceid, &sourceid, IEEE80211_ADDR_LEN);
+	
+        cmd_frame->host_sleep_status = sleep_status;
+	if ((common->secinfo.security_enable) &&
+	    (common->secinfo.gtk_cipher))
+		flags |= RSI_WOW_GTK_REKEY;
+	if (sleep_status)
+		cmd_frame->wow_flags = flags; /* TODO: check for magic packet */
+        rsi_dbg(INFO_ZONE, "Host_Sleep_Status : %d Flags : %d\n",
+		cmd_frame->host_sleep_status, cmd_frame->wow_flags );
+	
+        length = FRAME_DESC_SZ + IEEE80211_ADDR_LEN + 2 + 2;
+
+        cmd_frame->desc_word[0] |= cpu_to_le16(length - FRAME_DESC_SZ);
+        cmd_frame->desc_word[2] |= cpu_to_le16(0);
+  
+  	skb_put(skb, length);
+
+        return rsi_send_internal_mgmt_frame(common, skb);
+}
+#endif
+
+int rsi_send_beacon(struct rsi_common *common)
+{
+	struct sk_buff *skb = NULL;
+	u8 dword_align_bytes = 0;
+	
+	skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);
+	if (!skb)
+		return -ENOMEM;
+
+	memset(skb->data, 0, MAX_MGMT_PKT_SIZE);
+	
+	dword_align_bytes = ((unsigned long)skb->data & 0x3f);
+	if (dword_align_bytes) {
+		skb_pull(skb, (64 - dword_align_bytes));
+	}
+	if (rsi_prepare_beacon(common, skb)) {
+		rsi_dbg(ERR_ZONE, "Failed to prepare beacon\n");
+		return -EINVAL;
+	}
+	skb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);
+	rsi_set_event(&common->tx_thread.event);
+	rsi_dbg(DATA_TX_ZONE,
+		"%s: Added to beacon queue\n", __func__);
+
+	return 0;
+}
 
 /**
- * rsi_handle_ta_confirm_type() - This function handles the confirm frames.
+ * rsi_handle_ta_confirm() - This function handles the confirm frames.
  * @common: Pointer to the driver private structure.
  * @msg: Pointer to received packet.
  *
  * Return: 0 on success, -1 on failure.
  */
-static int rsi_handle_ta_confirm_type(struct rsi_common *common,
-				      u8 *msg)
+static int rsi_handle_ta_confirm(struct rsi_common *common, u8 *msg)
 {
+	struct rsi_hw *adapter = common->priv;
 	u8 sub_type = (msg[15] & 0xff);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+
+	rsi_dbg(MGMT_RX_ZONE, "%s: subtype=%d\n", __func__, sub_type);
 
 	switch (sub_type) {
+	case COMMON_DEV_CONFIG:
+		rsi_dbg(FSM_ZONE,
+			"Common Dev Config params confirm received\n");
+		if (common->fsm_state == FSM_COMMON_DEV_PARAMS_SENT) {
+			if (rsi_load_bootup_params(common)) {
+				common->fsm_state = FSM_CARD_NOT_READY;
+				goto out;
+			} else {
+				common->fsm_state = FSM_BOOT_PARAMS_SENT;
+			}
+		} else {
+			rsi_dbg(INFO_ZONE,
+				"%s: Received common dev config params cfm in %d state\n",
+				 __func__, common->fsm_state);
+			return 0;
+		}
+		break;
+
 	case BOOTUP_PARAMS_REQUEST:
-		rsi_dbg(FSM_ZONE, "%s: Boot up params confirm received\n",
-			__func__);
+		rsi_dbg(FSM_ZONE, "Bootup params confirmation.\n");
 		if (common->fsm_state == FSM_BOOT_PARAMS_SENT) {
+			adapter->eeprom.length = (IEEE80211_ADDR_LEN +
+						  WLAN_MAC_MAGIC_WORD_LEN +
+						  WLAN_HOST_MODE_LEN);
+			adapter->eeprom.offset = WLAN_MAC_EEPROM_ADDR;
 			if (rsi_eeprom_read(common)) {
 				common->fsm_state = FSM_CARD_NOT_READY;
 				goto out;
-			} else {
+			} else
 				common->fsm_state = FSM_EEPROM_READ_MAC_ADDR;
-			}
 		} else {
 			rsi_dbg(INFO_ZONE,
 				"%s: Received bootup params cfm in %d state\n",
@@ -1273,18 +2336,66 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 		}
 		break;
 
-	case EEPROM_READ_TYPE:
+	case EEPROM_READ:
+		rsi_dbg(FSM_ZONE, "EEPROM READ confirm received\n");
 		if (common->fsm_state == FSM_EEPROM_READ_MAC_ADDR) {
+			u32 msg_len = ((u16 *)msg)[0] & 0xfff;
+
+			if (msg_len <= 0) {
+				rsi_dbg(FSM_ZONE,
+					"%s: [EEPROM_READ] Invalid len %d\n",
+					__func__, msg_len);
+				goto out;
+			}
 			if (msg[16] == MAGIC_WORD) {
-				u8 offset = (FRAME_DESC_SZ + WLAN_HOST_MODE_LEN
-					     + WLAN_MAC_MAGIC_WORD_LEN);
+				u8 offset = (FRAME_DESC_SZ +
+					     WLAN_HOST_MODE_LEN +
+					     WLAN_MAC_MAGIC_WORD_LEN);
+
 				memcpy(common->mac_addr,
 				       &msg[offset],
-				       ETH_ALEN);
-				memcpy(&common->fw_ver,
-				       &msg[offset + ETH_ALEN],
-				       sizeof(struct version_info));
+				       IEEE80211_ADDR_LEN);
+				rsi_hex_dump(INIT_ZONE,
+					     "MAC Addr",
+					     common->mac_addr, ETH_ALEN);
+				adapter->eeprom.length =
+					((WLAN_MAC_MAGIC_WORD_LEN + 3) & (~3));
+				adapter->eeprom.offset =
+					WLAN_EEPROM_RFTYPE_ADDR;
+				if (rsi_eeprom_read(common)) {
+					rsi_dbg(ERR_ZONE,
+						"%s: Failed reading RF band\n",
+						__func__);
+					common->fsm_state = FSM_CARD_NOT_READY;
+				} else {
+					common->fsm_state =
+						FSM_EEPROM_READ_RF_TYPE;
+				}
+			} else {
+				common->fsm_state = FSM_CARD_NOT_READY;
+				break;
+			}
+		} else if (common->fsm_state == FSM_EEPROM_READ_RF_TYPE) {
+			u32 msg_len = ((u16 *)msg)[0] & 0xfff;
 
+			if (msg_len <= 0) {
+				rsi_dbg(FSM_ZONE,
+					"%s:[EEPROM_READ_CFM] Invalid len %d\n",
+					__func__, msg_len);
+				goto out;
+			}
+			if (msg[16] == MAGIC_WORD) {
+				if ((msg[17] & 0x3) == 0x3) {
+					rsi_dbg(INIT_ZONE,
+						"Dual band supported\n");
+					common->band = NL80211_BAND_5GHZ;
+					common->num_supp_bands = 2;
+				} else if ((msg[17] & 0x3) == 0x1) {
+					rsi_dbg(INIT_ZONE,
+						"Only 2.4Ghz band supported\n");
+					common->band = NL80211_BAND_2GHZ;
+					common->num_supp_bands = 1;
+				}
 			} else {
 				common->fsm_state = FSM_CARD_NOT_READY;
 				break;
@@ -1295,7 +2406,7 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 				common->fsm_state = FSM_RESET_MAC_SENT;
 		} else {
 			rsi_dbg(ERR_ZONE,
-				"%s: Received eeprom mac addr in %d state\n",
+				"%s: Received eeprom read in %d state\n",
 				__func__, common->fsm_state);
 			return 0;
 		}
@@ -1303,8 +2414,7 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 
 	case RESET_MAC_REQ:
 		if (common->fsm_state == FSM_RESET_MAC_SENT) {
-			rsi_dbg(FSM_ZONE, "%s: Reset MAC cfm received\n",
-				__func__);
+			rsi_dbg(FSM_ZONE, "Reset MAC confirm\n");
 
 			if (rsi_load_radio_caps(common))
 				goto out;
@@ -1325,8 +2435,7 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 				goto out;
 			} else {
 				common->fsm_state = FSM_BB_RF_PROG_SENT;
-				rsi_dbg(FSM_ZONE, "%s: Radio cap cfm received\n",
-					__func__);
+				rsi_dbg(FSM_ZONE, "Radio caps confirm\n");
 			}
 		} else {
 			rsi_dbg(INFO_ZONE,
@@ -1339,7 +2448,7 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 	case BB_PROG_VALUES_REQUEST:
 	case RF_PROG_VALUES_REQUEST:
 	case BBP_PROG_IN_TA:
-		rsi_dbg(FSM_ZONE, "%s: BB/RF cfm received\n", __func__);
+		rsi_dbg(FSM_ZONE, "BB/RF confirmation.\n");
 		if (common->fsm_state == FSM_BB_RF_PROG_SENT) {
 			common->bb_rf_prog_count--;
 			if (!common->bb_rf_prog_count) {
@@ -1348,27 +2457,99 @@ static int rsi_handle_ta_confirm_type(struct rsi_common *common,
 			}
 		} else {
 			rsi_dbg(INFO_ZONE,
-				"%s: Received bbb_rf cfm in %d state\n",
+				"%s: Received bb_rf cfm in %d state\n",
 				 __func__, common->fsm_state);
 			return 0;
 		}
 		break;
 
+	case AMPDU_IND:
+		rsi_dbg(INFO_ZONE, "AMPDU indication.\n");
+		break;
+
+	case SCAN_REQUEST:
+		rsi_dbg(INFO_ZONE, "Scan confirm.\n");
+		rsi_set_event(&common->chan_set_event);
+		break;
+
+	case SET_RX_FILTER:
+		rsi_dbg(INFO_ZONE, "RX Filter confirmation.\n");
+		break;
+
+	case WAKEUP_SLEEP_REQUEST:
+		rsi_dbg(INFO_ZONE, "Wakeup/Sleep confirmation.\n");
+		return rsi_handle_ps_confirm(adapter, msg);
+
+	case BG_SCAN_PROBE_REQ:
+		rsi_dbg(INFO_ZONE, "BG scan complete event\n");
+		if (common->bgscan_en) {
+			if (!rsi_send_bgscan_params(common, 0))
+			common->bgscan_en = 0;
+		}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+		info.aborted = false;
+		ieee80211_scan_completed(adapter->hw, &info);
+#else	
+		ieee80211_scan_completed(adapter->hw, false);
+#endif
+		if(common->hw_scan_cancel) {
+			rsi_set_event(&common->cancel_hw_scan_event);
+		}
+		break;
+
 	default:
-		rsi_dbg(INFO_ZONE, "%s: Invalid TA confirm pkt received\n",
-			__func__);
+		rsi_dbg(INFO_ZONE,
+			"%s: Invalid TA confirm type : %x\n",
+			__func__, sub_type);
 		break;
 	}
 	return 0;
+
 out:
-	rsi_dbg(ERR_ZONE, "%s: Unable to send pkt/Invalid frame received\n",
+	rsi_dbg(ERR_ZONE,
+		"%s: Unable to send pkt/Invalid frame received\n",
 		__func__);
 	return -EINVAL;
 }
 
 /**
+ *rsi_handle_card_ready() - This function handles the card ready
+ *                       indication from firmware.
+ *@common: Pointer to the driver private structure.
+ *
+ *Return: 0 on success, -1 on failure.
+ */
+int rsi_handle_card_ready(struct rsi_common *common)
+{
+	switch (common->fsm_state) {
+	case FSM_CARD_NOT_READY:
+		rsi_dbg(INIT_ZONE, "Card ready indication from Common HAL\n");
+		rsi_set_default_parameters(common);
+		if (rsi_send_common_dev_params(common) < 0)
+			return -EINVAL;
+		common->fsm_state = FSM_COMMON_DEV_PARAMS_SENT;
+		break;
+	case FSM_COMMON_DEV_PARAMS_SENT:
+		rsi_dbg(INIT_ZONE, "Common dev config params confirm\n");
+		if (rsi_load_bootup_params(common)) {
+			common->fsm_state = FSM_CARD_NOT_READY;
+			return -EINVAL;
+		}
+		common->fsm_state = FSM_BOOT_PARAMS_SENT;
+		break;
+	default:
+		rsi_dbg(ERR_ZONE,
+			"%s: card ready indication in invalid state %d.\n",
+			__func__, common->fsm_state);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
  * rsi_mgmt_pkt_recv() - This function processes the management packets
- *			 recieved from the hardware.
+ *			 received from the hardware.
  * @common: Pointer to the driver private structure.
  * @msg: Pointer to the received packet.
  *
@@ -1376,37 +2557,330 @@ out:
  */
 int rsi_mgmt_pkt_recv(struct rsi_common *common, u8 *msg)
 {
+	struct rsi_hw *adapter = common->priv;
 	s32 msg_len = (le16_to_cpu(*(__le16 *)&msg[0]) & 0x0fff);
-	u16 msg_type = (msg[2]);
-	int ret;
+	u16 msg_type = msg[2];
+	struct ieee80211_vif *vif = adapter->vifs[adapter->sc_nvifs - 1];
 
-	rsi_dbg(FSM_ZONE, "%s: Msg Len: %d, Msg Type: %4x\n",
-		__func__, msg_len, msg_type);
+	switch (msg_type) {
+	case TA_CONFIRM_TYPE:
+		return rsi_handle_ta_confirm(common, msg);
 
-	if (msg_type == TA_CONFIRM_TYPE) {
-		return rsi_handle_ta_confirm_type(common, msg);
-	} else if (msg_type == CARD_READY_IND) {
-		rsi_dbg(FSM_ZONE, "%s: Card ready indication received\n",
-			__func__);
-		if (common->fsm_state == FSM_CARD_NOT_READY) {
-			rsi_set_default_parameters(common);
+	case CARD_READY_IND:
+		rsi_dbg(INIT_ZONE, "CARD READY INDICATION FROM WLAN.\n");
+		return rsi_handle_card_ready(common);
 
-			ret = rsi_load_bootup_params(common);
-			if (ret)
-				return ret;
-			else
-				common->fsm_state = FSM_BOOT_PARAMS_SENT;
-		} else {
-			return -EINVAL;
-		}
-	} else if (msg_type == TX_STATUS_IND) {
+	case TX_STATUS_IND:
 		if (msg[15] == PROBEREQ_CONFIRM) {
 			common->mgmt_q_block = false;
-			rsi_dbg(FSM_ZONE, "%s: Probe confirm received\n",
-				__func__);
+			rsi_dbg(INFO_ZONE, "Mgmt queue unblocked\n");
+			rsi_set_event(&common->probe_cfm_event);
 		}
+		if ((msg[15] & 0xff) == EAPOL4_CONFIRM) {
+			u8 status = msg[12];
+
+			if (status) {	
+				if(vif->type == NL80211_IFTYPE_STATION) {
+					rsi_dbg(ERR_ZONE, "EAPOL 4 confirm\n");
+					common->start_bgscan = 1;
+					common->eapol4_confirm = 1;
+					if (!rsi_send_block_unblock_frame(common,
+									  false))
+						common->hw_data_qs_blocked = false;
+				}
+			}
+		}
+		break;
+
+	case PS_NOTIFY_IND:
+		rsi_dbg(FSM_ZONE, "Powersave notify indication.\n");
+		break;
+
+	case SLEEP_NOTIFY_IND:
+		rsi_dbg(FSM_ZONE, "Sleep notify indication.\n");
+		break;
+
+	case DECRYPT_ERROR_IND:
+		rsi_dbg(INFO_ZONE, "Error in decrypt.\n");
+		break;
+
+	case DEBUG_IND:
+		rsi_dbg(INFO_ZONE, "Debugging indication.\n");
+		break;
+
+	case RX_MISC_IND:
+		rsi_dbg(INFO_ZONE, "RX misc indication.\n");
+		break;
+
+	case HW_BMISS_EVENT:
+		rsi_dbg(INFO_ZONE, "Hardware beacon miss event\n");
+		rsi_indicate_bcnmiss(common);
+		rsi_resume_conn_channel(common->priv,
+					adapter->vifs[adapter->sc_nvifs - 1]);
+		break;
+
+	case BEACON_EVENT_IND:
+		rsi_dbg(INFO_ZONE, "Beacon event\n");
+		if (!common->init_done)
+			return -1;
+		if (common->iface_down)
+			return -1;
+		if (!common->beacon_enabled)
+			return -1;
+		rsi_send_beacon(common);
+		break;
+
+	case WOWLAN_WAKEUP_REASON:
+		rsi_hex_dump(INFO_ZONE, "WoWLAN Wakeup Trigger Pkt",
+			     msg, msg_len);
+		rsi_dbg(ERR_ZONE, "\n\nWakeup Type: %x\n", msg[15]);
+		switch(msg[15]) {
+		case UNICAST_MAGIC_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for Unicast magic packet ***\n");
+			break;
+		case BROADCAST_MAGICPKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for Broadcast magic packet ***\n");
+			break;
+		case EAPOL_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for GTK renewal ***\n");
+			break;
+		case DISCONNECT_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for Disconnect ***\n");
+			break;
+		case HW_BMISS_PKT:
+			rsi_dbg(ERR_ZONE,
+				"*** Wakeup for HW Beacon miss ***\n");
+			break;
+		default:
+			rsi_dbg(ERR_ZONE,
+				"##### Un-intentional Wakeup #####\n");
+			break;
+		}
+
+	case RX_DOT11_MGMT:
+		return rsi_mgmt_pkt_to_core(common, msg, msg_len);
+
+	default:
+		rsi_dbg(INFO_ZONE, "Cmd Frame Type: %d\n", msg_type);
+		break;
+	}
+
+	return 0;
+}
+
+static void channel_change_event(unsigned long priv)
+{
+	struct rsi_hw *adapter = (struct rsi_hw *)priv;
+	struct rsi_common *common = adapter->priv;
+
+	rsi_set_event(&common->chan_change_event);
+	del_timer(&common->scan_timer);
+}
+
+
+static int init_channel_timer(struct rsi_hw *adapter, u32 timeout)
+{
+	struct rsi_common *common = adapter->priv;
+
+	init_timer(&common->scan_timer);
+	rsi_reset_event(&common->chan_change_event);
+	common->scan_timer.data = (unsigned long)adapter;
+	common->scan_timer.function = (void *)&channel_change_event;
+	common->scan_timer.expires = msecs_to_jiffies(timeout) + jiffies;
+
+	add_timer(&common->scan_timer);
+
+	return 0;
+}
+
+/**
+ * This function prepares Probe request frame and send it to LMAC.
+ * @param  Pointer to Adapter structure.
+ * @param  Type of scan(Active/Passive).
+ * @param  Broadcast probe.
+ * @param  Pointer to the destination address.
+ * @param  Indicates LMAC/UMAC Q number.
+ * @return 0 if success else -1.
+ */
+int rsi_send_probe_request(struct rsi_common *common,
+				struct cfg80211_scan_request *scan_req,
+				u8 n_ssid,
+				u8 channel,
+				u8 scan_type)
+{
+	struct cfg80211_ssid *ssid_info;
+	struct ieee80211_tx_info *info;
+	struct skb_info *tx_params;
+	struct sk_buff *skb = NULL;
+	struct ieee80211_hdr *hdr = NULL;
+	u8 *pos;
+	u32 len = 0;
+	u8 ie_ssid_len;
+	u8 q_num;
+
+	if(common->priv->sc_nvifs <= 0)
+		return 0;	
+	ssid_info = &scan_req->ssids[n_ssid];
+	ie_ssid_len = ssid_info->ssid_len + 2 ;
+	len = (MIN_802_11_HDR_LEN + scan_req->ie_len + ie_ssid_len);
+
+	if (scan_type == 0) {
+		skb = dev_alloc_skb(len);
+		if (!skb) {
+			rsi_dbg(ERR_ZONE, "%s: Failed to alloc skb\n", __func__);
+			return -ENOMEM;
+		}
+		skb_put(skb, len);
+		memset(skb->data,0,skb->len);
+		pos = skb->data;
+		/*
+		 * prreq frame format
+		 * ssid
+		 * supported rates
+		 * RSN (optional)
+		 * extended supported rates
+		 * WPA (optional)
+		 * user-specified ie's
+		 */
+		hdr = (struct ieee80211_hdr *)skb->data;
 	} else {
-		return rsi_mgmt_pkt_to_core(common, msg, msg_len, msg_type);
+		pos = common->bgscan_probe_req;
+		hdr = (struct ieee80211_hdr *)common->bgscan_probe_req; 
+	}
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | 
+					 IEEE80211_STYPE_PROBE_REQ);
+	hdr->duration_id = 0x0;
+	memset(hdr->addr1, 0xff, ETH_ALEN);
+	memset(hdr->addr3, 0xFF, 6);
+	memcpy(hdr->addr2, common->mac_addr, ETH_ALEN);
+	hdr->seq_ctrl = 0x00;
+	pos += MIN_802_11_HDR_LEN; 
+
+	*pos++ = WLAN_EID_SSID;
+        *pos++ = ssid_info->ssid_len;
+
+	/* Check for hidden ssid case */
+	if (ssid_info->ssid_len) {
+                memcpy(pos, ssid_info->ssid, ssid_info->ssid_len);
+	}
+        pos += ssid_info->ssid_len;
+
+        if (scan_req->ie_len) {
+                memcpy(pos, scan_req->ie, scan_req->ie_len);
+	}
+       
+	if (scan_type == 1) {
+		common->bgscan_probe_req_len = len;	
+		return 0;
 	}
+
+	if ((common->iface_down == true) || (!common->scan_in_prog))
+		goto out;
+
+	info = IEEE80211_SKB_CB(skb);
+	tx_params = (struct skb_info *)info->driver_data;
+	tx_params->internal_hdr_size = skb_headroom(skb);
+	info->control.vif = common->priv->vifs[0];	
+	q_num = MGMT_SOFT_Q;
+	skb->priority = q_num;
+
+	rsi_prepare_mgmt_desc(common,skb);
+	skb_queue_tail(&common->tx_queue[MGMT_SOFT_Q], skb);
+	rsi_set_event(&common->tx_thread.event);
+	
 	return 0;
+
+out:
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+void rsi_scan_start(struct work_struct *work)
+{
+	struct ieee80211_channel *cur_chan = NULL;
+	struct cfg80211_scan_request *scan_req = NULL;
+	struct rsi_common *common =
+		container_of(work, struct rsi_common ,scan_work);
+	u8 ii, jj;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	struct cfg80211_scan_info info;
+#endif
+	
+	scan_req = common->scan_request;
+
+	common->scan_in_prog = true;
+	
+	for (ii =0; ii < scan_req->n_channels ; ii++) {
+		if (common->iface_down)
+			break;
+		
+		if(!common->scan_in_prog)
+			break;
+		rsi_dbg(INFO_ZONE,
+			"channle no: %d", scan_req->channels[ii]->hw_value);
+		rsi_band_check(common, scan_req->channels[ii]);
+		cur_chan = scan_req->channels[ii];
+		if (cur_chan->flags & IEEE80211_CHAN_DISABLED)
+			continue;
+
+		/* maxdwell time macro */
+		init_channel_timer(common->priv, 300);
+				 
+		if (rsi_set_channel(common, cur_chan)) {
+			rsi_dbg(ERR_ZONE, "Failed to set the channel\n");
+			break;
+		}
+		rsi_reset_event(&common->chan_set_event);
+		rsi_wait_event(&common->chan_set_event, msecs_to_jiffies(50));
+		
+		if(!common->scan_in_prog)
+			break;
+		rsi_reset_event(&common->chan_set_event);
+
+		if ((cur_chan->flags & IEEE80211_CHAN_NO_IR) ||
+		    (cur_chan->flags & IEEE80211_CHAN_RADAR)) {
+			/* DFS Channel */
+			/* Program passive scan duration */
+		} else {
+			/* Send probe request */
+			for (jj = 0;jj < scan_req->n_ssids;jj++) {
+				rsi_send_probe_request(common, 
+						       scan_req,
+						       jj,
+						       cur_chan->hw_value,
+						       0);
+				if (common->iface_down == true)
+					return;
+				rsi_reset_event(&common->probe_cfm_event);
+				rsi_wait_event(&common->probe_cfm_event,
+					       msecs_to_jiffies(50));
+				rsi_reset_event(&common->probe_cfm_event);
+			}
+		}
+		if(!common->scan_in_prog)
+			break;
+		if (common->iface_down)
+			break;
+		rsi_wait_event(&common->chan_change_event, EVENT_WAIT_FOREVER);
+		rsi_reset_event(&common->chan_change_event);
+	}
+
+	del_timer(&common->scan_timer);
+	common->scan_in_prog = false;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0))
+	info.aborted = false;
+	ieee80211_scan_completed(common->priv->hw, &info);
+#else	
+	ieee80211_scan_completed(common->priv->hw, false);
+#endif
+	if(common->hw_scan_cancel) {	
+		skb_queue_purge(&common->tx_queue[MGMT_SOFT_Q]);
+		rsi_set_event(&common->cancel_hw_scan_event);
+	}	
+	return ;
 }
+
diff --git a/drivers/net/wireless/rsi/rsi_91x_ps.c b/drivers/net/wireless/rsi/rsi_91x_ps.c
new file mode 100644
index 0000000..15d3ee4
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_91x_ps.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/version.h>
+#include "rsi_debugfs.h"
+#include "rsi_mgmt.h"
+#include "rsi_common.h"
+#include "rsi_ps.h"
+
+/**
+ * str_psstate() - return the ps state in string format.
+ *
+ * @state - PS state.
+ *
+ * return: PS state in string format.
+ */
+char *str_psstate(enum ps_state state)
+{
+	switch (state) {
+	case PS_NONE:
+		return "PS_NONE";
+	case PS_DISABLE_REQ_SENT:
+		return "PS_DISABLE_REQ_SENT";
+	case PS_ENABLE_REQ_SENT:
+		return "PS_ENABLE_REQ_SENT";
+	case PS_ENABLED:
+		return "PS_ENABLED";
+	default:
+		return "INVALID_STATE";
+	}
+	return "INVALID_STATE";
+}
+
+/**
+ * rsi_modify_ps_state() - Modify PS state to a new state.
+ *
+ * @adapter: pointer to rsi_hw structure.
+ * @nstate: new PS state.
+ *
+ * return: new state.
+ */
+static inline void rsi_modify_ps_state(struct rsi_hw *adapter,
+				       enum ps_state nstate)
+{
+	rsi_dbg(INFO_ZONE, "PS state changed %s => %s\n",
+		str_psstate(adapter->ps_state),
+		str_psstate(nstate));
+
+	adapter->ps_state = nstate;
+}
+
+/**
+ * rsi_default_ps_params() - Initalization of default powersave parameters.
+ *
+ * @adapter: pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_default_ps_params(struct rsi_hw *adapter)
+{
+	struct rsi_ps_info *ps_info = &adapter->ps_info;
+
+	ps_info->enabled = true;
+	ps_info->sleep_type = 1; /* LP */
+	ps_info->tx_threshold = 0;
+	ps_info->rx_threshold = 0;
+	ps_info->tx_hysterisis = 0;
+	ps_info->rx_hysterisis = 0;
+	ps_info->monitor_interval = 0;
+	ps_info->listen_interval = 2 * 100;
+	ps_info->num_bcns_per_lis_int = 0;
+	ps_info->dtim_interval_duration = 0;
+	ps_info->num_dtims_per_sleep = 0;
+	ps_info->deep_sleep_wakeup_period = 200;
+}
+EXPORT_SYMBOL_GPL(rsi_default_ps_params);
+
+/**
+ * rsi_enable_ps() - enable power save
+ *
+ * @adapter: Pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_enable_ps(struct rsi_hw *adapter)
+{
+	if (adapter->ps_state != PS_NONE) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Cannot accept enable PS in %s state\n",
+			__func__, str_psstate(adapter->ps_state));
+		return;
+	}
+
+	if (rsi_send_ps_request(adapter, true)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+		return;
+	}
+
+	rsi_modify_ps_state(adapter, PS_ENABLE_REQ_SENT);
+}
+
+/**
+ * rsi_disable_ps() - disable power save
+ *
+ * @adapter: Pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_disable_ps(struct rsi_hw *adapter)
+{
+	if (adapter->ps_state != PS_ENABLED) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Cannot accept disable PS in %s state\n",
+			__func__, str_psstate(adapter->ps_state));
+		return;
+	}
+
+	if (rsi_send_ps_request(adapter, false)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+		return;
+	}
+
+	rsi_modify_ps_state(adapter, PS_DISABLE_REQ_SENT);
+}
+
+/**
+ * rsi_conf_uapsd() - configures UAPSD powersave.
+ *
+ * @adapter - Pointer to rsi_hw structure.
+ *
+ * return: void.
+ */
+void rsi_conf_uapsd(struct rsi_hw *adapter)
+{
+	if (adapter->ps_state != PS_ENABLED)
+		return;
+
+	if (rsi_send_ps_request(adapter, false)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+		return;
+	}
+
+	if (rsi_send_ps_request(adapter, true)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to send PS request to device\n",
+			__func__);
+	}
+}
+
+/**
+ * rsi_handle_ps_confirm() - Processes powersave confirmation.
+ *
+ * @adapter - Pointer to rsi_hw structure.
+ * @msg - Recevied buffer.
+ *
+ * return: 0 on success.
+ */
+int rsi_handle_ps_confirm(struct rsi_hw *adapter, u8 *msg)
+{
+	u16 cfm_type = 0;
+
+	cfm_type = *(u16 *)&msg[PS_CONFIRM_INDEX];
+
+	switch (cfm_type) {
+	case SLEEP_REQUEST:
+		if (adapter->ps_state == PS_ENABLE_REQ_SENT)
+			rsi_modify_ps_state(adapter, PS_ENABLED);
+		break;
+	case WAKEUP_REQUEST:
+		if (adapter->ps_state == PS_DISABLE_REQ_SENT)
+			rsi_modify_ps_state(adapter, PS_NONE);
+		break;
+	default:
+		rsi_dbg(ERR_ZONE,
+			"Invalid PS confirm type %x in state %s\n",
+			cfm_type, str_psstate(adapter->ps_state));
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/rsi/rsi_91x_sdio.c b/drivers/net/wireless/rsi/rsi_91x_sdio.c
index 8428858..f75f568 100644
--- a/drivers/net/wireless/rsi/rsi_91x_sdio.c
+++ b/drivers/net/wireless/rsi/rsi_91x_sdio.c
@@ -1,23 +1,51 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/module.h>
 #include "rsi_sdio.h"
 #include "rsi_common.h"
+#include "rsi_hal.h"
+
+/* Default operating mode is Wi-Fi alone */
+u16 dev_oper_mode = DEV_OPMODE_WIFI_ALONE;
+module_param(dev_oper_mode, ushort, S_IRUGO);
+MODULE_PARM_DESC(dev_oper_mode,
+		 "1 -	Wi-Fi Alone \
+		  4 -	BT Alone \
+		  8 -	BT LE Alone \
+		  5 -	Wi-Fi STA + BT classic \
+		  9 -	Wi-Fi STA + BT LE \
+		  13 -	Wi-Fi STA + BT classic + BT LE \
+		  6 -	AP + BT classic \
+		  14 -	AP + BT classic + BT LE");
+
 
 /**
  * rsi_sdio_set_cmd52_arg() - This function prepares cmd 52 read/write arg.
@@ -127,8 +155,13 @@ static int rsi_issue_sdiocommand(struct sdio_func *func,
 	return err;
 }
 
+static void rsi_dummy_isr(struct sdio_func *function)
+{
+	return;
+}
+
 /**
- * rsi_handle_interrupt() - This function is called upon the occurence
+ * rsi_handle_interrupt() - This function is called upon the occurrence
  *			    of an interrupt.
  * @function: Pointer to the sdio_func structure.
  *
@@ -137,10 +170,118 @@ static int rsi_issue_sdiocommand(struct sdio_func *func,
 static void rsi_handle_interrupt(struct sdio_func *function)
 {
 	struct rsi_hw *adapter = sdio_get_drvdata(function);
+	struct rsi_91x_sdiodev *dev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 
-	sdio_release_host(function);
+	dev->sdio_irq_task = current;
 	rsi_interrupt_handler(adapter);
-	sdio_claim_host(function);
+	dev->sdio_irq_task = NULL;
+}
+
+void rsi_gspi_init(struct rsi_hw *adapter)
+{
+	unsigned long gspi_ctrl_reg0_val;
+	
+	/* Programming gspi frequency = soc_frequency / 2 */
+	/* Warning : ULP seemed to be not working
+	 * well at high frequencies. Modify accordingly */
+	gspi_ctrl_reg0_val = 0x4;
+	/* csb_setup_time [5:4] */
+	gspi_ctrl_reg0_val |= 0x10; 
+	/* csb_hold_time [7:6] */
+	gspi_ctrl_reg0_val |= 0x40; 
+	/* csb_high_time [9:8] */
+	gspi_ctrl_reg0_val |= 0x100; 
+	/* spi_mode [10] */
+	gspi_ctrl_reg0_val |= 0x000; 
+	/* clock_phase [11] */
+	gspi_ctrl_reg0_val |= 0x000; 
+	/* Initializing GSPI for ULP read/writes */
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_CTRL_REG0,
+				  gspi_ctrl_reg0_val,
+				  2);
+}
+
+void ulp_read_write(struct rsi_hw *adapter, u16 addr, u16 *data, u16 len_in_bits)
+{
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_DATA_REG1,
+				  ((addr << 6) | (data[1] & 0x3f)),
+				  2);
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_DATA_REG0,
+				  *(u16 *)&data[0],
+				  2);
+	rsi_gspi_init(adapter);
+	rsi_sdio_master_reg_write(adapter,
+				  GSPI_CTRL_REG1,
+				  ((len_in_bits - 1) | GSPI_TRIG),
+				  2);
+	msleep(10);
+}
+
+static void rsi_reset_chip(struct rsi_hw *adapter)
+{
+	u16 temp[4] = {0};
+	u32 data;
+	u8 sdio_interrupt_status = 0;
+	u8 request = 1;
+
+	rsi_dbg(INFO_ZONE, "Writing disable to wakeup register\n");
+	if (rsi_sdio_write_register(adapter,
+				0,
+				    SDIO_WAKEUP_REG,
+				    &request) < 0) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Failed to Write SDIO WAKEUP REG\n", __func__);
+		return;
+	}
+	msleep(3);
+	if (rsi_sdio_read_register(adapter,
+				   RSI_FN1_INT_REGISTER,
+				   &sdio_interrupt_status) < 0) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to Read Intr Status Register\n",
+			__func__);
+		return;
+	}
+	rsi_dbg(INFO_ZONE, "%s: Intr Status Register value = %d \n",
+		__func__, sdio_interrupt_status);
+
+	/* Put TA on hold */
+	if (rsi_sdio_master_access_msword(adapter, 0x2200)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to set ms word to common reg\n",
+			__func__);
+		return ;
+	}
+
+	data = TA_HOLD_THREAD_VALUE;
+	if (rsi_sdio_write_register_multiple(adapter,
+					TA_HOLD_THREAD_REG | SD_REQUEST_MASTER,
+					(u8 *)&data,
+					4)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to hold TA threads\n", __func__);
+		return ;
+	}
+
+	/* This msleep will ensure TA processor to go to hold and any pending dma
+	 * transfers to rf spi in device to finish */
+	msleep(100);
+
+	*(u32 *)temp = 0;
+	ulp_read_write(adapter, ULP_RESET_REG, temp, 32);
+	*(u32 *)temp = 2;
+	ulp_read_write(adapter, WATCH_DOG_TIMER_1, temp, 32);
+	*(u32 *)temp = 0;
+	ulp_read_write(adapter, WATCH_DOG_TIMER_2, temp, 32);
+	*(u32 *)temp = 50;
+	ulp_read_write(adapter, WATCH_DOG_DELAY_TIMER_1, temp, 32);
+	*(u32 *)temp = 0;
+	ulp_read_write(adapter, WATCH_DOG_DELAY_TIMER_2, temp, 32);
+	*(u32 *)temp = ((0xaa000) | RESTART_WDT | BYPASS_ULP_ON_WDT);
+	ulp_read_write(adapter, WATCH_DOG_TIMER_ENABLE, temp, 32);
+	msleep(1000);
 }
 
 /**
@@ -151,28 +292,34 @@ static void rsi_handle_interrupt(struct sdio_func *function)
  */
 static void rsi_reset_card(struct sdio_func *pfunction)
 {
-	int ret = 0;
 	int err;
 	struct mmc_card *card = pfunction->card;
 	struct mmc_host *host = card->host;
 	s32 bit = (fls(host->ocr_avail) - 1);
-	u8 cmd52_resp;
+	u8 cmd52_resp = 0;
 	u32 clock, resp, i;
 	u16 rca;
+	u32 cmd_delay = 0;
 
+#ifdef CONFIG_CARACALLA_BOARD
 	/* Reset 9110 chip */
-	ret = rsi_cmd52writebyte(pfunction->card,
+	err = rsi_cmd52writebyte(pfunction->card,
 				 SDIO_CCCR_ABORT,
 				 (1 << 3));
 
 	/* Card will not send any response as it is getting reset immediately
 	 * Hence expect a timeout status from host controller
 	 */
-	if (ret != -ETIMEDOUT)
-		rsi_dbg(ERR_ZONE, "%s: Reset failed : %d\n", __func__, ret);
+	if (err != -ETIMEDOUT)
+		rsi_dbg(ERR_ZONE, "%s: Reset failed : %d\n", __func__, err);
+
+	cmd_delay = 20;
+#else
+	cmd_delay = 2;
+#endif
 
 	/* Wait for few milli seconds to get rid of residue charges if any */
-	msleep(20);
+	msleep(cmd_delay);
 
 	/* Initialize the SDIO card */
 	host->ios.vdd = bit;
@@ -187,7 +334,7 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 	 * This delay should be sufficient to allow the power supply
 	 * to reach the minimum voltage.
 	 */
-	msleep(20);
+	msleep(cmd_delay);
 
 	host->ios.clock = host->f_min;
 	host->ios.power_mode = MMC_POWER_ON;
@@ -197,12 +344,12 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 	 * This delay must be at least 74 clock sizes, or 1 ms, or the
 	 * time required to reach a stable voltage.
 	 */
-	msleep(20);
+	msleep(cmd_delay);
 
 	/* Issue CMD0. Goto idle state */
 	host->ios.chip_select = MMC_CS_HIGH;
 	host->ops->set_ios(host, &host->ios);
-	msleep(20);
+	msleep(cmd_delay);
 	err = rsi_issue_sdiocommand(pfunction,
 				    MMC_GO_IDLE_STATE,
 				    0,
@@ -210,13 +357,17 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 				    NULL);
 	host->ios.chip_select = MMC_CS_DONTCARE;
 	host->ops->set_ios(host, &host->ios);
-	msleep(20);
+	msleep(cmd_delay);
 	host->use_spi_crc = 0;
 
 	if (err)
 		rsi_dbg(ERR_ZONE, "%s: CMD0 failed : %d\n", __func__, err);
 
+#ifdef CONFIG_CARACALLA_BOARD
 	if (!host->ocr_avail) {
+#else
+	if (1) {
+#endif
 		/* Issue CMD5, arg = 0 */
 		err = rsi_issue_sdiocommand(pfunction,
 					    SD_IO_SEND_OP_COND,
@@ -226,14 +377,22 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 		if (err)
 			rsi_dbg(ERR_ZONE, "%s: CMD5 failed : %d\n",
 				__func__, err);
+#ifdef CONFIG_CARACALLA_BOARD
 		host->ocr_avail = resp;
+#else
+		card->ocr = resp;
+#endif
 	}
 
 	/* Issue CMD5, arg = ocr. Wait till card is ready  */
 	for (i = 0; i < 100; i++) {
 		err = rsi_issue_sdiocommand(pfunction,
 					    SD_IO_SEND_OP_COND,
+#ifdef CONFIG_CARACALLA_BOARD
 					    host->ocr_avail,
+#else
+					    card->ocr,
+#endif
 					    (MMC_RSP_R4 | MMC_CMD_BCR),
 					    &resp);
 		if (err) {
@@ -244,7 +403,7 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 
 		if (resp & MMC_CARD_BUSY)
 			break;
-		msleep(20);
+		msleep(cmd_delay);
 	}
 
 	if ((i == 100) || (err)) {
@@ -326,6 +485,7 @@ static void rsi_reset_card(struct sdio_func *pfunction)
 		host->ios.bus_width = MMC_BUS_WIDTH_4;
 		host->ops->set_ios(host, &host->ios);
 	}
+	mdelay(cmd_delay);
 }
 
 /**
@@ -361,6 +521,7 @@ static int rsi_setblocklength(struct rsi_hw *adapter, u32 length)
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 	int status;
+
 	rsi_dbg(INIT_ZONE, "%s: Setting the block length\n", __func__);
 
 	status = sdio_set_block_size(dev->pfunction, length);
@@ -386,6 +547,7 @@ static int rsi_setupcard(struct rsi_hw *adapter)
 	rsi_setclock(adapter, 50000);
 
 	dev->tx_blk_size = 256;
+	adapter->tx_blk_size = dev->tx_blk_size;
 	status = rsi_setblocklength(adapter, dev->tx_blk_size);
 	if (status)
 		rsi_dbg(ERR_ZONE,
@@ -411,14 +573,16 @@ int rsi_sdio_read_register(struct rsi_hw *adapter,
 	u8 fun_num = 0;
 	int status;
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	if (fun_num == 0)
 		*data = sdio_f0_readb(dev->pfunction, addr, &status);
 	else
 		*data = sdio_readb(dev->pfunction, addr, &status);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	return status;
 }
@@ -442,14 +606,16 @@ int rsi_sdio_write_register(struct rsi_hw *adapter,
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 	int status = 0;
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	if (function == 0)
 		sdio_f0_writeb(dev->pfunction, *data, addr, &status);
 	else
 		sdio_writeb(dev->pfunction, *data, addr, &status);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	return status;
 }
@@ -464,17 +630,16 @@ int rsi_sdio_write_register(struct rsi_hw *adapter,
 void rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit)
 {
 	int status;
+
 	status = rsi_sdio_write_register(adapter,
 					 1,
 					 (SDIO_FUN1_INTR_CLR_REG |
-					  RSI_SD_REQUEST_MASTER),
+					  SD_REQUEST_MASTER),
 					 &int_bit);
 	if (status)
 		rsi_dbg(ERR_ZONE, "%s: unable to send ack\n", __func__);
 }
 
-
-
 /**
  * rsi_sdio_read_register_multiple() - This function read multiple bytes of
  *				       information from the SD card.
@@ -485,20 +650,22 @@ void rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit)
  *
  * Return: 0 on success, -1 on failure.
  */
-static int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,
-					   u32 addr,
-					   u32 count,
-					   u8 *data)
+int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,
+				    u32 addr,
+				    u8 *data,
+				    u16 count)
 {
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
-	u32 status;
+	u32 status = 0;
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	status =  sdio_readsb(dev->pfunction, data, addr, count);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	if (status != 0)
 		rsi_dbg(ERR_ZONE, "%s: Synch Cmd53 read failed\n", __func__);
@@ -518,7 +685,7 @@ static int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,
 int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
 				     u32 addr,
 				     u8 *data,
-				     u32 count)
+				     u16 count)
 {
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
@@ -536,11 +703,13 @@ int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
 		dev->write_fail++;
 	}
 
-	sdio_claim_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_claim_host(dev->pfunction);
 
 	status = sdio_writesb(dev->pfunction, addr, data, count);
 
-	sdio_release_host(dev->pfunction);
+	if (likely(dev->sdio_irq_task != current))
+		sdio_release_host(dev->pfunction);
 
 	if (status) {
 		rsi_dbg(ERR_ZONE, "%s: Synch Cmd53 write failed %d\n",
@@ -552,6 +721,176 @@ int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
 	return status;
 }
 
+int rsi_sdio_load_data_master_write(struct rsi_hw *adapter,
+				    u32 base_address,
+				    u32 instructions_sz,
+				    u16 block_size,
+				    u8 *ta_firmware)
+{
+	u32 num_blocks;
+	u16 msb_address;
+	u32 offset, ii;
+	u8 temp_buf[block_size];
+	u16 lsb_address;
+
+	num_blocks = instructions_sz / block_size;
+	msb_address = base_address >> 16;
+
+	rsi_dbg(INFO_ZONE, "ins_size: %d\n", instructions_sz);
+	rsi_dbg(INFO_ZONE, "num_blocks: %d\n", num_blocks);
+
+	/* Loading DM ms word in the sdio slave */
+	if (rsi_sdio_master_access_msword(adapter, msb_address)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to set ms word reg\n", __func__);
+		return -EIO;
+	}
+
+	for (offset = 0, ii = 0; ii < num_blocks; ii++, offset += block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf, ta_firmware + offset, block_size);
+		lsb_address = (u16)base_address;
+		if (rsi_sdio_write_register_multiple(adapter,
+					lsb_address | SD_REQUEST_MASTER,
+					temp_buf, block_size)) {
+			rsi_dbg(ERR_ZONE, "%s: failed to write\n", __func__);
+			return -EIO;
+		}
+		rsi_dbg(INFO_ZONE, "%s: loading block: %d\n", __func__, ii);
+		base_address += block_size;
+
+		if ((base_address >> 16) != msb_address) {
+			msb_address += 1;
+
+			/* Loading DM ms word in the sdio slave */
+			if (rsi_sdio_master_access_msword(adapter,
+							  msb_address)) {
+				rsi_dbg(ERR_ZONE,
+					"%s: Unable to set ms word reg\n",
+					__func__);
+				return -EIO;
+			}
+		}
+	}
+
+	if (instructions_sz % block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf,
+		       ta_firmware + offset,
+		       instructions_sz % block_size);
+		lsb_address = (u16)base_address;
+		if (rsi_sdio_write_register_multiple(adapter,
+						lsb_address | SD_REQUEST_MASTER,
+						temp_buf,
+						instructions_sz % block_size)) {
+			return -EIO;
+		}
+		rsi_dbg(INFO_ZONE,
+			"Written Last Block in Address 0x%x Successfully\n",
+			offset | SD_REQUEST_MASTER);
+	}
+	return 0;
+}
+
+int rsi_sdio_master_reg_read(struct rsi_hw *adapter, u32 addr,
+			     u32 *read_buf, u16 size)
+{
+	u32 *data = NULL;
+	u16 ms_addr = 0;
+	u32 align[2] = {};
+	u32 addr_on_bus;
+
+	data = PTR_ALIGN(&align[0], 8);
+
+	ms_addr = (addr >> 16);
+	if (rsi_sdio_master_access_msword(adapter, ms_addr)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to set ms word to common reg\n",
+			__func__);
+		return -EIO;
+	}
+	addr = addr & 0xFFFF;
+
+	addr_on_bus = (addr & 0xFF000000);
+	if ((addr_on_bus == (FLASH_SIZE_ADDR & 0xFF000000)) ||
+	    (addr_on_bus == 0x0)) {
+		addr_on_bus = (addr & ~(0x3));
+	} else
+		addr_on_bus = addr;
+
+	/* Bring TA out of reset */
+	if (rsi_sdio_read_register_multiple(adapter,
+					    (addr_on_bus | SD_REQUEST_MASTER),
+					    (u8 *)data, 4)) {
+		rsi_dbg(ERR_ZONE, "%s: AHB register read failed\n", __func__);
+		return -EIO;
+	}
+	if (size == 2) {
+		if ((addr & 0x3) == 0)
+			*read_buf = *data;
+		else
+			*read_buf  = (*data >> 16);
+		*read_buf = (*read_buf & 0xFFFF);
+	} else if (size == 1) {
+		if ((addr & 0x3) == 0)
+			*read_buf = *data;
+		else if ((addr & 0x3) == 1)
+			*read_buf = (*data >> 8);
+		else if ((addr & 0x3) == 2)
+			*read_buf = (*data >> 16);
+		else
+			*read_buf = (*data >> 24);
+		*read_buf = (*read_buf & 0xFF);
+	} else { /*size is 4 */
+		*read_buf = *data;
+	}
+
+	return 0;
+}
+
+int rsi_sdio_master_reg_write(struct rsi_hw *adapter,
+			      unsigned long addr,
+			      unsigned long data,
+			      u16 size)
+{
+	unsigned long data1[2];
+	unsigned long *data_aligned;
+
+	data_aligned = PTR_ALIGN(&data1[0], 8);
+
+	if (size == 2) {
+		*data_aligned = ((data << 16) | (data & 0xFFFF));
+	} else if (size == 1) {
+		u32 temp_data;
+
+		temp_data = (data & 0xFF);
+		*data_aligned = ((temp_data << 24) |
+				  (temp_data << 16) |
+				  (temp_data << 8) |
+				  (temp_data));
+	} else {
+		*data_aligned = data;
+	}
+	size = 4;
+
+	if (rsi_sdio_master_access_msword(adapter, (addr >> 16))) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to set ms word to common reg\n",
+			__func__);
+		return -EIO;
+	}
+	addr = addr & 0xFFFF;
+
+	/* Bring TA out of reset */
+	if (rsi_sdio_write_register_multiple(adapter,
+					     (addr | SD_REQUEST_MASTER),
+					     (u8 *)data_aligned, size)) {
+		rsi_dbg(ERR_ZONE,
+			"%s: Unable to do AHB reg write\n", __func__);
+		return -EIO;
+	}
+	return 0;
+}
+
 /**
  * rsi_sdio_host_intf_write_pkt() - This function writes the packet to device.
  * @adapter: Pointer to the adapter structure.
@@ -560,9 +899,9 @@ int rsi_sdio_write_register_multiple(struct rsi_hw *adapter,
  *
  * Return: 0 on success, -1 on failure.
  */
-static int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
-					u8 *pkt,
-					u32 len)
+int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
+				 u8 *pkt,
+				 u32 len)
 {
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
@@ -572,6 +911,8 @@ static int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
 	int status;
 
 	queueno = ((pkt[1] >> 4) & 0xf);
+	if (queueno == RSI_BT_DATA_Q)
+		queueno = RSI_BT_Q;
 
 	num_blocks = len / block_size;
 
@@ -583,9 +924,9 @@ static int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,
 
 	status = rsi_sdio_write_register_multiple(adapter,
 						  address,
-						  (u8 *)pkt,
+						  pkt,
 						  length);
-	if (status)
+	if (status < 0)
 		rsi_dbg(ERR_ZONE, "%s: Unable to write onto the card: %d\n",
 			__func__, status);
 	rsi_dbg(DATA_TX_ZONE, "%s: Successfully written onto card\n", __func__);
@@ -614,8 +955,8 @@ int rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter,
 
 	status = rsi_sdio_read_register_multiple(adapter,
 						 length,
-						 length, /*num of bytes*/
-						 (u8 *)pkt);
+						 (u8 *)pkt,
+						 length);
 
 	if (status)
 		rsi_dbg(ERR_ZONE, "%s: Failed to read frame: %d\n", __func__,
@@ -643,6 +984,7 @@ static int rsi_init_sdio_interface(struct rsi_hw *adapter,
 		return status;
 
 	adapter->rsi_dev = rsi_91x_dev;
+	rsi_91x_dev->sdio_irq_task = NULL;
 
 	sdio_claim_host(pfunction);
 
@@ -667,7 +1009,7 @@ static int rsi_init_sdio_interface(struct rsi_hw *adapter,
 		goto fail;
 	}
 
-	rsi_dbg(INIT_ZONE, "%s: Setup card succesfully\n", __func__);
+	rsi_dbg(INIT_ZONE, "%s: Setup card successfully\n", __func__);
 
 	status = rsi_init_sdio_slave_regs(adapter);
 	if (status) {
@@ -676,11 +1018,11 @@ static int rsi_init_sdio_interface(struct rsi_hw *adapter,
 	}
 	sdio_release_host(pfunction);
 
-	adapter->host_intf_write_pkt = rsi_sdio_host_intf_write_pkt;
-	adapter->host_intf_read_pkt = rsi_sdio_host_intf_read_pkt;
 	adapter->determine_event_timeout = rsi_sdio_determine_event_timeout;
 	adapter->check_hw_queue_status = rsi_sdio_read_buffer_status_register;
-
+	adapter->process_isr_hci = rsi_interrupt_handler;
+	adapter->check_intr_status_reg = rsi_read_intr_status_reg;
+	
 #ifdef CONFIG_RSI_DEBUGFS
 	adapter->num_debugfs_entries = MAX_DEBUGFS_ENTRIES;
 #endif
@@ -691,6 +1033,17 @@ fail:
 	return status;
 }
 
+static struct rsi_host_intf_ops sdio_host_intf_ops = {
+	.write_pkt		= rsi_sdio_host_intf_write_pkt,
+	.read_pkt		= rsi_sdio_host_intf_read_pkt,
+	.master_access_msword	= rsi_sdio_master_access_msword,
+	.master_reg_read	= rsi_sdio_master_reg_read,
+	.master_reg_write	= rsi_sdio_master_reg_write,
+	.read_reg_multiple	= rsi_sdio_read_register_multiple,
+	.write_reg_multiple	= rsi_sdio_write_register_multiple,
+	.load_data_master_write	= rsi_sdio_load_data_master_write,
+};
+
 /**
  * rsi_probe() - This function is called by kernel when the driver provided
  *		 Vendor and device IDs are matched. All the initialization
@@ -713,33 +1066,60 @@ static int rsi_probe(struct sdio_func *pfunction,
 			__func__);
 		return 1;
 	}
+	adapter->rsi_host_intf = RSI_HOST_INTF_SDIO;
+	adapter->host_intf_ops = &sdio_host_intf_ops;
+	adapter->priv->oper_mode = dev_oper_mode;
 
 	if (rsi_init_sdio_interface(adapter, pfunction)) {
 		rsi_dbg(ERR_ZONE, "%s: Failed to init sdio interface\n",
 			__func__);
 		goto fail;
 	}
+#ifdef CONFIG_SDIO_INTR_POLL
+	init_sdio_intr_status_poll_thread(adapter->priv);
+#endif
+	sdio_claim_host(pfunction);
+//	if (sdio_claim_irq(pfunction, rsi_handle_interrupt)) {
+	if (sdio_claim_irq(pfunction, rsi_dummy_isr)) {
+		rsi_dbg(ERR_ZONE, "%s: Failed to request IRQ\n", __func__);
+		sdio_release_host(pfunction);
+		goto fail;
+	}
+	sdio_release_host(pfunction);
+	rsi_dbg(INIT_ZONE, "%s: Registered Interrupt handler\n", __func__);
 
-	if (rsi_sdio_device_init(adapter->priv)) {
+	if (rsi_hal_device_init(adapter)) {
 		rsi_dbg(ERR_ZONE, "%s: Failed in device init\n", __func__);
 		sdio_claim_host(pfunction);
+		sdio_release_irq(pfunction);
 		sdio_disable_func(pfunction);
 		sdio_release_host(pfunction);
 		goto fail;
 	}
+	rsi_dbg(INFO_ZONE, "===> RSI Device Init Done <===\n");
+
+	if (rsi_sdio_master_access_msword(adapter, MISC_CFG_BASE_ADDR)) {
+		rsi_dbg(ERR_ZONE, "%s: Unable to set ms word reg\n", __func__);
+		return -EIO;
+	}
+	rsi_dbg(INIT_ZONE, "%s: Setting ms word to 0x41050000\n", __func__);
 
 	sdio_claim_host(pfunction);
+	sdio_release_irq(pfunction);
+	mdelay(10);
 	if (sdio_claim_irq(pfunction, rsi_handle_interrupt)) {
 		rsi_dbg(ERR_ZONE, "%s: Failed to request IRQ\n", __func__);
 		sdio_release_host(pfunction);
 		goto fail;
 	}
-
 	sdio_release_host(pfunction);
-	rsi_dbg(INIT_ZONE, "%s: Registered Interrupt handler\n", __func__);
 
 	return 0;
+
 fail:
+#ifdef CONFIG_SDIO_INTR_POLL
+	rsi_kill_thread(&adapter->priv->sdio_intr_poll_thread);
+#endif
 	rsi_91x_deinit(adapter);
 	rsi_dbg(ERR_ZONE, "%s: Failed in probe...Exiting\n", __func__);
 	return 1;
@@ -761,34 +1141,193 @@ static void rsi_disconnect(struct sdio_func *pfunction)
 
 	dev = (struct rsi_91x_sdiodev *)adapter->rsi_dev;
 
-	dev->write_fail = 2;
-	rsi_mac80211_detach(adapter);
-
+#ifdef CONFIG_SDIO_INTR_POLL
+	rsi_kill_thread(&adapter->priv->sdio_intr_poll_thread);
+#endif
 	sdio_claim_host(pfunction);
 	sdio_release_irq(pfunction);
-	sdio_disable_func(pfunction);
-	rsi_91x_deinit(adapter);
+	sdio_release_host(pfunction);
+	mdelay(10);
+
+	rsi_mac80211_detach(adapter);
+	mdelay(10);
+
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	rsi_hci_detach(adapter->priv);
+	mdelay(10);
+#endif
+
+	/* Reset Chip */
+	rsi_reset_chip(adapter);
+
 	/* Resetting to take care of the case, where-in driver is re-loaded */
+	sdio_claim_host(pfunction);
 	rsi_reset_card(pfunction);
+	sdio_disable_func(pfunction);
 	sdio_release_host(pfunction);
+	dev->write_fail = 2;
+	rsi_91x_deinit(adapter);
+	rsi_dbg(ERR_ZONE, "##### RSI SDIO device disconnected #####\n");
 }
 
 #ifdef CONFIG_PM
+int rsi_set_sdio_pm_caps(struct rsi_hw *adapter)
+{
+	struct rsi_91x_sdiodev *dev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
+	struct sdio_func *func = dev->pfunction;
+	int ret;
+
+	/* Keep Power to the MMC while suspend*/
+	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+	if (ret) {
+		rsi_dbg(ERR_ZONE, "set sdio keep pwr flag failed: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int rsi_freeze(struct device *dev)
+{
+	int ret = 0;
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+#ifdef CONFIG_RSI_WOW
+	struct rsi_91x_sdiodev *sdev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
+#endif
+	u8 isr_status = 0;
+
+	rsi_dbg(INFO_ZONE, "SDIO Bus freeze ===>\n");
+
+#ifdef CONFIG_RSI_WOW
+	if ((adapter->priv->suspend_flag == STATION_NOT_CONNECTED) ||
+	    (sdev->write_fail)) { 
+		rsi_dbg(ERR_ZONE,
+			"SUSPEND Cannot proceed as Device is not ready\n");
+		rsi_dbg(ERR_ZONE,
+			"Disable WoWLAN / Connect to AP\n");
+		return -EBUSY;
+	}
+#endif
+	rsi_dbg(INFO_ZONE, "Waiting for interrupts to be cleared..");
+	do {
+		rsi_sdio_read_register(adapter,
+				       RSI_FN1_INT_REGISTER,
+				       &isr_status);
+		printk(".");
+	} while (isr_status); 
+	printk("\n");
+
+	ret = rsi_set_sdio_pm_caps(adapter);
+	if (ret)
+		rsi_dbg(INFO_ZONE, "Setting power management caps failed\n");
+	
+	return 0;
+}
+
 static int rsi_suspend(struct device *dev)
 {
-	/* Not yet implemented */
-	return -ENOSYS;
+	int ret = 0;
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+#ifdef CONFIG_RSI_WOW
+	struct rsi_91x_sdiodev *sdev =
+		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
+#endif
+	u8 isr_status = 0;
+
+	rsi_dbg(INFO_ZONE, "SDIO Bus suspend ===>\n");
+
+	if (!adapter) {
+		rsi_dbg(ERR_ZONE, "Device is not ready\n");
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_RSI_WOW
+	if ((adapter->priv->suspend_flag == STATION_NOT_CONNECTED) ||
+	    (sdev->write_fail)) { 
+		rsi_dbg(ERR_ZONE,
+			"SUSPEND Cannot proceed; Device is not ready\n");
+		rsi_dbg(ERR_ZONE,
+			"Disable WoWLAN / Connect to AP\n");
+		return -EBUSY;
+	}
+#endif
+	printk("Waiting for interrupts to be cleared..");
+	do {
+		rsi_sdio_read_register(adapter,
+				       RSI_FN1_INT_REGISTER,
+				       &isr_status);
+		printk(".");
+	} while (isr_status); 
+	printk("\n");
+
+	ret = rsi_set_sdio_pm_caps(adapter);
+	if (ret)
+		rsi_dbg(INFO_ZONE, "Setting power management caps failed\n");
+	
+	rsi_dbg(INFO_ZONE, "***** SDIO BUS SUSPEND DONE ******\n");
+	return 0;
+}
+
+int rsi_resume(struct device *dev)
+{
+#ifdef CONFIG_RSI_WOW
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+        
+	rsi_dbg(INFO_ZONE, "***** BUS RESUME ******\n");
+        adapter->priv->suspend_flag = 0;
+#endif
+
+	rsi_dbg(INFO_ZONE, "RSI module resumed\n");
+	return 0;
+}
+
+int rsi_thaw(struct device *dev)
+{
+#ifdef CONFIG_RSI_WOW
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+        
+	rsi_dbg(INFO_ZONE, "***** BUS THAW ******\n");
+        adapter->priv->suspend_flag = 0;
+#endif
+
+	rsi_dbg(INFO_ZONE, "RSI module resumed\n");
+	return 0;
 }
 
-static int rsi_resume(struct device *dev)
+int rsi_restore(struct device *dev)
 {
-	/* Not yet implemented */
-	return -ENOSYS;
+	struct sdio_func *pfunction = dev_to_sdio_func(dev);
+	struct rsi_hw *adapter = sdio_get_drvdata(pfunction);
+
+#ifdef CONFIG_RSI_WOW
+	rsi_dbg(INFO_ZONE, "***** BUS RESTORE ******\n");
+        adapter->priv->suspend_flag = 0;
+#endif
+	rsi_reset_chip(adapter);
+
+	/* Resetting to take care of the case, where-in driver is re-loaded */
+	sdio_claim_host(pfunction);
+	rsi_reset_card(pfunction);
+	sdio_disable_func(pfunction);
+	sdio_release_host(pfunction);
+
+	rsi_dbg(INFO_ZONE, "RSI module resumed\n");
+	return 0;
 }
 
 static const struct dev_pm_ops rsi_pm_ops = {
 	.suspend = rsi_suspend,
 	.resume = rsi_resume,
+	.freeze = rsi_freeze,
+	.thaw = rsi_thaw,
+	.poweroff = rsi_suspend,
+	.restore = rsi_restore,
 };
 #endif
 
@@ -847,5 +1386,5 @@ MODULE_DESCRIPTION("Common SDIO layer for RSI drivers");
 MODULE_SUPPORTED_DEVICE("RSI-91x");
 MODULE_DEVICE_TABLE(sdio, rsi_dev_table);
 MODULE_FIRMWARE(FIRMWARE_RSI9113);
-MODULE_VERSION("0.1");
+MODULE_VERSION(DRV_VER);
 MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c b/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c
index 40d7231..9dabc72 100644
--- a/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c
+++ b/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c
@@ -1,23 +1,37 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/firmware.h>
 #include "rsi_sdio.h"
 #include "rsi_common.h"
+#include "rsi_hal.h"
 
 /**
  * rsi_sdio_master_access_msword() - This function sets the AHB master access
@@ -27,8 +41,8 @@
  *
  * Return: status: 0 on success, -1 on failure.
  */
-static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
-					 u16 ms_word)
+int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
+				  u16 ms_word)
 {
 	u8 byte;
 	u8 function = 0;
@@ -36,7 +50,7 @@ static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
 
 	byte = (u8)(ms_word & 0x00FF);
 
-	rsi_dbg(INIT_ZONE,
+	rsi_dbg(INFO_ZONE,
 		"%s: MASTER_ACCESS_MSBYTE:0x%x\n", __func__, byte);
 
 	status = rsi_sdio_write_register(adapter,
@@ -52,7 +66,7 @@ static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
 
 	byte = (u8)(ms_word >> 8);
 
-	rsi_dbg(INIT_ZONE, "%s:MASTER_ACCESS_LSBYTE:0x%x\n", __func__, byte);
+	rsi_dbg(INFO_ZONE, "%s:MASTER_ACCESS_LSBYTE:0x%x\n", __func__, byte);
 	status = rsi_sdio_write_register(adapter,
 					 function,
 					 SDIO_MASTER_ACCESS_LSBYTE,
@@ -61,194 +75,58 @@ static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
 }
 
 /**
- * rsi_copy_to_card() - This function includes the actual funtionality of
- *			copying the TA firmware to the card.Basically this
- *			function includes opening the TA file,reading the
- *			TA file and writing their values in blocks of data.
+ * rsi_process_pkt() - This Function reads rx_blocks register and figures out
+ *		       the size of the rx pkt.
  * @common: Pointer to the driver private structure.
- * @fw: Pointer to the firmware value to be written.
- * @len: length of firmware file.
- * @num_blocks: Number of blocks to be written to the card.
  *
- * Return: 0 on success and -1 on failure.
+ * Return: 0 on success, -1 on failure.
  */
-static int rsi_copy_to_card(struct rsi_common *common,
-			    const u8 *fw,
-			    u32 len,
-			    u32 num_blocks)
+static int rsi_process_pkt(struct rsi_common *common)
 {
 	struct rsi_hw *adapter = common->priv;
 	struct rsi_91x_sdiodev *dev =
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
-	u32 indx, ii;
-	u32 block_size = dev->tx_blk_size;
-	u32 lsb_address;
-	__le32 data[] = { TA_HOLD_THREAD_VALUE, TA_SOFT_RST_CLR,
-			  TA_PC_ZERO, TA_RELEASE_THREAD_VALUE };
-	u32 address[] = { TA_HOLD_THREAD_REG, TA_SOFT_RESET_REG,
-			  TA_TH0_PC_REG, TA_RELEASE_THREAD_REG };
-	u32 base_address;
-	u16 msb_address;
-
-	base_address = TA_LOAD_ADDRESS;
-	msb_address = base_address >> 16;
-
-	for (indx = 0, ii = 0; ii < num_blocks; ii++, indx += block_size) {
-		lsb_address = ((u16) base_address | RSI_SD_REQUEST_MASTER);
-		if (rsi_sdio_write_register_multiple(adapter,
-						     lsb_address,
-						     (u8 *)(fw + indx),
-						     block_size)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load %s blk\n", __func__,
-				FIRMWARE_RSI9113);
-			return -1;
-		}
-		rsi_dbg(INIT_ZONE, "%s: loading block: %d\n", __func__, ii);
-		base_address += block_size;
-		if ((base_address >> 16) != msb_address) {
-			msb_address += 1;
-			if (rsi_sdio_master_access_msword(adapter,
-							  msb_address)) {
-				rsi_dbg(ERR_ZONE,
-					"%s: Unable to set ms word reg\n",
-					__func__);
-				return -1;
-			}
-		}
-	}
-
-	if (len % block_size) {
-		lsb_address = ((u16) base_address | RSI_SD_REQUEST_MASTER);
-		if (rsi_sdio_write_register_multiple(adapter,
-						     lsb_address,
-						     (u8 *)(fw + indx),
-						     len % block_size)) {
+	u8 num_blks = 0;
+	u32 rcv_pkt_len = 0;
+	int status = 0;
+	u8 value = 0;
+	u8 protocol = 0, unaggr_pkt = 0;
+
+#define COEX_PKT 0
+#define WLAN_PKT 3
+#define ZIGB_PKT 1
+#define BT_PKT   2
+	num_blks = ((adapter->interrupt_status & 1) |
+			((adapter->interrupt_status >> 4) << 1));
+
+	if (!num_blks) {
+		status = rsi_sdio_read_register(adapter,
+						SDIO_RX_NUM_BLOCKS_REG,
+						&value);
+		if (status) {
 			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load f/w\n", __func__);
-			return -1;
+				"%s: Failed to read pkt length from the card:\n",
+				__func__);
+			return status;
 		}
-	}
-	rsi_dbg(INIT_ZONE,
-		"%s: Succesfully loaded TA instructions\n", __func__);
 
-	if (rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR)) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Unable to set ms word to common reg\n",
-			__func__);
-		return -1;
-	}
-
-	for (ii = 0; ii < ARRAY_SIZE(data); ii++) {
-		/* Bringing TA out of reset */
-		if (rsi_sdio_write_register_multiple(adapter,
-						     (address[ii] |
-						     RSI_SD_REQUEST_MASTER),
-						     (u8 *)&data[ii],
-						     4)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to hold TA threads\n", __func__);
-			return -1;
-		}
+		protocol = value >> 5;
+		num_blks = value & 0x1f;
+	} else {
+		protocol = WLAN_PKT;
 	}
 
-	rsi_dbg(INIT_ZONE, "%s: loaded firmware\n", __func__);
-	return 0;
-}
-
-/**
- * rsi_load_ta_instructions() - This function includes the actual funtionality
- *				of loading the TA firmware.This function also
- *				includes opening the TA file,reading the TA
- *				file and writing their value in blocks of data.
- * @common: Pointer to the driver private structure.
- *
- * Return: status: 0 on success, -1 on failure.
- */
-static int rsi_load_ta_instructions(struct rsi_common *common)
-{
-	struct rsi_hw *adapter = common->priv;
-	struct rsi_91x_sdiodev *dev =
-		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
-	u32 len;
-	u32 num_blocks;
-	const u8 *fw;
-	const struct firmware *fw_entry = NULL;
-	u32 block_size = dev->tx_blk_size;
-	int status = 0;
-	u32 base_address;
-	u16 msb_address;
-
-	if (rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR)) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Unable to set ms word to common reg\n",
-			__func__);
-		return -1;
+	if (dev->write_fail == 2) {
+		rsi_sdio_ack_intr(common->priv, (1 << MSDU_PKT_PENDING));
 	}
-	base_address = TA_LOAD_ADDRESS;
-	msb_address = (base_address >> 16);
-
-	if (rsi_sdio_master_access_msword(adapter, msb_address)) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Unable to set ms word reg\n", __func__);
+	if (unlikely(!num_blks)) {
+		dev->write_fail = 2;
 		return -1;
 	}
 
-	status = request_firmware(&fw_entry, FIRMWARE_RSI9113, adapter->device);
-	if (status < 0) {
-		rsi_dbg(ERR_ZONE, "%s Firmware file %s not found\n",
-			__func__, FIRMWARE_RSI9113);
-		return status;
-	}
-
-	/* Copy firmware into DMA-accessible memory */
-	fw = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
-	if (!fw) {
-		status = -ENOMEM;
-		goto out;
-	}
-	len = fw_entry->size;
-
-	if (len % 4)
-		len += (4 - (len % 4));
-
-	num_blocks = (len / block_size);
+	if (protocol == BT_PKT || protocol == ZIGB_PKT)  //unaggr_pkt FIXME
+		unaggr_pkt = 1;
 
-	rsi_dbg(INIT_ZONE, "%s: Instruction size:%d\n", __func__, len);
-	rsi_dbg(INIT_ZONE, "%s: num blocks: %d\n", __func__, num_blocks);
-
-	status = rsi_copy_to_card(common, fw, len, num_blocks);
-	kfree(fw);
-
-out:
-	release_firmware(fw_entry);
-	return status;
-}
-
-/**
- * rsi_process_pkt() - This Function reads rx_blocks register and figures out
- *		       the size of the rx pkt.
- * @common: Pointer to the driver private structure.
- *
- * Return: 0 on success, -1 on failure.
- */
-static int rsi_process_pkt(struct rsi_common *common)
-{
-	struct rsi_hw *adapter = common->priv;
-	u8 num_blks = 0;
-	u32 rcv_pkt_len = 0;
-	int status = 0;
-
-	status = rsi_sdio_read_register(adapter,
-					SDIO_RX_NUM_BLOCKS_REG,
-					&num_blks);
-
-	if (status) {
-		rsi_dbg(ERR_ZONE,
-			"%s: Failed to read pkt length from the card:\n",
-			__func__);
-		return status;
-	}
 	rcv_pkt_len = (num_blks * 256);
 
 	common->rx_data_pkt = kmalloc(rcv_pkt_len, GFP_KERNEL);
@@ -267,7 +145,7 @@ static int rsi_process_pkt(struct rsi_common *common)
 		goto fail;
 	}
 
-	status = rsi_read_pkt(common, rcv_pkt_len);
+	status = rsi_read_pkt(common, common->rx_data_pkt, rcv_pkt_len);
 
 fail:
 	kfree(common->rx_data_pkt);
@@ -360,6 +238,22 @@ int rsi_init_sdio_slave_regs(struct rsi_hw *adapter)
 	return 0;
 }
 
+int rsi_read_intr_status_reg(struct rsi_hw *adapter)
+{
+	u8 isr_status = 0;
+	struct rsi_common *common = adapter->priv;
+	int status;
+
+	status = rsi_sdio_read_register(common->priv,
+						RSI_FN1_INT_REGISTER,
+						&isr_status);
+	isr_status &= 0xE;
+	
+	if(isr_status & BIT(MSDU_PKT_PENDING))
+		adapter->isr_pending = 1;
+	return 0;
+}
+
 /**
  * rsi_interrupt_handler() - This function read and process SDIO interrupts.
  * @adapter: Pointer to the adapter structure.
@@ -379,7 +273,7 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 	dev->rx_info.sdio_int_counter++;
 
 	do {
-		mutex_lock(&common->tx_rxlock);
+		mutex_lock(&common->rx_lock);
 		status = rsi_sdio_read_register(common->priv,
 						RSI_FN1_INT_REGISTER,
 						&isr_status);
@@ -387,17 +281,23 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 			rsi_dbg(ERR_ZONE,
 				"%s: Failed to Read Intr Status Register\n",
 				__func__);
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->rx_lock);
 			return;
 		}
 
+		adapter->interrupt_status = isr_status;
+		isr_status &= 0xE;
+
 		if (isr_status == 0) {
 			rsi_set_event(&common->tx_thread.event);
 			dev->rx_info.sdio_intr_status_zero++;
-			mutex_unlock(&common->tx_rxlock);
+			mutex_unlock(&common->rx_lock);
 			return;
 		}
 
+//		adapter->interrupt_status = isr_status;
+//		isr_status &= 0xE;
+
 		rsi_dbg(ISR_ZONE, "%s: Intr_status = %x %d %d\n",
 			__func__, isr_status, (1 << MSDU_PKT_PENDING),
 			(1 << FW_ASSERT_IND));
@@ -419,6 +319,7 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 					"%s: ==> BUFFER_AVAILABLE <==\n",
 					__func__);
 				dev->rx_info.buf_available_counter++;
+				dev->buff_status_updated = 1;
 				break;
 
 			case FIRMWARE_ASSERT_IND:
@@ -426,8 +327,8 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 					"%s: ==> FIRMWARE Assert <==\n",
 					__func__);
 				status = rsi_sdio_read_register(common->priv,
-							SDIO_FW_STATUS_REG,
-							&fw_status);
+								SDIO_FW_STATUS_REG,
+								&fw_status);
 				if (status) {
 					rsi_dbg(ERR_ZONE,
 						"%s: Failed to read f/w reg\n",
@@ -435,7 +336,7 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 				} else {
 					rsi_dbg(ERR_ZONE,
 						"%s: Firmware Status is 0x%x\n",
-						__func__ , fw_status);
+						__func__, fw_status);
 					rsi_sdio_ack_intr(common->priv,
 							  (1 << FW_ASSERT_IND));
 				}
@@ -452,7 +353,7 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 					rsi_dbg(ERR_ZONE,
 						"%s: Failed to read pkt\n",
 						__func__);
-					mutex_unlock(&common->tx_rxlock);
+					mutex_unlock(&common->rx_lock);
 					return;
 				}
 				break;
@@ -467,33 +368,11 @@ void rsi_interrupt_handler(struct rsi_hw *adapter)
 			}
 			isr_status ^= BIT(isr_type - 1);
 		} while (isr_status);
-		mutex_unlock(&common->tx_rxlock);
+		mutex_unlock(&common->rx_lock);
 	} while (1);
 }
 
 /**
- * rsi_device_init() - This Function Initializes The HAL.
- * @common: Pointer to the driver private structure.
- *
- * Return: 0 on success, -1 on failure.
- */
-int rsi_sdio_device_init(struct rsi_common *common)
-{
-	if (rsi_load_ta_instructions(common))
-		return -1;
-
-	if (rsi_sdio_master_access_msword(common->priv, MISC_CFG_BASE_ADDR)) {
-		rsi_dbg(ERR_ZONE, "%s: Unable to set ms word reg\n",
-			__func__);
-		return -1;
-	}
-	rsi_dbg(INIT_ZONE,
-		"%s: Setting ms word to 0x41050000\n", __func__);
-
-	return 0;
-}
-
-/**
  * rsi_sdio_read_buffer_status_register() - This function is used to the read
  *					    buffer status register and set
  *					    relevant fields in
@@ -510,11 +389,19 @@ int rsi_sdio_read_buffer_status_register(struct rsi_hw *adapter, u8 q_num)
 		(struct rsi_91x_sdiodev *)adapter->rsi_dev;
 	u8 buf_status = 0;
 	int status = 0;
+//	static int counter = 4;
 
+#if 0
+	if ((!dev->buff_status_updated) && counter) {
+		counter--;
+		goto out;
+	}
+#endif
+
+	dev->buff_status_updated = 0;
 	status = rsi_sdio_read_register(common->priv,
 					RSI_DEVICE_BUFFER_STATUS_REGISTER,
 					&buf_status);
-
 	if (status) {
 		rsi_dbg(ERR_ZONE,
 			"%s: Failed to read status register\n", __func__);
@@ -544,11 +431,13 @@ int rsi_sdio_read_buffer_status_register(struct rsi_hw *adapter, u8 q_num)
 	} else {
 		dev->rx_info.semi_buffer_full = false;
 	}
+//	(dev->rx_info.semi_buffer_full ? (counter = 4) : (counter = 1));
 
+//out:
 	if ((q_num == MGMT_SOFT_Q) && (dev->rx_info.mgmt_buffer_full))
 		return QUEUE_FULL;
 
-	if (dev->rx_info.buffer_full)
+	if ((q_num < MGMT_SOFT_Q) && (dev->rx_info.buffer_full))
 		return QUEUE_FULL;
 
 	return QUEUE_NOT_FULL;
diff --git a/drivers/net/wireless/rsi/rsi_91x_usb.c b/drivers/net/wireless/rsi/rsi_91x_usb.c
index ef5d394..ad918ca 100644
--- a/drivers/net/wireless/rsi/rsi_91x_usb.c
+++ b/drivers/net/wireless/rsi/rsi_91x_usb.c
@@ -1,25 +1,62 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/module.h>
+#include <linux/usb.h>
 #include "rsi_usb.h"
+#include "rsi_hal.h"
+
+/* Default operating mode is Wi-Fi alone */
+u16 dev_oper_mode = DEV_OPMODE_WIFI_ALONE;
+module_param(dev_oper_mode, ushort, S_IRUGO);
+MODULE_PARM_DESC(dev_oper_mode,
+		 "1 -	Wi-Fi Alone \
+		  4 -	BT Alone \
+		  8 -	BT LE Alone \
+		  5 -	Wi-Fi STA + BT classic \
+		  9 -	Wi-Fi STA + BT LE \
+		  13 -	Wi-Fi STA + BT classic + BT LE \
+		  6 -	AP + BT classic \
+		  14 -	AP + BT classic + BT LE");
+
+static struct rsi_host_intf_ops usb_host_intf_ops = {
+	.write_pkt		= rsi_usb_host_intf_write_pkt,
+	.master_reg_read	= rsi_usb_master_reg_read,
+	.master_reg_write	= rsi_usb_master_reg_write,
+	.read_reg_multiple	= rsi_usb_read_register_multiple,
+	.write_reg_multiple	= rsi_usb_write_register_multiple,
+	.load_data_master_write	= rsi_usb_load_data_master_write,
+};
 
 /**
- * rsi_usb_card_write() - This function writes to the USB Card.
+ * rsi_usb_card_write() - This function writes data to the USB Card.
  * @adapter: Pointer to the adapter structure.
  * @buf: Pointer to the buffer from where the data has to be taken.
  * @len: Length to be written.
@@ -28,27 +65,36 @@
  * Return: status: 0 on success, a negative error code on failure.
  */
 static int rsi_usb_card_write(struct rsi_hw *adapter,
-			      void *buf,
+			      u8 *buf,
 			      u16 len,
-			      u8 endpoint)
+			      u32 endpoint)
 {
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	int status;
-	s32 transfer;
+	int status = 0;
+	u8 *seg = dev->tx_buffer;
+	int transfer = 0;
+	int ep = dev->bulkout_endpoint_addr[endpoint - 1];
+
+	memset(seg, 0, len + 128);
+	memcpy(seg + 128, buf, len);
+	len += 128;
+	transfer = len;
 
 	status = usb_bulk_msg(dev->usbdev,
-			      usb_sndbulkpipe(dev->usbdev,
-			      dev->bulkout_endpoint_addr[endpoint - 1]),
-			      buf,
-			      len,
+			      usb_sndbulkpipe(dev->usbdev, ep),
+			      (void *)seg,
+			      (int)len,
 			      &transfer,
 			      HZ * 5);
-
 	if (status < 0) {
 		rsi_dbg(ERR_ZONE,
-			"Card write failed with error code :%10d\n", status);
+			"Card write failed with error code :%d\n", status);
 		dev->write_fail = 1;
+		goto fail;
 	}
+	rsi_dbg(MGMT_TX_ZONE, "%s: Sent Message successfully\n", __func__);
+
+fail:
 	return status;
 }
 
@@ -63,84 +109,28 @@ static int rsi_usb_card_write(struct rsi_hw *adapter,
  * Return: 0 on success, a negative error code on failure.
  */
 static int rsi_write_multiple(struct rsi_hw *adapter,
-			      u8 endpoint,
+			      u32 addr,
 			      u8 *data,
 			      u32 count)
 {
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	u8 *seg = dev->tx_buffer;
-
-	if (dev->write_fail)
-		return 0;
+	struct rsi_91x_usbdev *dev =
+		(struct rsi_91x_usbdev *)adapter->rsi_dev;
 
-	if (endpoint == MGMT_EP) {
-		memset(seg, 0, RSI_USB_TX_HEAD_ROOM);
-		memcpy(seg + RSI_USB_TX_HEAD_ROOM, data, count);
-	} else {
-		seg = ((u8 *)data - RSI_USB_TX_HEAD_ROOM);
+	if (!adapter || addr == 0) {
+		rsi_dbg(INFO_ZONE,
+			"%s: Unable to write to card\n", __func__);
+		return -1;
 	}
 
-	return rsi_usb_card_write(adapter,
-				  seg,
-				  count + RSI_USB_TX_HEAD_ROOM,
-				  endpoint);
-}
-
-/**
- * rsi_find_bulk_in_and_out_endpoints() - This function initializes the bulk
- *					  endpoints to the device.
- * @interface: Pointer to the USB interface structure.
- * @adapter: Pointer to the adapter structure.
- *
- * Return: ret_val: 0 on success, -ENOMEM on failure.
- */
-static int rsi_find_bulk_in_and_out_endpoints(struct usb_interface *interface,
-					      struct rsi_hw *adapter)
-{
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	struct usb_host_interface *iface_desc;
-	struct usb_endpoint_descriptor *endpoint;
-	__le16 buffer_size;
-	int ii, bep_found = 0;
-
-	iface_desc = &(interface->altsetting[0]);
-
-	for (ii = 0; ii < iface_desc->desc.bNumEndpoints; ++ii) {
-		endpoint = &(iface_desc->endpoint[ii].desc);
-
-		if ((!(dev->bulkin_endpoint_addr)) &&
-		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
-		    ((endpoint->bmAttributes &
-		    USB_ENDPOINT_XFERTYPE_MASK) ==
-		    USB_ENDPOINT_XFER_BULK)) {
-			buffer_size = endpoint->wMaxPacketSize;
-			dev->bulkin_size = buffer_size;
-			dev->bulkin_endpoint_addr =
-				endpoint->bEndpointAddress;
-		}
-
-		if (!dev->bulkout_endpoint_addr[bep_found] &&
-		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
-		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		      USB_ENDPOINT_XFER_BULK)) {
-			dev->bulkout_endpoint_addr[bep_found] =
-				endpoint->bEndpointAddress;
-			buffer_size = endpoint->wMaxPacketSize;
-			dev->bulkout_size[bep_found] = buffer_size;
-			bep_found++;
-		}
-
-		if (bep_found >= MAX_BULK_EP)
-			break;
-	}
-
-	if (!(dev->bulkin_endpoint_addr) &&
-	    (dev->bulkout_endpoint_addr[0]))
-		return -EINVAL;
+	if (dev->write_fail)
+		return -1;
 
-	return 0;
+	return rsi_usb_card_write(adapter, data, count, addr);
 }
 
+#define RSI_USB_REQ_OUT	(USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE)
+#define RSI_USB_REQ_IN	(USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE)
+
 /* rsi_usb_reg_read() - This function reads data from given register address.
  * @usbdev: Pointer to the usb_device structure.
  * @reg: Address of the register to be read.
@@ -151,24 +141,26 @@ static int rsi_find_bulk_in_and_out_endpoints(struct usb_interface *interface,
  */
 static int rsi_usb_reg_read(struct usb_device *usbdev,
 			    u32 reg,
-			    u16 *value,
+			    u32 *value,
 			    u16 len)
 {
-	u8 *buf;
-	int status = -ENOMEM;
-
-	buf  = kmalloc(0x04, GFP_KERNEL);
-	if (!buf)
-		return status;
+	u8 buf[4];
+	int status = 0;
+	u16 reg_value;
+	u16 index;
 
+	len = 2;
+	reg_value = cpu_to_le16(((u16 *)&reg)[1] & 0xffff);
+	index = cpu_to_le16(((u16 *)&reg)[0] & 0xffff);
 	status = usb_control_msg(usbdev,
 				 usb_rcvctrlpipe(usbdev, 0),
 				 USB_VENDOR_REGISTER_READ,
-				 USB_TYPE_VENDOR,
-				 ((reg & 0xffff0000) >> 16), (reg & 0xffff),
+				 RSI_USB_REQ_IN,
+				 reg_value,
+				 index,
 				 (void *)buf,
 				 len,
-				 HZ * 5);
+				 USB_CTRL_GET_TIMEOUT);
 
 	*value = (buf[0] | (buf[1] << 8));
 	if (status < 0) {
@@ -176,7 +168,6 @@ static int rsi_usb_reg_read(struct usb_device *usbdev,
 			"%s: Reg read failed with error code :%d\n",
 			__func__, status);
 	}
-	kfree(buf);
 
 	return status;
 }
@@ -192,136 +183,205 @@ static int rsi_usb_reg_read(struct usb_device *usbdev,
  * Return: status: 0 on success, a negative error code on failure.
  */
 static int rsi_usb_reg_write(struct usb_device *usbdev,
-			     u32 reg,
-			     u16 value,
+			     unsigned long reg,
+			     unsigned long value,
 			     u16 len)
 {
-	u8 *usb_reg_buf;
-	int status = -ENOMEM;
-
-	usb_reg_buf  = kmalloc(0x04, GFP_KERNEL);
-	if (!usb_reg_buf)
-		return status;
+	u8 usb_reg_buf[4];
+	int status = 0;
+	u16 reg_value, index;
 
 	usb_reg_buf[0] = (value & 0x00ff);
 	usb_reg_buf[1] = (value & 0xff00) >> 8;
 	usb_reg_buf[2] = 0x0;
 	usb_reg_buf[3] = 0x0;
 
+	reg_value = ((u16 *)&reg)[1] & 0xffff;
+	index = ((u16 *)&reg)[0] & 0xffff;
 	status = usb_control_msg(usbdev,
 				 usb_sndctrlpipe(usbdev, 0),
 				 USB_VENDOR_REGISTER_WRITE,
-				 USB_TYPE_VENDOR,
-				 ((reg & 0xffff0000) >> 16),
-				 (reg & 0xffff),
+				 RSI_USB_REQ_OUT,
+				 reg_value,
+				 index,
 				 (void *)usb_reg_buf,
 				 len,
-				 HZ * 5);
+				 USB_CTRL_SET_TIMEOUT);
 	if (status < 0) {
 		rsi_dbg(ERR_ZONE,
 			"%s: Reg write failed with error code :%d\n",
 			__func__, status);
 	}
-	kfree(usb_reg_buf);
 
 	return status;
 }
 
 /**
- * rsi_rx_done_handler() - This function is called when a packet is received
- *			   from USB stack. This is callback to recieve done.
- * @urb: Received URB.
+ * rsi_usb_read_register_multiple() - This function reads multiple
+ *					bytes of data from the address.
+ * @adapter:	Pointer to the adapter structure.
+ * @addr:	Address of the register.
+ * @data:	Read data.
+ * @len:	Number of bytes to read.
  *
- * Return: None.
+ * Return: status: 0 on success, a negative error code on failure.
  */
-static void rsi_rx_done_handler(struct urb *urb)
+int rsi_usb_read_register_multiple(struct rsi_hw *adapter,
+				   u32 addr,
+				   u8 *data,
+				   u16 count)
 {
-	struct rsi_hw *adapter = urb->context;
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	u8 *buf;
+	u16 transfer;
+	int status = 0;
+	u16 reg_val, index;
 
-	if (urb->status)
-		return;
-
-	rsi_set_event(&dev->rx_thread.event);
-}
-
-/**
- * rsi_rx_urb_submit() - This function submits the given URB to the USB stack.
- * @adapter: Pointer to the adapter structure.
- *
- * Return: 0 on success, a negative error code on failure.
- */
-static int rsi_rx_urb_submit(struct rsi_hw *adapter)
-{
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	struct urb *urb = dev->rx_usb_urb[0];
-	int status;
+	if (addr == 0)
+		return -EINVAL;
 
-	usb_fill_bulk_urb(urb,
-			  dev->usbdev,
-			  usb_rcvbulkpipe(dev->usbdev,
-				dev->bulkin_endpoint_addr),
-			  urb->transfer_buffer,
-			  3000,
-			  rsi_rx_done_handler,
-			  adapter);
+	buf = kzalloc(4096, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
 
-	status = usb_submit_urb(urb, GFP_KERNEL);
-	if (status)
-		rsi_dbg(ERR_ZONE, "%s: Failed in urb submission\n", __func__);
+	reg_val = ((u16 *)&addr)[1] & 0xffff;
+	index = ((u16 *)&addr)[0] & 0xffff;
+	while (count) {
+		transfer = min_t(u16, count, 4096);
+		status = usb_control_msg(dev->usbdev,
+					 usb_rcvctrlpipe(dev->usbdev, 0),
+					 USB_VENDOR_REGISTER_READ,
+					 RSI_USB_REQ_IN,
+					 reg_val,
+					 index,
+					 (void *)buf,
+					 transfer,
+					 USB_CTRL_GET_TIMEOUT);
+		if (status < 0) {
+			rsi_dbg(ERR_ZONE,
+				"Reg read failed with error code :%d\n",
+				 status);
+			kfree(buf);
+			return status;
 
+		} else {
+			memcpy(data, buf, transfer);
+			count -= transfer;
+			data += transfer;
+			addr += transfer;
+		}
+	}
+	kfree(buf);
 	return status;
 }
 
 /**
  * rsi_usb_write_register_multiple() - This function writes multiple bytes of
- *				       information to multiple registers.
- * @adapter: Pointer to the adapter structure.
- * @addr: Address of the register.
- * @data: Pointer to the data that has to be written.
- * @count: Number of multiple bytes to be written on to the registers.
+ *				       information to the given address.
+ * @adapter:	Pointer to the adapter structure.
+ * @addr:	Address of the register.
+ * @data:	Pointer to the data that has to be written.
+ * @count:	Number of multiple bytes to be written on to the registers.
  *
  * Return: status: 0 on success, a negative error code on failure.
  */
 int rsi_usb_write_register_multiple(struct rsi_hw *adapter,
 				    u32 addr,
 				    u8 *data,
-				    u32 count)
+				    u16 count)
 {
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct rsi_91x_usbdev *dev =
+		(struct rsi_91x_usbdev *)adapter->rsi_dev;
 	u8 *buf;
-	u8 transfer;
+	u16 transfer;
 	int status = 0;
+	u16 reg_val, index;
 
 	buf = kzalloc(4096, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
+	reg_val = ((u16 *)&addr)[1] & 0xffff;
+	index = ((u16 *)&addr)[0] & 0xffff;
 	while (count) {
-		transfer = (u8)(min_t(u32, count, 4096));
+		transfer = min_t(u16, count, 4096);
 		memcpy(buf, data, transfer);
 		status = usb_control_msg(dev->usbdev,
 					 usb_sndctrlpipe(dev->usbdev, 0),
 					 USB_VENDOR_REGISTER_WRITE,
-					 USB_TYPE_VENDOR,
-					 ((addr & 0xffff0000) >> 16),
-					 (addr & 0xffff),
+					 RSI_USB_REQ_OUT,
+					 reg_val,
+					 index,
 					 (void *)buf,
 					 transfer,
-					 HZ * 5);
+					 USB_CTRL_SET_TIMEOUT);
 		if (status < 0) {
 			rsi_dbg(ERR_ZONE,
 				"Reg write failed with error code :%d\n",
 				status);
-		} else {
-			count -= transfer;
-			data += transfer;
-			addr += transfer;
+			kfree(buf);
+			return status;
 		}
+		count -= transfer;
+		data += transfer;
+		addr += transfer;
 	}
 
 	kfree(buf);
-	return 0;
+	return status;
+}
+
+/**
+ * rsi_rx_done_handler() - This function is called when a packet is received
+ *			   from USB stack. This is callback to receive done.
+ * @urb: Received URB.
+ *
+ * Return: None.
+ */
+static void rsi_rx_done_handler(struct urb *urb)
+{
+	struct rx_usb_ctrl_block *rx_cb = urb->context;
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)rx_cb->data;
+
+	if (urb->status)
+		return;
+
+	if (urb->actual_length <= 0) {
+		rsi_dbg(INFO_ZONE, "%s: Zero length packet\n", __func__);
+		return;
+	}
+	rx_cb->pend = 1;
+
+	rsi_set_event(&dev->rx_thread.event);
+}
+
+/**
+ * rsi_rx_urb_submit() - This function submits the given URB to the USB stack.
+ * @adapter: Pointer to the adapter structure.
+ *
+ * Return: 0 on success, a negative error code on failure.
+ */
+static int rsi_rx_urb_submit(struct rsi_hw *adapter, u8 ep_num)
+{
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct rx_usb_ctrl_block *rx_cb = &dev->rx_cb[ep_num - 1];
+	struct urb *urb = rx_cb->rx_urb;
+	int status;
+
+	usb_fill_bulk_urb(urb,
+			dev->usbdev,
+			usb_rcvbulkpipe(dev->usbdev,
+					dev->bulkin_endpoint_addr[ep_num - 1]),
+			urb->transfer_buffer,
+			3000,
+			rsi_rx_done_handler,
+			rx_cb);
+
+	status = usb_submit_urb(urb, GFP_KERNEL);
+	if (status)
+		rsi_dbg(ERR_ZONE, "%s: Failed in urb submission\n", __func__);
+
+	return status;
 }
 
 /**
@@ -333,21 +393,90 @@ int rsi_usb_write_register_multiple(struct rsi_hw *adapter,
  *
  * Return: 0 on success, a negative error code on failure.
  */
-static int rsi_usb_host_intf_write_pkt(struct rsi_hw *adapter,
-				       u8 *pkt,
-				       u32 len)
+int rsi_usb_host_intf_write_pkt(struct rsi_hw *adapter,
+				u8 *pkt,
+				u32 len)
 {
-	u32 queueno = ((pkt[1] >> 4) & 0xf);
+	u32 queueno = ((pkt[1] >> 4) & 0x7);
 	u8 endpoint;
 
-	endpoint = ((queueno == RSI_WIFI_MGMT_Q) ? MGMT_EP : DATA_EP);
+	rsi_dbg(DATA_TX_ZONE, "%s: queueno=%d\n", __func__, queueno);
+	endpoint = ((queueno == RSI_WIFI_MGMT_Q || queueno == RSI_COEX_Q ||
+		     queueno == RSI_WIFI_DATA_Q) ?
+		    MGMT_EP : DATA_EP);
 
 	return rsi_write_multiple(adapter,
 				  endpoint,
-				  (u8 *)pkt,
+				  pkt,
 				  len);
 }
 
+int rsi_usb_master_reg_read(struct rsi_hw *adapter,
+			    u32 reg,
+			    u32 *value,
+			    u16 len)
+{
+	struct usb_device *usbdev =
+		((struct rsi_91x_usbdev *)adapter->rsi_dev)->usbdev;
+
+	return rsi_usb_reg_read(usbdev, reg, value, len);
+}
+
+int rsi_usb_master_reg_write(struct rsi_hw *adapter,
+			     unsigned long reg,
+			     unsigned long value,
+			     u16 len)
+{
+	struct usb_device *usbdev =
+		((struct rsi_91x_usbdev *)adapter->rsi_dev)->usbdev;
+
+	return rsi_usb_reg_write(usbdev, reg, value, len);
+}
+
+int rsi_usb_load_data_master_write(struct rsi_hw *adapter,
+				   u32 base_address,
+				   u32 instructions_sz,
+				   u16 block_size,
+				   u8 *ta_firmware)
+{
+	u16 num_blocks;
+	u32 cur_indx, ii;
+	u8 temp_buf[256];
+
+	num_blocks = instructions_sz / block_size;
+	rsi_dbg(INFO_ZONE, "num_blocks: %d\n", num_blocks);
+
+	for (cur_indx = 0, ii = 0;
+	     ii < num_blocks;
+	     ii++, cur_indx += block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf, ta_firmware + cur_indx, block_size);
+		if ((rsi_usb_write_register_multiple(adapter,
+						     base_address,
+						     (u8 *)(temp_buf),
+						     block_size)) < 0)
+			return -EIO;
+
+		rsi_dbg(INFO_ZONE, "%s: loading block: %d\n", __func__, ii);
+		base_address += block_size;
+	}
+
+	if (instructions_sz % block_size) {
+		memset(temp_buf, 0, block_size);
+		memcpy(temp_buf, ta_firmware + cur_indx,
+		       instructions_sz % block_size);
+		if ((rsi_usb_write_register_multiple(adapter,
+					     base_address,
+					     (u8 *)temp_buf,
+					     instructions_sz % block_size)) < 0)
+			return -EIO;
+		rsi_dbg(INFO_ZONE,
+			"Written Last Block in Address 0x%x Successfully\n",
+			cur_indx);
+	}
+	return 0;
+}
+
 /**
  * rsi_deinit_usb_interface() - This function deinitializes the usb interface.
  * @adapter: Pointer to the adapter structure.
@@ -358,10 +487,113 @@ static void rsi_deinit_usb_interface(struct rsi_hw *adapter)
 {
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
 
+	rsi_dbg(INFO_ZONE, "Deinitializing USB interface...\n");
+
 	rsi_kill_thread(&dev->rx_thread);
-	usb_free_urb(dev->rx_usb_urb[0]);
-	kfree(adapter->priv->rx_data_pkt);
-	kfree(dev->tx_buffer);
+	kfree(dev->rx_cb[0].rx_buffer);
+	usb_free_urb(dev->rx_cb[0].rx_urb);
+#if defined (CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)	
+	kfree(dev->rx_cb[1].rx_buffer);
+	usb_free_urb(dev->rx_cb[1].rx_urb);
+#endif
+	kfree(dev->saved_tx_buffer);
+}
+
+/**
+ * rsi_find_bulk_in_and_out_endpoints() - This function initializes the bulk
+ *					  endpoints to the device.
+ * @interface: Pointer to the USB interface structure.
+ * @adapter: Pointer to the adapter structure.
+ *
+ * Return: ret_val: 0 on success, -ENOMEM on failure.
+ */
+static int rsi_find_bulk_in_and_out_endpoints(struct usb_interface *interface,
+					      struct rsi_hw *adapter)
+{
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	__le16 buffer_size;
+	int ii, bin_found = 0, bout_found = 0;
+
+	iface_desc = &interface->altsetting[0];
+
+	for (ii = 0; ii < iface_desc->desc.bNumEndpoints; ++ii) {
+		endpoint = &(iface_desc->endpoint[ii].desc);
+
+		if ((!dev->bulkin_endpoint_addr[bin_found]) &&
+		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		     USB_ENDPOINT_XFER_BULK)) {
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulkin_size[bin_found] = buffer_size;
+			dev->bulkin_endpoint_addr[bin_found] =
+					endpoint->bEndpointAddress;
+			printk("bulkin addr[%d] = %d\n", bin_found, dev->bulkin_endpoint_addr[bin_found]);
+			bin_found++;
+		}
+
+		if (!dev->bulkout_endpoint_addr[bout_found] &&
+		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
+		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		     USB_ENDPOINT_XFER_BULK)) {
+			printk("%s:%d\n", __func__, __LINE__);
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulkout_endpoint_addr[bout_found] =
+					endpoint->bEndpointAddress;
+			buffer_size = endpoint->wMaxPacketSize;
+			dev->bulkout_size[bout_found] = buffer_size;
+			printk("bulkout addr[%d] = %d\n", bout_found, dev->bulkout_endpoint_addr[bout_found]);
+			bout_found++;
+		}
+
+		if ((bin_found >= MAX_BULK_EP) || (bout_found >= MAX_BULK_EP))
+			break;
+	}
+
+	if (!(dev->bulkin_endpoint_addr[0]) &&
+	    (dev->bulkout_endpoint_addr[0]))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int rsi_usb_init_rx(struct rsi_hw *adapter)
+{
+	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
+	struct rx_usb_ctrl_block *rx_cb;
+	u8 dword_align_bytes = 0, idx;
+
+	for (idx = 0; idx < MAX_RX_URBS; idx++) {
+		rx_cb = &dev->rx_cb[idx];
+
+		rx_cb->rx_buffer = kzalloc(2000 * 4, GFP_KERNEL | GFP_DMA);
+		if (!rx_cb->rx_buffer)
+			return -ENOMEM
+				;
+		rx_cb->orig_rx_buffer = rx_cb->rx_buffer;
+		dword_align_bytes = (unsigned long)rx_cb->rx_buffer & 0x3f;
+		if (dword_align_bytes)
+			rx_cb->rx_buffer = rx_cb->rx_buffer +
+					   (64 - dword_align_bytes);
+
+		rx_cb->rx_urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!rx_cb->rx_urb) {
+			rsi_dbg(ERR_ZONE, "Failed alloc rx urb[%d]\n", idx);
+			goto err;
+		}
+		rx_cb->rx_urb->transfer_buffer = rx_cb->rx_buffer;
+		rx_cb->ep_num = idx + 1;
+		rx_cb->data = (void *)dev;
+	}
+	return 0;
+
+err:
+	kfree(rx_cb[0].rx_buffer);
+	kfree(rx_cb[0].rx_urb);
+	kfree(rx_cb[1].rx_buffer);
+	kfree(rx_cb[1].rx_urb);
+	return -1;
 }
 
 /**
@@ -376,7 +608,8 @@ static int rsi_init_usb_interface(struct rsi_hw *adapter,
 {
 	struct rsi_91x_usbdev *rsi_dev;
 	struct rsi_common *common = adapter->priv;
-	int status;
+	int status = 0;
+	u8 dword_align_bytes = 0;
 
 	rsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);
 	if (!rsi_dev)
@@ -391,57 +624,162 @@ static int rsi_init_usb_interface(struct rsi_hw *adapter,
 	adapter->device = &pfunction->dev;
 	usb_set_intfdata(pfunction, adapter);
 
-	common->rx_data_pkt = kmalloc(2048, GFP_KERNEL);
-	if (!common->rx_data_pkt) {
-		rsi_dbg(ERR_ZONE, "%s: Failed to allocate memory\n",
-			__func__);
-		return -ENOMEM;
-	}
-
 	rsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);
 	if (!rsi_dev->tx_buffer) {
 		status = -ENOMEM;
-		goto fail_tx;
+		goto fail_1;
 	}
-	rsi_dev->rx_usb_urb[0] = usb_alloc_urb(0, GFP_KERNEL);
-	if (!rsi_dev->rx_usb_urb[0]) {
-		status = -ENOMEM;
-		goto fail_rx;
+	rsi_dev->saved_tx_buffer = rsi_dev->tx_buffer;
+	dword_align_bytes = (unsigned long)rsi_dev->tx_buffer & 0x3f;
+	if (dword_align_bytes)
+		rsi_dev->tx_buffer = rsi_dev->tx_buffer +
+				     (64 - dword_align_bytes);
+
+	/* Initialize RX handle */
+	if (rsi_usb_init_rx(adapter)) {
+		rsi_dbg(ERR_ZONE, "Failed to init RX handle\n");
+		goto fail_1;
 	}
-	rsi_dev->rx_usb_urb[0]->transfer_buffer = adapter->priv->rx_data_pkt;
+
 	rsi_dev->tx_blk_size = 252;
+	adapter->tx_blk_size = rsi_dev->tx_blk_size;
 
 	/* Initializing function callbacks */
 	adapter->rx_urb_submit = rsi_rx_urb_submit;
-	adapter->host_intf_write_pkt = rsi_usb_host_intf_write_pkt;
 	adapter->check_hw_queue_status = rsi_usb_check_queue_status;
 	adapter->determine_event_timeout = rsi_usb_event_timeout;
+	adapter->host_intf_ops = &usb_host_intf_ops;
+	rsi_dev->priv = (void *)adapter;
 
 	rsi_init_event(&rsi_dev->rx_thread.event);
 	status = rsi_create_kthread(common, &rsi_dev->rx_thread,
 				    rsi_usb_rx_thread, "RX-Thread");
 	if (status) {
 		rsi_dbg(ERR_ZONE, "%s: Unable to init rx thrd\n", __func__);
-		goto fail_thread;
+		goto fail_2;
 	}
 
 #ifdef CONFIG_RSI_DEBUGFS
-	/* In USB, one less than the MAX_DEBUGFS_ENTRIES entries is required */
-	adapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);
+	/* In USB, one less than the MAX_DEBUGFS_ENTRIES entries
+	 * is required */
+	adapter->num_debugfs_entries = MAX_DEBUGFS_ENTRIES - 1;
 #endif
 
 	rsi_dbg(INIT_ZONE, "%s: Enabled the interface\n", __func__);
 	return 0;
 
-fail_thread:
-	usb_free_urb(rsi_dev->rx_usb_urb[0]);
-fail_rx:
-	kfree(rsi_dev->tx_buffer);
-fail_tx:
-	kfree(common->rx_data_pkt);
+fail_2:
+	kfree(rsi_dev->saved_tx_buffer);
+	rsi_kill_thread(&rsi_dev->rx_thread);
+fail_1:
 	return status;
 }
 
+static int rsi_usb_gspi_init(struct rsi_hw *adapter)
+{
+	u32 gspi_ctrl_reg0_val;
+
+	/**
+	 * Programming gspi frequency = soc_frequency / 2
+	 * Warning : ULP seemed to be not working
+	 * well at high frequencies. Modify accordingly
+	 */
+	gspi_ctrl_reg0_val = 0x4;
+	gspi_ctrl_reg0_val |= 0x10;
+	gspi_ctrl_reg0_val |= 0x40;
+	gspi_ctrl_reg0_val |= 0x100;
+	gspi_ctrl_reg0_val |= 0x000;
+	gspi_ctrl_reg0_val |= 0x000;
+
+	/* Initializing GSPI for ULP read/writes */
+	return rsi_usb_master_reg_write(adapter, GSPI_CTRL_REG0,
+			gspi_ctrl_reg0_val, 2);
+}
+
+static int usb_ulp_read_write(struct rsi_hw *adapter,
+			      u16 addr,
+			      u16 *data,
+			      u16 len_in_bits)
+{
+	if ((rsi_usb_master_reg_write(adapter,
+				      GSPI_DATA_REG1,
+				      ((addr << 6) | (data[1] & 0x3f)),
+				      2) < 0))
+		goto fail;
+
+	if ((rsi_usb_master_reg_write(adapter,
+				      GSPI_DATA_REG0,
+				      (*(u16 *)&data[0]),
+				      2)) < 0)
+		goto fail;
+
+	if ((rsi_usb_gspi_init(adapter)) < 0)
+		goto fail;
+
+	if ((rsi_usb_master_reg_write(adapter, GSPI_CTRL_REG1,
+				      ((len_in_bits - 1) | GSPI_TRIG),
+				      2)) < 0)
+		goto fail;
+
+	msleep(10);
+
+	return 0;
+
+fail:
+	return -1;
+}
+
+static int rsi_reset_card(struct rsi_hw *adapter)
+{
+	u16 temp[4] = {0};
+
+	rsi_dbg(INFO_ZONE, "Resetting Card...\n");
+
+#define TA_HOLD_REG 0x22000844
+	rsi_usb_master_reg_write(adapter, TA_HOLD_REG, 0xE, 4);
+	msleep(100);
+	*(u32 *)temp = 2;
+	if ((usb_ulp_read_write(adapter,
+				WATCH_DOG_TIMER_1,
+				&temp[0], 32)) < 0) {
+		goto fail;
+	}
+
+	*(u32 *)temp = 0;
+	if ((usb_ulp_read_write(adapter,
+				WATCH_DOG_TIMER_2,
+				temp, 32)) < 0) {
+		goto fail;
+	}
+
+	*(u32 *)temp = 50;
+	if ((usb_ulp_read_write(adapter,
+				WATCH_DOG_DELAY_TIMER_1,
+				temp, 32)) < 0) {
+		goto fail;
+	}
+
+	*(u32 *)temp = 0;
+	if ((usb_ulp_read_write(adapter,
+				WATCH_DOG_DELAY_TIMER_2,
+				temp, 32)) < 0) {
+		goto fail;
+	}
+
+	*(u32 *)temp = ((0xaa000) | RESTART_WDT | BYPASS_ULP_ON_WDT);
+	if ((usb_ulp_read_write(adapter,
+				WATCH_DOG_TIMER_ENABLE,
+				temp, 32)) < 0) {
+		goto fail;
+	}
+	rsi_dbg(INFO_ZONE, "Card Reset Done\n");
+	return 0;
+
+fail:
+	rsi_dbg(ERR_ZONE, "Reset card Failed\n");
+	return -1;
+}
+
 /**
  * rsi_probe() - This function is called by kernel when the driver provided
  *		 Vendor and device IDs are matched. All the initialization
@@ -456,8 +794,8 @@ static int rsi_probe(struct usb_interface *pfunction,
 {
 	struct rsi_hw *adapter;
 	struct rsi_91x_usbdev *dev;
-	u16 fw_status;
-	int status;
+	u32 fw_status = 0;
+	int status = 0;
 
 	rsi_dbg(INIT_ZONE, "%s: Init function called\n", __func__);
 
@@ -467,6 +805,8 @@ static int rsi_probe(struct usb_interface *pfunction,
 			__func__);
 		return -ENOMEM;
 	}
+	adapter->rsi_host_intf = RSI_HOST_INTF_USB;
+	adapter->priv->oper_mode = dev_oper_mode;
 
 	status = rsi_init_usb_interface(adapter, pfunction);
 	if (status) {
@@ -480,31 +820,32 @@ static int rsi_probe(struct usb_interface *pfunction,
 	dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
 
 	status = rsi_usb_reg_read(dev->usbdev, FW_STATUS_REG, &fw_status, 2);
-	if (status)
+	if (status < 0)
 		goto err1;
 	else
 		fw_status &= 1;
 
 	if (!fw_status) {
-		status = rsi_usb_device_init(adapter->priv);
+		rsi_dbg(INIT_ZONE, "Loading firmware...\n");
+		status = rsi_hal_device_init(adapter);
 		if (status) {
 			rsi_dbg(ERR_ZONE, "%s: Failed in device init\n",
 				__func__);
 			goto err1;
 		}
-
-		status = rsi_usb_reg_write(dev->usbdev,
-					   USB_INTERNAL_REG_1,
-					   RSI_USB_READY_MAGIC_NUM, 1);
-		if (status)
-			goto err1;
-		rsi_dbg(INIT_ZONE, "%s: Performed device init\n", __func__);
+		rsi_dbg(INIT_ZONE, "%s: Device Init Done\n", __func__);
 	}
 
-	status = rsi_rx_urb_submit(adapter);
+	status = rsi_rx_urb_submit(adapter, 1 /* RX_WLAN_EP */);  
 	if (status)
 		goto err1;
 
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	status = rsi_rx_urb_submit(adapter, 2 /* RX_BT_EP */);
+	if (status)
+		goto err1;
+#endif
+
 	return 0;
 err1:
 	rsi_deinit_usb_interface(adapter);
@@ -529,7 +870,18 @@ static void rsi_disconnect(struct usb_interface *pfunction)
 		return;
 
 	rsi_mac80211_detach(adapter);
+	rsi_dbg(INFO_ZONE, "mac80211 detach done\n");
+
+#if defined(CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	rsi_hci_detach(adapter->priv);
+	rsi_dbg(INFO_ZONE, "HCI Detach Done\n");
+#endif
+
+	rsi_reset_card(adapter);
+
 	rsi_deinit_usb_interface(adapter);
+	rsi_dbg(INFO_ZONE, "USB interface down\n");
+
 	rsi_91x_deinit(adapter);
 
 	rsi_dbg(INFO_ZONE, "%s: Deinitialization completed\n", __func__);
@@ -554,6 +906,7 @@ static const struct usb_device_id rsi_dev_table[] = {
 	{ USB_DEVICE(0x041B, 0x0301) },
 	{ USB_DEVICE(0x041B, 0x0201) },
 	{ USB_DEVICE(0x041B, 0x9330) },
+	{ USB_DEVICE(0x1618, 0x9113) },
 	{ /* Blank */},
 };
 
@@ -568,12 +921,25 @@ static struct usb_driver rsi_driver = {
 #endif
 };
 
-module_usb_driver(rsi_driver);
+static int __init rsi_usb_module_init(void)
+{
+	rsi_dbg(INIT_ZONE,
+		"=====> RSI USB Module Initialize <=====\n");
+	return usb_register(&rsi_driver);
+}
+
+static void __exit rsi_usb_module_exit(void)
+{
+	usb_deregister(&rsi_driver);
+}
+
+module_init(rsi_usb_module_init);
+module_exit(rsi_usb_module_exit);
 
 MODULE_AUTHOR("Redpine Signals Inc");
 MODULE_DESCRIPTION("Common USB layer for RSI drivers");
 MODULE_SUPPORTED_DEVICE("RSI-91x");
 MODULE_DEVICE_TABLE(usb, rsi_dev_table);
 MODULE_FIRMWARE(FIRMWARE_RSI9113);
-MODULE_VERSION("0.1");
+MODULE_VERSION(DRV_VER);
 MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/wireless/rsi/rsi_91x_usb_ops.c b/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
index de49008..147b5d1 100644
--- a/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
+++ b/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
@@ -1,85 +1,37 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
  *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <linux/firmware.h>
 #include "rsi_usb.h"
 
 /**
- * rsi_copy_to_card() - This function includes the actual funtionality of
- *			copying the TA firmware to the card.Basically this
- *			function includes opening the TA file,reading the TA
- *			file and writing their values in blocks of data.
- * @common: Pointer to the driver private structure.
- * @fw: Pointer to the firmware value to be written.
- * @len: length of firmware file.
- * @num_blocks: Number of blocks to be written to the card.
- *
- * Return: 0 on success and -1 on failure.
- */
-static int rsi_copy_to_card(struct rsi_common *common,
-			    const u8 *fw,
-			    u32 len,
-			    u32 num_blocks)
-{
-	struct rsi_hw *adapter = common->priv;
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	u32 indx, ii;
-	u32 block_size = dev->tx_blk_size;
-	u32 lsb_address;
-	u32 base_address;
-
-	base_address = TA_LOAD_ADDRESS;
-
-	for (indx = 0, ii = 0; ii < num_blocks; ii++, indx += block_size) {
-		lsb_address = base_address;
-		if (rsi_usb_write_register_multiple(adapter,
-						    lsb_address,
-						    (u8 *)(fw + indx),
-						    block_size)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load %s blk\n", __func__,
-				FIRMWARE_RSI9113);
-			return -EIO;
-		}
-		rsi_dbg(INIT_ZONE, "%s: loading block: %d\n", __func__, ii);
-		base_address += block_size;
-	}
-
-	if (len % block_size) {
-		lsb_address = base_address;
-		if (rsi_usb_write_register_multiple(adapter,
-						    lsb_address,
-						    (u8 *)(fw + indx),
-						    len % block_size)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Unable to load %s blk\n", __func__,
-				FIRMWARE_RSI9113);
-			return -EIO;
-		}
-	}
-	rsi_dbg(INIT_ZONE,
-		"%s: Succesfully loaded %s instructions\n", __func__,
-		FIRMWARE_RSI9113);
-
-	rsi_dbg(INIT_ZONE, "%s: loaded firmware\n", __func__);
-	return 0;
-}
-
-/**
  * rsi_usb_rx_thread() - This is a kernel thread to receive the packets from
  *			 the USB device.
  * @common: Pointer to the driver private structure.
@@ -90,96 +42,43 @@ void rsi_usb_rx_thread(struct rsi_common *common)
 {
 	struct rsi_hw *adapter = common->priv;
 	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	int status;
+	struct rx_usb_ctrl_block *rx_cb;
+	int status, idx;
 
 	do {
 		rsi_wait_event(&dev->rx_thread.event, EVENT_WAIT_FOREVER);
 
 		if (atomic_read(&dev->rx_thread.thread_done))
-			goto out;
-
-		mutex_lock(&common->tx_rxlock);
-		status = rsi_read_pkt(common, 0);
-		if (status) {
-			rsi_dbg(ERR_ZONE, "%s: Failed To read data", __func__);
-			mutex_unlock(&common->tx_rxlock);
-			return;
+			break;
+
+		for (idx = 0; idx < MAX_RX_URBS; idx++) {
+			rx_cb = &dev->rx_cb[idx];
+			if (!rx_cb->pend)
+				continue;
+			
+			mutex_lock(&common->rx_lock);
+			status = rsi_read_pkt(common, rx_cb->rx_buffer, 0);
+			if (status) {
+				rsi_dbg(ERR_ZONE, "%s: Failed To read data",
+					__func__);
+				mutex_unlock(&common->rx_lock);
+				break;
+			}
+			rx_cb->pend = 0;
+			mutex_unlock(&common->rx_lock);
+			
+			if (adapter->rx_urb_submit(adapter, rx_cb->ep_num)) {
+				rsi_dbg(ERR_ZONE,
+					"%s: Failed in urb submission", __func__);
+				break;
+			}
 		}
-		mutex_unlock(&common->tx_rxlock);
 		rsi_reset_event(&dev->rx_thread.event);
-		if (adapter->rx_urb_submit(adapter)) {
-			rsi_dbg(ERR_ZONE,
-				"%s: Failed in urb submission", __func__);
-			return;
-		}
+	
 	} while (1);
 
-out:
-	rsi_dbg(INFO_ZONE, "%s: Terminated thread\n", __func__);
+	rsi_dbg(INFO_ZONE, "%s: Terminated USB RX thread\n", __func__);
+	atomic_inc(&dev->rx_thread.thread_done);
 	complete_and_exit(&dev->rx_thread.completion, 0);
 }
 
-
-/**
- * rsi_load_ta_instructions() - This function includes the actual funtionality
- *				of loading the TA firmware.This function also
- *				includes opening the TA file,reading the TA
- *				file and writing their value in blocks of data.
- * @common: Pointer to the driver private structure.
- *
- * Return: status: 0 on success, -1 on failure.
- */
-static int rsi_load_ta_instructions(struct rsi_common *common)
-{
-	struct rsi_hw *adapter = common->priv;
-	struct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)adapter->rsi_dev;
-	const struct firmware *fw_entry = NULL;
-	u32 block_size = dev->tx_blk_size;
-	const u8 *fw;
-	u32 num_blocks, len;
-	int status = 0;
-
-	status = request_firmware(&fw_entry, FIRMWARE_RSI9113, adapter->device);
-	if (status < 0) {
-		rsi_dbg(ERR_ZONE, "%s Firmware file %s not found\n",
-			__func__, FIRMWARE_RSI9113);
-		return status;
-	}
-
-	/* Copy firmware into DMA-accessible memory */
-	fw = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);
-	if (!fw) {
-		status = -ENOMEM;
-		goto out;
-	}
-	len = fw_entry->size;
-
-	if (len % 4)
-		len += (4 - (len % 4));
-
-	num_blocks = (len / block_size);
-
-	rsi_dbg(INIT_ZONE, "%s: Instruction size:%d\n", __func__, len);
-	rsi_dbg(INIT_ZONE, "%s: num blocks: %d\n", __func__, num_blocks);
-
-	status = rsi_copy_to_card(common, fw, len, num_blocks);
-	kfree(fw);
-
-out:
-	release_firmware(fw_entry);
-	return status;
-}
-
-/**
- * rsi_device_init() - This Function Initializes The HAL.
- * @common: Pointer to the driver private structure.
- *
- * Return: 0 on success, -1 on failure.
- */
-int rsi_usb_device_init(struct rsi_common *common)
-{
-	if (rsi_load_ta_instructions(common))
-		return -EIO;
-
-	return 0;
-		}
diff --git a/drivers/net/wireless/rsi/rsi_boot_params.h b/drivers/net/wireless/rsi/rsi_boot_params.h
index 5e2721f..2af85e1 100644
--- a/drivers/net/wireless/rsi/rsi_boot_params.h
+++ b/drivers/net/wireless/rsi/rsi_boot_params.h
@@ -1,87 +1,109 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_BOOTPARAMS_HEADER_H__
 #define __RSI_BOOTPARAMS_HEADER_H__
 
-#define CRYSTAL_GOOD_TIME                BIT(0)
-#define BOOTUP_MODE_INFO                 BIT(1)
-#define WIFI_TAPLL_CONFIGS               BIT(5)
-#define WIFI_PLL960_CONFIGS              BIT(6)
-#define WIFI_AFEPLL_CONFIGS              BIT(7)
-#define WIFI_SWITCH_CLK_CONFIGS          BIT(8)
+#define CRYSTAL_GOOD_TIME		BIT(0)
+#define BOOTUP_MODE_INFO                BIT(1)
+#define WIFI_TAPLL_CONFIGS              BIT(5)
+#define WIFI_PLL960_CONFIGS             BIT(6)
+#define WIFI_AFEPLL_CONFIGS             BIT(7)
+#define WIFI_SWITCH_CLK_CONFIGS         BIT(8)
 
-#define TA_PLL_M_VAL_20                  8
-#define TA_PLL_N_VAL_20                  1
-#define TA_PLL_P_VAL_20                  4
+#define TAPLL_M_VAL_20			9
+#define TAPLL_N_VAL_20			0
+#define TAPLL_P_VAL_20			4
 
-#define PLL960_M_VAL_20                  0x14
-#define PLL960_N_VAL_20                  0
-#define PLL960_P_VAL_20                  5
+#define PLL960_M_VAL_20                 0x14
+#define PLL960_N_VAL_20                 0
+#define PLL960_P_VAL_20                 5
 
-#define UMAC_CLK_40MHZ                   40
+#define UMAC_CLK_40MHZ                  80
 
-#define TA_PLL_M_VAL_40                  46
-#define TA_PLL_N_VAL_40                  3
-#define TA_PLL_P_VAL_40                  3
+#define TAPLL_M_VAL_40                  9
+#define TAPLL_N_VAL_40                  0
+#define TAPLL_P_VAL_40                  4
 
-#define PLL960_M_VAL_40                  0x14
-#define PLL960_N_VAL_40                  0
-#define PLL960_P_VAL_40                  5
+#define PLL960_M_VAL_40                 0x14
+#define PLL960_N_VAL_40                 0
+#define PLL960_P_VAL_40                 5
 
 #define UMAC_CLK_20BW \
-	(((TA_PLL_M_VAL_20 + 1) * 40) / \
-	 ((TA_PLL_N_VAL_20 + 1) * (TA_PLL_P_VAL_20 + 1)))
+	(((TAPLL_M_VAL_20 + 1) * 40) / \
+	 ((TAPLL_N_VAL_20 + 1) * (TAPLL_P_VAL_20 + 1)))
 #define VALID_20 \
-	(WIFI_PLL960_CONFIGS | WIFI_AFEPLL_CONFIGS | WIFI_SWITCH_CLK_CONFIGS)
+	(WIFI_TAPLL_CONFIGS | WIFI_PLL960_CONFIGS | WIFI_AFEPLL_CONFIGS | \
+	 WIFI_SWITCH_CLK_CONFIGS | BOOTUP_MODE_INFO | CRYSTAL_GOOD_TIME)
+
 #define UMAC_CLK_40BW   \
-	(((TA_PLL_M_VAL_40 + 1) * 40) / \
-	 ((TA_PLL_N_VAL_40 + 1) * (TA_PLL_P_VAL_40 + 1)))
+	(((TAPLL_M_VAL_40 + 1) * 40) / \
+	 ((TAPLL_N_VAL_40 + 1) * (TAPLL_P_VAL_40 + 1)))
 #define VALID_40 \
 	(WIFI_PLL960_CONFIGS | WIFI_AFEPLL_CONFIGS | WIFI_SWITCH_CLK_CONFIGS | \
 	 WIFI_TAPLL_CONFIGS | CRYSTAL_GOOD_TIME | BOOTUP_MODE_INFO)
 
-/* structure to store configs related to TAPLL programming */
+/* TAPLL programming configurations */
 struct tapll_info {
 	__le16 pll_reg_1;
 	__le16 pll_reg_2;
 } __packed;
 
-/* structure to store configs related to PLL960 programming */
+/* PLL960 programming configurations */
 struct pll960_info {
 	__le16 pll_reg_1;
 	__le16 pll_reg_2;
 	__le16 pll_reg_3;
 } __packed;
 
-/* structure to store configs related to AFEPLL programming */
+/* AFEPLL programming configurations */
 struct afepll_info {
 	__le16 pll_reg;
 } __packed;
 
-/* structure to store configs related to pll configs */
+/* PLL configurations */
 struct pll_config {
 	struct tapll_info tapll_info_g;
 	struct pll960_info pll960_info_g;
 	struct afepll_info afepll_info_g;
 } __packed;
 
-/* structure to store configs related to UMAC clk programming */
+/* UMAC clk programming configurations */
 struct switch_clk {
-	__le16 switch_clk_info;
+	__le16 switch_umac_clk : 1; /* If set rest is valid */
+	__le16 switch_qspi_clk : 1; /* If set qspi clk will be changed */
+	__le16 switch_slp_clk_2_32 : 1;
+	__le16 switch_bbp_lmac_clk_reg : 1;
+	__le16 switch_mem_ctrl_cfg : 1;
+	__le16 reserved : 11;
+
 	/* If switch_bbp_lmac_clk_reg is set then this value will be programmed
 	 * into reg
 	 */
@@ -99,11 +121,43 @@ struct device_clk_info {
 
 struct bootup_params {
 	__le16 magic_number;
+#define LOADED_TOKEN  0x5AA5   /* Bootup params are installed by host
+				* or OTP/FLASH (Bootloader)
+				*/
+#define ROM_TOKEN     0x55AA   /* Bootup params are taken from ROM
+				* itself in MCU mode.
+				*/
 	__le16 crystal_good_time;
 	__le32 valid;
+#define CRYSTAL_GOOD_TIME                BIT(0)
+#define BOOTUP_MODE_INFO                 BIT(1)
+#define DIGITAL_LOOP_BACK_PARAMS         BIT(2)
+#define RTLS_TIMESTAMP_EN                BIT(3)
+#define HOST_SPI_INTR_CFG                BIT(4)
+#define WIFI_TAPLL_CONFIGS               BIT(5)
+#define WIFI_PLL960_CONFIGS              BIT(6)
+#define WIFI_AFEPLL_CONFIGS              BIT(7)
+#define WIFI_SWITCH_CLK_CONFIGS          BIT(8)
+#define BT_TAPLL_CONFIGS                 BIT(9)
+#define BT_PLL960_CONFIGS                BIT(10)
+#define BT_AFEPLL_CONFIGS                BIT(11)
+#define BT_SWITCH_CLK_CONFIGS            BIT(12)
+#define ZB_TAPLL_CONFIGS                 BIT(13)
+#define ZB_PLL960_CONFIGS                BIT(14)
+#define ZB_AFEPLL_CONFIGS                BIT(15)
+#define ZB_SWITCH_CLK_CONFIGS            BIT(16)
+#define BUCKBOOST_WAIT_INFO              BIT(17)
+#define PMU_WAKEUP_SHUTDOWN_W            BIT(18)
+#define WDT_PROG_VALUES                  BIT(19)
+#define WDT_RESET_DELAY_VALUE            BIT(20)
+#define DCDC_OPERATION_MODE_VALID        BIT(21)
+#define PMU_SLP_CLKOUT_SEL               BIT(22)
+#define SOC_RESET_WAIT_CNT               BIT(23)
 	__le32 reserved_for_valids;
 	__le16 bootup_mode_info;
-	/* configuration used for digital loop back */
+#define BT_COEXIST                       BIT(0)
+#define BOOTUP_MODE                     (BIT(2) | BIT(1))
+#define CUR_DEV_MODE                    (bootup_params.bootup_mode_info >> 1)
 	__le16 digital_loop_back_params;
 	__le16 rtls_timestamp_en;
 	__le16 host_spi_intr_cfg;
@@ -122,5 +176,9 @@ struct bootup_params {
 	/* dcdc modes configs */
 	__le32 dcdc_operation_mode;
 	__le32 soc_reset_wait_cnt;
+	__le32 waiting_time_at_fresh_sleep;
+	__le32 max_threshold_to_avoid_sleep;
+	u8 beacon_resedue_alg_en;
 } __packed;
+
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_coex.h b/drivers/net/wireless/rsi/rsi_coex.h
new file mode 100644
index 0000000..83313e3
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_coex.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_COEX_H__
+#define __RSI_COEX_H__
+
+#include "rsi_common.h"
+
+#define RSI_COEX_TXQ_MAX_PKTS		64
+#define RSI_COEX_TXQ_WATER_MARK		50
+#define COMMON_CARD_READY_IND           0
+
+#define COEX_Q				0
+#define BT_Q				1
+#define WLAN_Q				2
+#define VIP_Q				3
+#define ZIGB_Q				4
+#define NUM_COEX_TX_QUEUES		5
+
+#include "rsi_main.h"
+
+enum rsi_proto {
+	RSI_PROTO_WLAN = 0,
+	RSI_PROTO_BT
+};
+
+struct rsi_coex_ctrl_block {
+	struct rsi_common *priv;
+	struct sk_buff_head coex_tx_qs[NUM_COEX_TX_QUEUES];
+        struct semaphore tx_bus_lock;
+	struct rsi_thread coex_tx_thread;
+};
+
+int rsi_coex_init(struct rsi_common *common);
+int rsi_coex_send_pkt(struct rsi_common *common,
+		      struct sk_buff *skb,
+		      u8 proto_type);
+int rsi_coex_recv_pkt(struct rsi_common *common, u8 *msg);
+void rsi_coex_deinit(struct rsi_common *common);
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_common.h b/drivers/net/wireless/rsi/rsi_common.h
index d3fbe33..e4aa29e 100644
--- a/drivers/net/wireless/rsi/rsi_common.h
+++ b/drivers/net/wireless/rsi/rsi_common.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_COMMON_H__
@@ -20,8 +34,6 @@
 #include <linux/kthread.h>
 
 #define EVENT_WAIT_FOREVER              0
-#define TA_LOAD_ADDRESS                 0x00
-#define FIRMWARE_RSI9113                "rsi_91x.fw"
 #define QUEUE_NOT_FULL                  1
 #define QUEUE_FULL                      0
 
@@ -38,10 +50,10 @@ static inline int rsi_wait_event(struct rsi_event *event, u32 timeout)
 
 	if (!timeout)
 		status = wait_event_interruptible(event->event_queue,
-				(atomic_read(&event->event_condition) == 0));
+				(!atomic_read(&event->event_condition)));
 	else
 		status = wait_event_interruptible_timeout(event->event_queue,
-				(atomic_read(&event->event_condition) == 0),
+				(!atomic_read(&event->event_condition)),
 				timeout);
 	return status;
 }
@@ -63,6 +75,7 @@ static inline int rsi_create_kthread(struct rsi_common *common,
 				     u8 *name)
 {
 	init_completion(&thread->completion);
+	atomic_set(&thread->thread_done, 0);
 	thread->task = kthread_run(func_ptr, common, "%s", name);
 	if (IS_ERR(thread->task))
 		return (int)PTR_ERR(thread->task);
@@ -72,6 +85,8 @@ static inline int rsi_create_kthread(struct rsi_common *common,
 
 static inline int rsi_kill_thread(struct rsi_thread *handle)
 {
+	if (atomic_read(&handle->thread_done) > 0)
+		return 0;
 	atomic_inc(&handle->thread_done);
 	rsi_set_event(&handle->event);
 
@@ -83,5 +98,18 @@ void rsi_mac80211_detach(struct rsi_hw *hw);
 u16 rsi_get_connected_channel(struct rsi_hw *adapter);
 struct rsi_hw *rsi_91x_init(void);
 void rsi_91x_deinit(struct rsi_hw *adapter);
-int rsi_read_pkt(struct rsi_common *common, s32 rcv_pkt_len);
+int rsi_read_pkt(struct rsi_common *common, u8 *rx_pkt, s32 rcv_pkt_len);
+void rsi_indicate_bcnmiss(struct rsi_common *common);
+void rsi_resume_conn_channel(struct rsi_hw *adapter, struct ieee80211_vif *vif);
+void rsi_hci_detach(struct rsi_common *common);
+char *dot11_pkt_type(__le16 frame_control);
+struct rsi_sta *rsi_find_sta(struct rsi_common *common, u8 *mac_addr);
+void rsi_init_bcn_timer(struct rsi_common *common);
+void rsi_del_bcn_timer(struct rsi_common *common);
+void rsi_bcn_scheduler_thread(struct rsi_common *common);
+#ifdef CONFIG_SDIO_INTR_POLL
+void init_sdio_intr_status_poll_thread(struct rsi_common *common);
+#endif
+void rsi_roc_timeout(unsigned long data);
+struct ieee80211_vif *rsi_get_vif(struct rsi_hw *adapter, u8 *mac);
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_debugfs.h b/drivers/net/wireless/rsi/rsi_debugfs.h
index 580ad3b..58085fd 100644
--- a/drivers/net/wireless/rsi/rsi_debugfs.h
+++ b/drivers/net/wireless/rsi/rsi_debugfs.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_DEBUGFS_H__
diff --git a/drivers/net/wireless/rsi/rsi_hal.h b/drivers/net/wireless/rsi/rsi_hal.h
new file mode 100644
index 0000000..900c1b2
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_hal.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_HAL_H__
+#define __RSI_HAL_H__
+
+/* Device Operating modes */
+#define DEV_OPMODE_WIFI_ALONE		1
+#define DEV_OPMODE_BT_ALONE		4
+#define DEV_OPMODE_BT_LE_ALONE		8
+#define DEV_OPMODE_STA_BT		5
+#define DEV_OPMODE_STA_BT_LE		9
+#define DEV_OPMODE_STA_BT_DUAL		13
+#define DEV_OPMODE_AP_BT		6
+#define DEV_OPMODE_AP_BT_DUAL		14
+
+#define TA_LOAD_ADDRESS			0x00
+#define FIRMWARE_RSI9113		"rsi_91x.fw"
+#define FLASH_WRITE_CHUNK_SIZE		(4 * 1024)
+#define USB_FLASH_READ_CHUNK_SIZE	((2 * 1024) - 4)
+#define SDIO_FLASH_READ_CHUNK_SIZE	(2 * 1024)
+#define FLASH_SECTOR_SIZE		(4 * 1024)
+#define STARTING_BLOCK_INDEX		0
+#define FLASH_BLOCK_SIZE		(32 * 1024)
+
+#define FLASH_SIZE_ADDR			0x04000016
+#define PING_BUFFER_ADDRESS		0x19000
+#define PONG_BUFFER_ADDRESS		0x1a000
+#define SWBL_REGIN			0x41050034
+#define SWBL_REGOUT			0x4105003c
+#define PING_WRITE			0x1
+#define PONG_WRITE			0x2
+
+#define BL_CMD_TIMEOUT			2000
+#define BL_BURN_TIMEOUT			(50 * 1000)
+
+#define MASTER_READ_MODE		1
+#define EEPROM_READ_MODE		2
+
+#define REGIN_VALID			0xA
+#define REGIN_INPUT			0xA0
+#define REGOUT_VALID			0xAB
+#define REGOUT_INVALID			(~0xAB)
+#define CMD_PASS			0xAA
+#define CMD_FAIL			0xCC
+#define INVALID_ADDR			0x4C
+
+#define BURN_BL				0x23
+#define LOAD_HOSTED_FW			'A'
+#define BURN_HOSTED_FW			'B'
+#define PING_VALID			'I'
+#define PONG_VALID			'O'
+#define PING_AVAIL			'I'
+#define PONG_AVAIL			'O'
+#define EOF_REACHED			'E'
+#define CHECK_CRC			'K'
+#define POLLING_MODE			'P'
+#define CONFIG_AUTO_READ_MODE		'R'
+#define JUMP_TO_ZERO_PC			'J'
+#define FW_LOADING_SUCCESSFUL		'S'
+#define LOADING_INITIATED		'1'
+
+/* Boot loader commands */
+#define HOST_INTF_REG_OUT		0x4105003C
+#define HOST_INTF_REG_IN		0x41050034
+#define BOARD_READY			0xABCD
+#define REG_READ			0xD1
+#define REG_WRITE			0xD2
+#define SEND_RPS_FILE			'2'
+#define BOOTUP_OPTIONS_LAST_CONFIG_NOT_SAVED 0xF1
+#define BOOTUP_OPTIONS_CHECKSUM_FAIL 0xF2
+#define INVALID_OPTION			0xF3
+#define CHECKSUM_SUCCESS		0xAA
+#define CHECKSUM_FAILURE		0xCC
+#define CHECKSUM_INVALID_ADDRESS	0x4C
+
+#define EEPROM_VERSION_OFFSET		77
+#define CALIB_CRC_OFFSET		4092
+#define MAGIC_WORD			0x5A
+#define MAGIC_WORD_OFFSET_1		40
+#define MAGIC_WORD_OFFSET_2		424
+#define FW_IMAGE_MIN_ADDRESS		(68 * 1024)
+#define FLASH_MAX_ADDRESS		(4 * 1024 * 1024) //4MB
+#define MAX_FLASH_FILE_SIZE		(400 * 1024) //400K
+#define FLASHING_START_ADDRESS		16
+#define CALIB_VALUES_START_ADDR		16
+#define SOC_FLASH_ADDR			0x04000000
+#define EEPROM_DATA_SIZE		4096
+#define CALIB_DATA_SIZE		(EEPROM_DATA_SIZE - CALIB_VALUES_START_ADDR)
+#define BL_HEADER			32
+
+#define BT_CARD_READY_IND		0x89
+#define WLAN_CARD_READY_IND		0x0
+#define COMMON_HAL_CARD_READY_IND	0x0
+#define ZIGB_CARD_READY_IND		0xff
+
+#define COMMAN_HAL_WAIT_FOR_CARD_READY	1
+#define COMMON_HAL_SEND_CONFIG_PARAMS	2
+#define COMMON_HAL_TX_ACCESS		3
+#define COMMON_HAL_WAIT_FOR_PROTO_CARD_READY 4
+#define HEX_FILE			1
+#define BIN_FILE			0
+#define UNIX_FILE_TYPE			8
+#define DOS_FILE_TYPE			9
+#define LMAC_INSTRUCTIONS_SIZE		(16  * 1024) /* 16Kbytes */
+
+#define ULP_RESET_REG			0x161
+#define WATCH_DOG_TIMER_1		0x16c
+#define WATCH_DOG_TIMER_2		0x16d
+#define WATCH_DOG_DELAY_TIMER_1		0x16e
+#define WATCH_DOG_DELAY_TIMER_2		0x16f
+#define WATCH_DOG_TIMER_ENABLE		0x170
+
+#define RESTART_WDT			BIT(11)
+#define BYPASS_ULP_ON_WDT		BIT(1)
+
+#define RF_SPI_PROG_REG_BASE_ADDR	0x40080000
+
+#define GSPI_CTRL_REG0			(RF_SPI_PROG_REG_BASE_ADDR)
+#define GSPI_CTRL_REG1			(RF_SPI_PROG_REG_BASE_ADDR + 0x2)
+#define GSPI_DATA_REG0			(RF_SPI_PROG_REG_BASE_ADDR + 0x4)
+#define GSPI_DATA_REG1			(RF_SPI_PROG_REG_BASE_ADDR + 0x6)
+#define GSPI_DATA_REG2			(RF_SPI_PROG_REG_BASE_ADDR + 0x8)
+
+#define GSPI_DMA_MODE			BIT(13)
+
+#define GSPI_2_ULP			BIT(12)
+#define GSPI_TRIG			BIT(7)
+#define GSPI_READ			BIT(6)
+#define GSPI_RF_SPI_ACTIVE		BIT(8)
+
+#define FW_FLASH_OFFSET			0x820
+#define LMAC_VER_OFFSET			FW_FLASH_OFFSET +0x200
+
+struct bl_header {
+	__le32 flags;
+	__le32 image_no;
+	__le32 check_sum;
+	__le32 flash_start_address;
+	__le32 flash_len;
+} __packed;
+
+struct ta_metadata {
+	char *name;
+	unsigned int address;
+};
+
+int rsi_prepare_mgmt_desc(struct rsi_common *common, struct sk_buff *skb);
+int rsi_prepare_data_desc(struct rsi_common *common, struct sk_buff *skb);
+int rsi_hal_device_init(struct rsi_hw *adapter);
+int rsi_send_data_pkt(struct rsi_common *common, struct sk_buff *skb);
+int rsi_send_bt_pkt(struct rsi_common *common, struct sk_buff *skb);
+int rsi_prepare_beacon(struct rsi_common *common, struct sk_buff *skb);
+
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_hci.h b/drivers/net/wireless/rsi/rsi_hci.h
new file mode 100644
index 0000000..26f554d
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_hci.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_HCI_H__
+#define __RSI_HCI_H__
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include <net/genetlink.h>
+#include <linux/version.h>
+
+#include "rsi_main.h"
+
+#define BB_READ 			0x0
+#define BB_WRITE 			0x1
+#define RF_READ 			0x2
+#define RF_WRITE 			0x3
+#define BT_PER_TRANSMIT 	0x4
+#define BT_RECEIVE 			0x5
+#define BUFFER_READ 		0x6
+#define BUFFER_WRITE 		0x7
+#define BT_PER_STATS 		0x8
+#define ANT_SEL 			0x9
+#define BT_BER_PKT_CNT 		0xA
+#define BT_BER_RECEIVE 		0xB
+#define BT_BER_MODE 		0xC
+#define BT_CW_MODE 			0xD 
+#define TX_STATUS 			0xE
+#define GET_DRV_COEX_MODE 	0xF
+
+/* RX frame types */
+#define RESULT_CONFIRM		0x80
+#define BT_PER 				0x10
+#define BT_BER 				0x11
+#define BT_CW 				0x12
+
+#define REQUIRED_HEADROOM_FOR_BT_HAL     16
+
+#define GET_ADAPTER_FROM_GENLCB (gcb) \
+	        (struct rsi_hci_adapter *)((gcb)->gc_drvpriv)
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 6, 11)
+# define get_portid(_info) (_info)->snd_pid
+#else
+# define get_portid(_info) (_info)->snd_portid
+#endif
+    
+enum {
+	RSI_USER_A_UNSPEC,
+	RSI_USER_A_MSG,
+	__RSI_USER_A_MAX,
+};
+
+enum {
+	RSI_USER_C_UNSPEC,
+	RSI_USER_C_CMD,
+	__RSI_USER_C_MAX,
+};
+
+struct genl_cb {
+	unsigned char gc_cmd, *gc_name;
+	int gc_seq, gc_pid;
+	int gc_done;
+	int gc_n_ops; 
+	void  *gc_drvpriv;
+	struct nla_policy *gc_policy;
+	struct genl_family *gc_family;
+	struct genl_ops *gc_ops; 
+	struct genl_info *gc_info;
+	struct sk_buff *gc_skb;
+};
+
+enum {
+	BT_DEVICE_NOT_READY = 0,
+	BT_DEVICE_READY
+};
+
+struct rsi_hci_adapter {
+	struct rsi_common *priv;
+	struct hci_dev *hdev;
+	struct genl_cb *gcb;
+	struct sk_buff_head hci_tx_queue;
+};
+
+int rsi_genl_recv (struct sk_buff *skb, struct genl_info *info);
+int rsi_hci_attach (struct rsi_common *common);
+void rsi_hci_detach(struct rsi_common *common);
+int rsi_hci_recv_pkt(struct rsi_common *common, u8 *pkt);
+
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_main.h b/drivers/net/wireless/rsi/rsi_main.h
index 5baed94..a267232 100644
--- a/drivers/net/wireless/rsi/rsi_main.h
+++ b/drivers/net/wireless/rsi/rsi_main.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_MAIN_H__
@@ -20,29 +34,40 @@
 #include <linux/string.h>
 #include <linux/skbuff.h>
 #include <net/mac80211.h>
+#include <linux/etherdevice.h>
+#include <linux/version.h>
+
+struct rsi_hw;
 
-#define ERR_ZONE                        BIT(0)  /* For Error Msgs             */
-#define INFO_ZONE                       BIT(1)  /* For General Status Msgs    */
-#define INIT_ZONE                       BIT(2)  /* For Driver Init Seq Msgs   */
-#define MGMT_TX_ZONE                    BIT(3)  /* For TX Mgmt Path Msgs      */
-#define MGMT_RX_ZONE                    BIT(4)  /* For RX Mgmt Path Msgs      */
-#define DATA_TX_ZONE                    BIT(5)  /* For TX Data Path Msgs      */
-#define DATA_RX_ZONE                    BIT(6)  /* For RX Data Path Msgs      */
-#define FSM_ZONE                        BIT(7)  /* For State Machine Msgs     */
-#define ISR_ZONE                        BIT(8)  /* For Interrupt Msgs         */
+#include "rsi_ps.h"
+
+#define DRV_VER				"RS9113.NB0.NL.GNU.LNX.1.0.RC7"
+
+#define ERR_ZONE                        BIT(0) /* Error Msgs		*/
+#define INFO_ZONE                       BIT(1) /* Generic Debug Msgs	*/
+#define INIT_ZONE                       BIT(2) /* Driver Init Msgs	*/
+#define MGMT_TX_ZONE                    BIT(3) /* TX Mgmt Path Msgs	*/
+#define MGMT_RX_ZONE                    BIT(4) /* RX Mgmt Path Msgs	*/
+#define DATA_TX_ZONE                    BIT(5) /* TX Data Path Msgs	*/
+#define DATA_RX_ZONE                    BIT(6) /* RX Data Path Msgs	*/
+#define FSM_ZONE                        BIT(7) /* State Machine Msgs	*/
+#define ISR_ZONE                        BIT(8) /* Interrupt Msgs	*/
 
 #define FSM_CARD_NOT_READY              0
-#define FSM_BOOT_PARAMS_SENT            1
-#define FSM_EEPROM_READ_MAC_ADDR        2
-#define FSM_RESET_MAC_SENT              3
-#define FSM_RADIO_CAPS_SENT             4
-#define FSM_BB_RF_PROG_SENT             5
-#define FSM_MAC_INIT_DONE               6
+#define FSM_COMMON_DEV_PARAMS_SENT	1
+#define FSM_BOOT_PARAMS_SENT            2
+#define FSM_EEPROM_READ_MAC_ADDR        3
+#define FSM_EEPROM_READ_RF_TYPE		4
+#define FSM_RESET_MAC_SENT              5
+#define FSM_RADIO_CAPS_SENT             6
+#define FSM_BB_RF_PROG_SENT             7
+#define FSM_MAC_INIT_DONE               8
 
 extern u32 rsi_zone_enabled;
 extern __printf(2, 3) void rsi_dbg(u32 zone, const char *fmt, ...);
+void rsi_hex_dump(u32 zone, char *msg_str, const u8 *msg, u32 len);
 
-#define RSI_MAX_VIFS                    1
+#define RSI_MAX_VIFS                    3
 #define NUM_EDCA_QUEUES                 4
 #define IEEE80211_ADDR_LEN              6
 #define FRAME_DESC_SZ                   16
@@ -53,22 +78,38 @@ extern __printf(2, 3) void rsi_dbg(u32 zone, const char *fmt, ...);
 #define MULTICAST_WATER_MARK            200
 #define MAC_80211_HDR_FRAME_CONTROL     0
 #define WME_NUM_AC                      4
-#define NUM_SOFT_QUEUES                 5
-#define MAX_HW_QUEUES                   8
+#define NUM_SOFT_QUEUES                 6
+#define MAX_HW_QUEUES                   12
 #define INVALID_QUEUE                   0xff
 #define MAX_CONTINUOUS_VO_PKTS          8
 #define MAX_CONTINUOUS_VI_PKTS          4
+#define MGMT_HW_Q			10 /* Queue No 10 is used for
+					    * MGMT_QUEUE in Device FW,
+					    *  Hence this is Reserved
+					    */
+#define BROADCAST_HW_Q			9
+#define BEACON_HW_Q			11
 
 /* Queue information */
+#define RSI_COEX_Q			0x0
+#define RSI_ZIGB_Q			0x1
+#define RSI_BT_Q			0x2
+#define RSI_WLAN_Q			0x3
 #define RSI_WIFI_MGMT_Q                 0x4
 #define RSI_WIFI_DATA_Q                 0x5
+#define RSI_BT_MGMT_Q			0x6
+#define RSI_BT_DATA_Q			0x7
 #define IEEE80211_MGMT_FRAME            0x00
 #define IEEE80211_CTL_FRAME             0x04
 
+#define RSI_MAX_ASSOC_STAS		32
+#define RSI_MAX_COEX_ASSOC_STAS		4
 #define IEEE80211_QOS_TID               0x0f
 #define IEEE80211_NONQOS_TID            16
 
-#define MAX_DEBUGFS_ENTRIES             4
+#define MAX_DEBUGFS_ENTRIES             5
+#define MAX_BGSCAN_CHANNELS		38
+
 
 #define TID_TO_WME_AC(_tid) (      \
 	((_tid) == 0 || (_tid) == 3) ? BE_Q : \
@@ -82,11 +123,17 @@ extern __printf(2, 3) void rsi_dbg(u32 zone, const char *fmt, ...);
 	((_q) == VI_Q) ? IEEE80211_AC_VI : \
 	IEEE80211_AC_VO)
 
+#define STATION_NOT_CONNECTED		BIT(1)
 struct version_info {
 	u16 major;
 	u16 minor;
-	u16 release_num;
-	u16 patch_num;
+	u8 release_num;
+	u8 patch_num;
+	union {
+		struct {
+			u8 fw_ver[8];
+		} info;
+	} ver;
 } __packed;
 
 struct skb_info {
@@ -95,14 +142,17 @@ struct skb_info {
 	u16 channel;
 	s8 tid;
 	s8 sta_id;
+	u8 internal_hdr_size;
+	struct ieee80211_sta *sta;
 };
 
 enum edca_queue {
-	BK_Q,
+	BK_Q = 0,
 	BE_Q,
 	VI_Q,
 	VO_Q,
-	MGMT_SOFT_Q
+	MGMT_SOFT_Q,
+	MGMT_BEACON_Q
 };
 
 struct security_info {
@@ -127,6 +177,7 @@ struct vif_priv {
 	bool is_ht;
 	bool sgi;
 	u16 seq_start;
+	u8 vap_id;
 };
 
 struct rsi_event {
@@ -148,6 +199,32 @@ struct cqm_info {
 	u32 rssi_hyst;
 };
 
+struct bgscan_config_params {
+	u16 bgscan_threshold;
+	u16 roam_threshold;
+	u16 bgscan_periodicity;
+	u8 num_user_channels;
+	u8 num_bg_channels;
+	u8 two_probe;
+	u16 active_scan_duration;
+	u16 passive_scan_duration;
+	u16 user_channels[MAX_BGSCAN_CHANNELS];
+	u16 channels2scan[MAX_BGSCAN_CHANNELS];
+};
+
+struct xtended_desc {
+	u8 confirm_frame_type;
+	u8 retry_cnt;
+	u16 reserved;
+};
+
+struct rsi_sta {
+	struct ieee80211_sta *sta;
+	s16 sta_id;
+	u16 seq_no[IEEE80211_NUM_ACS];
+	u16 seq_start[IEEE80211_NUM_ACS];
+};
+
 struct rsi_hw;
 
 struct rsi_common {
@@ -155,19 +232,26 @@ struct rsi_common {
 	struct vif_priv vif_info[RSI_MAX_VIFS];
 
 	bool mgmt_q_block;
-	struct version_info driver_ver;
-	struct version_info fw_ver;
+	char driver_ver[32];
+	struct version_info lmac_ver;
 
 	struct rsi_thread tx_thread;
-	struct sk_buff_head tx_queue[NUM_EDCA_QUEUES + 1];
+#ifdef CONFIG_SDIO_INTR_POLL
+	struct rsi_thread sdio_intr_poll_thread;
+#endif
+	struct sk_buff_head tx_queue[NUM_EDCA_QUEUES + 2];
+
 	/* Mutex declaration */
 	struct mutex mutex;
+	struct mutex pslock;
 	/* Mutex used between tx/rx threads */
-	struct mutex tx_rxlock;
+	struct mutex tx_lock;
+	struct mutex rx_lock;
 	u8 endpoint;
 
 	/* Channel/band related */
 	u8 band;
+	u8 num_supp_bands;
 	u8 channel_width;
 
 	u16 rts_threshold;
@@ -183,13 +267,16 @@ struct rsi_common {
 
 	/* state related */
 	u32 fsm_state;
+	u8 bt_fsm_state;
 	bool init_done;
 	u8 bb_rf_prog_count;
 	bool iface_down;
+	bool scan_in_prog;
 
 	/* Generic */
 	u8 channel;
 	u8 *rx_data_pkt;
+	u8 *saved_rx_data_pkt;
 	u8 mac_id;
 	u8 radio_id;
 	u16 rate_pwr[20];
@@ -202,29 +289,173 @@ struct rsi_common {
 
 	/* bgscan related */
 	struct cqm_info cqm_info;
+	struct bgscan_config_params bgscan_info;
+	int bgscan_en;
+	u8  start_bgscan;
+	u8 bgscan_probe_req[1500];
+	int bgscan_probe_req_len;
+	u16 bgscan_seq_ctrl;
+	u8 mac80211_cur_channel;
+	struct cfg80211_scan_request *scan_request;
+	struct ieee80211_vif *scan_vif;
 
 	bool hw_data_qs_blocked;
+	u8 driver_mode;
+	u8 coex_mode;
+	u16 oper_mode;
+	u8 ta_aggr;
+	u8 skip_fw_load;
+	u8 lp_ps_handshake_mode;
+	u8 ulp_ps_handshake_mode;
+	u8 uapsd_bitmap;
+	u8 rf_power_val;
+	u8 device_gpio_type;
+	u16 country_code;
+	u8 wlan_rf_power_mode;
+	u8 bt_rf_power_mode;
+	u8 obm_ant_sel_val;
+	u8 antenna_diversity;
+	u16 rf_pwr_mode;
+	char antenna_gain[2];
+	u8 host_wakeup_intr_enable;
+	u8 host_wakeup_intr_active_high;
+	int tx_power;
+	u8 ant_in_use;
+#ifdef CONFIG_RSI_WOW
+	u8 suspend_flag;
+#endif
+
+#if defined (CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+	void *hci_adapter;
+#endif
+
+#ifdef CONFIG_RSI_COEX
+	void *coex_cb;
+#endif
+
+	/* AP mode related */
+	u8 beacon_enabled;
+	u16 beacon_interval;
+	u16 beacon_cnt;
+	u8 dtim_cnt;
+	u16 bc_mc_seqno;
+	struct rsi_sta stations[RSI_MAX_ASSOC_STAS + 1];
+	int num_stations;
+	int max_stations;
+	struct ieee80211_channel *ap_channel;
+	struct rsi_thread bcn_thread;
+	struct timer_list bcn_timer;
+	struct ieee80211_key_conf *key;
+	u8 eapol4_confirm;
+	struct rsi_event chan_set_event;
+	struct rsi_event probe_cfm_event;
+	struct rsi_event chan_change_event;
+	struct rsi_event cancel_hw_scan_event;
+	struct timer_list scan_timer;
+	struct workqueue_struct *scan_workqueue;
+	struct work_struct scan_work;
+	bool hw_scan_cancel;
+
+	/* Wi-Fi direct mode related */
+	bool p2p_enabled;
+	struct timer_list roc_timer;
+	struct ieee80211_vif *roc_vif;
+	int last_vap_type;
+	u8 last_vap_addr[6];
+	u8 last_vap_id;
+
+        struct semaphore tx_bus_lock;
+};
+
+enum host_intf {
+	RSI_HOST_INTF_SDIO = 0,
+	RSI_HOST_INTF_USB
+};
+
+enum rsi_dev_model {
+	RSI_DEV_9110 = 0,
+	RSI_DEV_9113,
+	RSI_DEV_9116
+};
+
+struct eepromrw_info {
+	u32 offset;
+	u32 length;
+	u8  write;
+	u16 eeprom_erase;
+	u8 data[480];
+};
+
+struct eeprom_read {
+	u16 length;
+	u16 off_set;
 };
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0))
+#define NUM_NL80211_BANDS	3
+#endif
+
 struct rsi_hw {
 	struct rsi_common *priv;
+	enum rsi_dev_model device_model;
 	struct ieee80211_hw *hw;
 	struct ieee80211_vif *vifs[RSI_MAX_VIFS];
 	struct ieee80211_tx_queue_params edca_params[NUM_EDCA_QUEUES];
-	struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
 
-	struct device *device;
-	u8 sc_nvifs;
+	struct ieee80211_supported_band sbands[NUM_NL80211_BANDS];
 
+	struct device *device;
+	int sc_nvifs;
+	enum host_intf rsi_host_intf;
+	enum ps_state ps_state;
+	struct rsi_ps_info ps_info;
+	spinlock_t ps_lock;
+	u32 isr_pending;
 #ifdef CONFIG_RSI_DEBUGFS
 	struct rsi_debugfs *dfsentry;
 	u8 num_debugfs_entries;
 #endif
+
+	char *fw_file_name;
+	struct timer_list bl_cmd_timer;
+	u8 blcmd_timer_expired;
+	u32 flash_capacity;
+	u32 tx_blk_size;
+	u32 common_hal_fsm;
+	u8 eeprom_init;
+	struct eepromrw_info eeprom;
+	u32 interrupt_status;
+
+	u8 dfs_region;
+	char country[2];
 	void *rsi_dev;
-	int (*host_intf_read_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
-	int (*host_intf_write_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
+
+	struct rsi_host_intf_ops *host_intf_ops;
 	int (*check_hw_queue_status)(struct rsi_hw *adapter, u8 q_num);
-	int (*rx_urb_submit)(struct rsi_hw *adapter);
+	int (*rx_urb_submit)(struct rsi_hw *adapter, u8 ep_num);
 	int (*determine_event_timeout)(struct rsi_hw *adapter);
+	void (*process_isr_hci)(struct rsi_hw *adapter);
+	int  (*check_intr_status_reg)(struct rsi_hw *adapter);
+};
+
+void rsi_print_version(struct rsi_common *common);
+struct rsi_host_intf_ops {
+	int (*read_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
+	int (*write_pkt)(struct rsi_hw *adapter, u8 *pkt, u32 len);
+	int (*master_access_msword)(struct rsi_hw *adapter, u16 ms_word);
+	int (*read_reg_multiple)(struct rsi_hw *adapter, u32 addr,
+				 u8 *data, u16 count);
+	int (*write_reg_multiple)(struct rsi_hw *adapter, u32 addr,
+				  u8 *data, u16 count);
+	int (*master_reg_read)(struct rsi_hw *adapter, u32 addr,
+			       u32 *read_buf, u16 size);
+	int (*master_reg_write)(struct rsi_hw *adapter,
+				unsigned long addr, unsigned long data,
+				u16 size);
+	int (*load_data_master_write)(struct rsi_hw *adapter, u32 addr,
+				      u32 instructions_size, u16 block_size,
+				      u8 *fw);
+	int (*rsi_check_bus_status)(struct rsi_hw *adapter);
 };
+
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_mgmt.h b/drivers/net/wireless/rsi/rsi_mgmt.h
index 3741173..6179651 100644
--- a/drivers/net/wireless/rsi/rsi_mgmt.h
+++ b/drivers/net/wireless/rsi/rsi_mgmt.h
@@ -1,17 +1,31 @@
-/**
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_MGMT_H__
@@ -27,7 +41,7 @@
 
 #define RSI_11B_MODE                    0
 #define RSI_11G_MODE                    BIT(7)
-#define RETRY_COUNT                     8
+#define RETRY_COUNT                     15
 #define RETRY_LONG                      4
 #define RETRY_SHORT                     7
 #define WMM_SHORT_SLOT_TIME             9
@@ -43,13 +57,44 @@
 #define WLAN_HOST_MODE_LEN              0x04
 #define WLAN_FW_VERSION_LEN             0x08
 #define MAGIC_WORD                      0x5A
+#define WLAN_EEPROM_RFTYPE_ADDR		424
+
+/*WOWLAN RESUME WAKEUP TYPES*/
+#define	UNICAST_MAGIC_PKT       	BIT(0) 
+#define	BROADCAST_MAGICPKT      	BIT(1) 
+#define	EAPOL_PKT               	BIT(2) 
+#define	DISCONNECT_PKT          	BIT(3) 
+#define	HW_BMISS_PKT            	BIT(4) 
+#define INSERT_SEQ_IN_FW                BIT(2)
 
 /* Receive Frame Types */
-#define TA_CONFIRM_TYPE                 0x01
-#define RX_DOT11_MGMT                   0x02
-#define TX_STATUS_IND                   0x04
+enum rx_cmd_type {
+	CARD_READY_IND = 0x0,
+	TA_CONFIRM_TYPE = 0x01,
+	RX_DOT11_MGMT = 0x02,
+	RX_DOT11_DATA = 0x03,
+	TX_STATUS_IND = 0x04,
+	PS_NOTIFY_IND = 0x05,
+	SLEEP_NOTIFY_IND = 0x06,
+	DECRYPT_ERROR_IND = 0x07,
+	BEACON_EVENT_IND = 0x08,
+	DEBUG_IND = 0x09,
+	RX_MISC_IND = 0xa,
+	UNCONNECTED_PEER = 0xb,
+	HW_BMISS_EVENT = 0xc,
+	RATE_GC_TABLE_UPDATE = 0xd,
+	RADAR_DETECTED = 0x0e,
+	TSF_SYNC_CONFIRM = 0xc0,
+	ANTENNA_SELECT = 0xf,
+};
+
+#ifdef CONFIG_RSI_WOW
+#define WOW_MAX_FILTERS_PER_LIST 16
+#define WOW_PATTERN_SIZE 256
+#endif
+#define EAPOL4_CONFIRM			1
 #define PROBEREQ_CONFIRM                2
-#define CARD_READY_IND                  0x00
+#define NULLDATA_CONFIRM		3
 
 #define RSI_DELETE_PEER                 0x0
 #define RSI_ADD_PEER                    0x1
@@ -61,7 +106,12 @@
 #define BBP_REG_WRITE                   0
 #define RF_RESET_ENABLE                 BIT(3)
 #define RATE_INFO_ENABLE                BIT(0)
+#define MORE_DATA_PRESENT		BIT(1)
 #define RSI_BROADCAST_PKT               BIT(9)
+#define RSI_DESC_11G_MODE		BIT(7)
+#define RSI_DESC_REQUIRE_CFM_TO_HOST	BIT(10)
+#define ADD_DELTA_TSF_VAP_ID		BIT(11)
+#define FETCH_RETRY_CNT_FRM_HST		BIT(12)
 
 #define UPPER_20_ENABLE                 (0x2 << 12)
 #define LOWER_20_ENABLE                 (0x4 << 12)
@@ -71,31 +121,31 @@
 #define RSI_ENABLE_40MHZ                (0x1 << 3)
 #define ENABLE_SHORTGI_RATE		BIT(9)
 
-#define RX_BA_INDICATION                1
-#define RSI_TBL_SZ                      40
-#define MAX_RETRIES                     8
-#define RSI_IFTYPE_STATION		 0
-
-#define STD_RATE_MCS7                   0x07
-#define STD_RATE_MCS6                   0x06
-#define STD_RATE_MCS5                   0x05
-#define STD_RATE_MCS4                   0x04
-#define STD_RATE_MCS3                   0x03
-#define STD_RATE_MCS2                   0x02
-#define STD_RATE_MCS1                   0x01
-#define STD_RATE_MCS0                   0x00
-#define STD_RATE_54                     0x6c
-#define STD_RATE_48                     0x60
-#define STD_RATE_36                     0x48
-#define STD_RATE_24                     0x30
-#define STD_RATE_18                     0x24
-#define STD_RATE_12                     0x18
-#define STD_RATE_11                     0x16
-#define STD_RATE_09                     0x12
-#define STD_RATE_06                     0x0C
-#define STD_RATE_5_5                    0x0B
-#define STD_RATE_02                     0x04
-#define STD_RATE_01                     0x02
+#define RX_BA_INDICATION		1
+#define RSI_TBL_SZ			40
+#define MAX_RETRIES			8
+#define RSI_IFTYPE_STATION		1
+
+#define STD_RATE_MCS7			0x07
+#define STD_RATE_MCS6			0x06
+#define STD_RATE_MCS5			0x05
+#define STD_RATE_MCS4			0x04
+#define STD_RATE_MCS3			0x03
+#define STD_RATE_MCS2			0x02
+#define STD_RATE_MCS1			0x01
+#define STD_RATE_MCS0			0x00
+#define STD_RATE_54			0x6c
+#define STD_RATE_48			0x60
+#define STD_RATE_36			0x48
+#define STD_RATE_24			0x30
+#define STD_RATE_18			0x24
+#define STD_RATE_12			0x18
+#define STD_RATE_11			0x16
+#define STD_RATE_09			0x12
+#define STD_RATE_06			0x0C
+#define STD_RATE_5_5			0x0B
+#define STD_RATE_02			0x04
+#define STD_RATE_01			0x02
 
 #define RSI_RF_TYPE                     1
 #define RSI_RATE_00                     0x00
@@ -138,11 +188,98 @@
 #define LONG_PREAMBLE			0x0000
 #define SHORT_PREAMBLE			0x0001
 
-#define RSI_SUPP_FILTERS	(FIF_ALLMULTI | FIF_PROBE_REQ |\
-				 FIF_BCN_PRBRESP_PROMISC)
+#define RSI_SUPP_FILTERS		(FIF_ALLMULTI | FIF_PROBE_REQ |\
+					 FIF_BCN_PRBRESP_PROMISC)
+
+#define ANTENNA_SEL_INT			0x02 /* RF_OUT_2 / Integerated */
+#define ANTENNA_SEL_UFL			0x03 /* RF_OUT_1 / U.FL */
+
+/* Power save handshake types */
+#define NO_HAND_SHAKE			0
+#define GPIO_HAND_SHAKE			1
+#define PACKET_HAND_SHAKE		2
+#define TA_GPIO				0
+#define ULP_GPIO			1
+#define RF_POWER_3_3			1
+#define RF_POWER_1_9			0
+
+/* Rx filter word definitions */
+#define PROMISCOUS_MODE			BIT(0)
+#define ALLOW_DATA_ASSOC_PEER		BIT(1)
+#define ALLOW_MGMT_ASSOC_PEER		BIT(2)
+#define ALLOW_CTRL_ASSOC_PEER		BIT(3)
+#define DISALLOW_BEACONS		BIT(4)
+#define ALLOW_CONN_PEER_MGMT_WHILE_BUF_FULL BIT(5)
+#define DISALLOW_BROADCAST_DATA		BIT(6)
+
+#define RSI_TXPOWER_MAX			30
+#define RSI_TXPOWER_MIN			-127
+
+#define DEEP_SLEEP			1
+#define CONNECTED_SLEEP			2
+
+#define SLEEP_REQUEST			1
+#define WAKEUP_REQUEST			2
+
+#define RSI_TXPOWER_MAX			30
+#define RSI_TXPOWER_MIN			-127
+
+#define IEEE80211_MARKALL_UAPSD_QUEUES \
+	(IEEE80211_WMM_IE_STA_QOSINFO_AC_VO | \
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VI | \
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BE | \
+	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)
+#define IEEE80211_STA_SP_ALL_PKTS	0x00
+
+/* Tx data frame format */
+#define MAC_BBP_INFO			BIT(0) 
+#define NO_ACK_IND			BIT(9)
+#define QOS_EN				BIT(12)
+/* frame type bit{11:10} */
+#define NORMAL_FRAME			0x00
+#define DTIM_BEACON_GATED_FRAME		BIT(10) 
+#define BEACON_FRAME			BIT(11)
+#define DTIM_BEACON			BIT(10) | BIT(11)
+#define INSERT_TSF			BIT(15)
+#define INSERT_SEQ_NO			BIT(2)
+
+#ifdef CONFIG_PM
+#define RSI_WOW_ANY			BIT(1)
+#define RSI_WOW_GTK_REKEY		BIT(3)
+#define RSI_WOW_MAGIC_PKT		BIT(4)
+#define RSI_WOW_DISCONNECT		BIT(5)
+#endif
+#define HOST_BG_SCAN_TRIG		BIT(4)
+#define TARGET_BOARD_CARACALLA		BIT(10)
+
 enum opmode {
+	UNKNOW_OPMODE = -1,
+	AP_OPMODE = 0,
 	STA_OPMODE = 1,
-	AP_OPMODE = 2
+	P2P_GO_OPMODE = 2,
+	P2P_CLIENT_OPMODE = 3
+};
+
+enum vap_status {
+	VAP_ADD = 1,
+	VAP_DELETE = 2,
+	VAP_UPDATE = 3
+};
+
+enum peer_type {
+	PEER_TYPE_AP,
+	PEER_TYPE_STA,
+	PEER_TYPE_P2P_GO,
+	PEER_TYPE_P2P_CLIENT,
+	PEER_TYPE_IBSS
+};
+
+/*
+ * Subtypes for RX_MISC_IND frame
+ * Frame sub types from LMAC to Host
+ */
+enum rx_misc_ind_subtype {
+	FW_UPGRADE_REQ
 };
 
 extern struct ieee80211_rate rsi_rates[12];
@@ -159,34 +296,55 @@ enum sta_notify_events {
 
 /* Send Frames Types */
 enum cmd_frame_type {
-	TX_DOT11_MGMT,
-	RESET_MAC_REQ,
-	RADIO_CAPABILITIES,
-	BB_PROG_VALUES_REQUEST,
-	RF_PROG_VALUES_REQUEST,
-	WAKEUP_SLEEP_REQUEST,
-	SCAN_REQUEST,
-	TSF_UPDATE,
-	PEER_NOTIFY,
-	BLOCK_HW_QUEUE,
-	SET_KEY_REQ,
-	AUTO_RATE_IND,
-	BOOTUP_PARAMS_REQUEST,
-	VAP_CAPABILITIES,
-	EEPROM_READ_TYPE ,
-	EEPROM_WRITE,
-	GPIO_PIN_CONFIG ,
-	SET_RX_FILTER,
-	AMPDU_IND,
-	STATS_REQUEST_FRAME,
-	BB_BUF_PROG_VALUES_REQ,
-	BBP_PROG_IN_TA,
-	BG_SCAN_PARAMS,
-	BG_SCAN_PROBE_REQ,
-	CW_MODE_REQ,
-	PER_CMD_PKT
+	TX_DOT11_MGMT = 0,
+	RESET_MAC_REQ, /* 0x1 */
+	RADIO_CAPABILITIES, /* 0x2 */
+	BB_PROG_VALUES_REQUEST, /* 0x3 */
+	RF_PROG_VALUES_REQUEST, /* 0x4 */
+	WAKEUP_SLEEP_REQUEST, /* 0x5 */
+	SCAN_REQUEST, /* 0x6 */
+	TSF_UPDATE, /* 0x7 */
+	PEER_NOTIFY, /* 0x8 */
+	BLOCK_HW_QUEUE, /* 0x9 */
+	SET_KEY_REQ, /* 0xA */
+	AUTO_RATE_IND, /* 0xB */
+	BOOTUP_PARAMS_REQUEST, /* 0xC */
+	VAP_CAPABILITIES, /* 0xD */
+	EEPROM_READ, /* 0xE */
+	EEPROM_WRITE, /* 0xF */
+	GPIO_PIN_CONFIG, /* 0x10 */
+	SET_RX_FILTER, /* 0x11 */
+	AMPDU_IND, /* 0x12 */
+	STATS_REQUEST, /* 0x13 */
+	BB_BUF_PROG_VALUES_REQ, /* 0x14 */
+	BBP_PROG_IN_TA, /* 0x15 */
+	BG_SCAN_PARAMS, /* 0x16 */
+	BG_SCAN_PROBE_REQ, /* 0x17 */
+	CW_MODE_REQ, /* 0x18 */
+	PER_CMD_PKT, /* 0x19 */
+	DEV_SLEEP_REQUEST, /* 0x1A */
+	DEV_WAKEUP_CNF,  /* 0x1B */
+	RF_LOOPBACK_REQ, /* 0x1C */
+	RF_LPBK_M3,  /* 0x1D */
+	RF_RESET_FRAME,  /* 0x1E */
+	LMAC_REG_OPS,  /* 0x1F */
+	ANT_SEL_FRAME, /* 0x20 */
+	CONFIRM, /* 0x21 */
+	WLAN_DE_REGISTER, /* 0x22 */
+	DEBUG_FRAME,  /* 0x23 */
+	HW_BMISS_HANDLE, /* 0x24 */
+	MULTICAST_ENABLE, /* 0x25 */
+	TX_MISC_IND, /* 0x26 */
+	VAP_DYNAMIC_UPDATE, /* 0x27 */
+	COMMON_DEV_CONFIG, /* 0x28 */
+	RADIO_PARAMS_UPDATE, /* 0x29 */
+	RADAR_REQUEST, /* 0x2A */
+	WOWLAN_CONFIG_PARAMS, /* 0x2B */
+	IAP_CONFIG, /* 0x2C */
+	WOWLAN_WAKEUP_REASON = 0xc5 /* 0xC5 */
 };
 
+/* RSI Command packet formats */
 struct rsi_mac_frame {
 	__le16 desc_word[8];
 } __packed;
@@ -219,6 +377,38 @@ struct rsi_vap_caps {
 	__le32 default_data_rate;
 	__le16 beacon_interval;
 	__le16 dtim_period;
+	__le16 beacon_miss_threshold;
+} __packed;
+
+struct rsi_dynamic_s {
+	__le16 desc_word[8];
+
+	struct framebody {
+		__le16 data_rate;
+		__le16 mgmt_rate;
+		__le16 keep_alive_period;
+	} frame_body;
+} __packed;
+
+struct rsi_bgscan_params {
+	__le16 desc_word[8];
+	__le16 bgscan_threshold;
+	__le16 roam_threshold;
+	__le16 bgscan_periodicity;
+	u8 num_bg_channels;
+	u8 two_probe;
+	__le16 active_scan_duration;
+	__le16 passive_scan_duration;
+	__le16 channels2scan[MAX_BGSCAN_CHANNELS];
+} __packed;
+
+struct rsi_bgscan_probe {
+	__le16 desc_word[8];
+	__le16 mgmt_rate;
+	__le16 flags;
+	__le16 channel_num;
+	__le16 channel_scan_time;
+	__le16 probe_req_length;
 } __packed;
 
 struct rsi_set_key {
@@ -261,6 +451,81 @@ struct rsi_radio_caps {
 	__le16 preamble_type;
 } __packed;
 
+struct rsi_ulp_gpio_vals {
+	u8 motion_sensor_gpio_ulp_wakeup : 1;
+	u8 sleep_ind_from_device : 1;
+	u8 ulp_gpio_2 :1;
+	u8 push_button_ulp_wakeup : 1;
+	u8 reserved : 4;
+} __packed;
+
+struct rsi_soc_gpio_vals {
+	u32 pspi_csn_0 : 1;
+	u32 pspi_csn_1 : 1;
+	u32 host_wakeup_intr :1;
+	u32 pspi_data_0 : 1;
+	u32 pspi_data_1 : 1;
+	u32 pspi_data_2 : 1;
+	u32 pspi_data_3 : 1;
+	u32 i2c_scl :1;
+	u32 i2c_sda   :1;
+	u32 uart1_rx :1;
+	u32 uart1_tx  :1;
+	u32 uart1_rts_i2s_clk :1;
+	u32 uart1_cts_i2s_ws :1;
+	u32 dbg_uart_rx_i2s_din :1;
+	u32 dbg_uart_tx_i2s_dout :1;
+	u32 lp_wakeup_boot_bypass :1;
+	u32 led_0 :1;
+	u32 btcoex_wlan_active_ext_pa_ant_sel_A :1;
+	u32 btcoex_bt_priority_ext_pa_ant_sel_B :1;
+	u32 btcoex_bt_active_ext_pa_on_off :1;
+	u32 rf_reset :1;
+	u32 sleep_ind_from_device :1;
+} __packed;
+
+struct rsi_config_vals {
+	u16 desc_word[8];
+	u8 lp_ps_handshake;
+	u8 ulp_ps_handshake;
+	u8 sleep_config_params; /* 0 for no handshake,
+				 * 1 for GPIO based handshake,
+				 * 2 packet handshake
+				 */
+	u8 unused_ulp_gpio;
+	u32 unused_soc_gpio_bitmap;
+	u8 ext_pa_or_bt_coex_en;
+	u8 opermode;
+	u8 wlan_rf_pwr_mode;
+	u8 bt_rf_pwr_mode;
+	u8 zigbee_rf_pwr_mode;
+	u8 driver_mode;
+	u8 region_code;
+	u8 antenna_sel_val;
+#define EXT_PA      1
+#define EXT_BT_COEX 2
+} __packed;
+
+struct rsi_request_ps {
+	u16 desc_word[8];
+	struct ps_sleep_params ps_sleep;
+	u8 ps_mimic_support;
+	u8 ps_uapsd_acs;
+	u8 ps_uapsd_wakeup_period;
+	u8 reserved;
+	u32 ps_listen_interval;
+	u32 ps_dtim_interval_duration;
+	u16 ps_num_dtim_intervals;
+} __packed;
+
+struct rsi_wowlan_req { 
+	__le16 desc_word[8];
+	u8 sourceid[ETH_ALEN];
+	u16 wow_flags;
+	u16 host_sleep_status;
+} __packed;
+
+
 static inline u32 rsi_get_queueno(u8 *addr, u16 offset)
 {
 	return (le16_to_cpu(*(__le16 *)&addr[offset]) & 0x7000) >> 12;
@@ -287,17 +552,26 @@ static inline u8 rsi_get_channel(u8 *addr)
 }
 
 int rsi_mgmt_pkt_recv(struct rsi_common *common, u8 *msg);
-int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode);
-int rsi_send_aggregation_params_frame(struct rsi_common *common, u16 tid,
-				      u16 ssn, u8 buf_size, u8 event);
-int rsi_hal_load_key(struct rsi_common *common, u8 *data, u16 key_len,
-		     u8 key_type, u8 key_id, u32 cipher);
-int rsi_set_channel(struct rsi_common *common, u16 chno);
+int rsi_set_vap_capabilities(struct rsi_common *common, enum opmode mode,
+			     u8 *mac_addr, u8 vap_id, u8 vap_status);
+int rsi_send_aggr_params_frame(struct rsi_common *common, u16 tid,
+			       u16 ssn, u8 buf_size, u8 event, u8 sta_id);
+int rsi_load_key(struct rsi_common *common, u8 *data, u16 key_len,
+		 u8 key_type, u8 key_id, u32 cipher, s16 sta_id);
+int rsi_set_channel(struct rsi_common *common,
+		    struct ieee80211_channel *channel);
+int rsi_send_vap_dynamic_update(struct rsi_common *common);
 int rsi_send_block_unblock_frame(struct rsi_common *common, bool event);
-void rsi_inform_bss_status(struct rsi_common *common, u8 status,
-			   const u8 *bssid, u8 qos_enable, u16 aid);
+void rsi_inform_bss_status(struct rsi_common *common, enum opmode opmode,
+			   u8 status, const u8 *bssid, u8 qos_enable, u16 aid,
+			   struct ieee80211_sta *sta, u16 sta_id, u16 assoc_cap);
+int rsi_send_sta_notify_frame(struct rsi_common *common, enum opmode opmode,
+			      u8 notify_event, const unsigned char *bssid,
+			      u8 qos_enable, u16 aid, u16 sta_id);
 void rsi_indicate_pkt_to_os(struct rsi_common *common, struct sk_buff *skb);
 int rsi_mac80211_attach(struct rsi_common *common);
+int rsi_send_bgscan_params(struct rsi_common *common, int enable);
+int rsi_send_bgscan_probe_req(struct rsi_common *common);
 void rsi_indicate_tx_status(struct rsi_hw *common, struct sk_buff *skb,
 			    int status);
 bool rsi_is_cipher_wep(struct rsi_common *common);
@@ -305,5 +579,32 @@ void rsi_core_qos_processor(struct rsi_common *common);
 void rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb);
 int rsi_send_mgmt_pkt(struct rsi_common *common, struct sk_buff *skb);
 int rsi_send_data_pkt(struct rsi_common *common, struct sk_buff *skb);
-int rsi_band_check(struct rsi_common *common);
+int rsi_send_beacon(struct rsi_common *common);
+int rsi_send_pkt(struct rsi_common *common, struct sk_buff *skb);
+int rsi_band_check(struct rsi_common *common, struct ieee80211_channel *chan);
+int rsi_send_rx_filter_frame(struct rsi_common *common, u16 rx_filter_word);
+int rsi_flash_read(struct rsi_hw *adapter);
+int rsi_program_bb_rf(struct rsi_common *common);
+int rsi_send_radio_params_update(struct rsi_common *common);
+void init_bgscan_params(struct rsi_common *common);
+int rsi_set_antenna(struct rsi_common *common, u8 antenna);
+int rsi_hci_attach(struct rsi_common *common);
+int rsi_handle_card_ready(struct rsi_common *common);
+void rsi_validate_bgscan_channels(struct rsi_hw *adapter,
+				  struct bgscan_config_params *params);
+#ifdef CONFIG_RSI_WOW
+int rsi_send_wowlan_request(struct rsi_common *common, u16 flags,
+			    u16 sleep_status);
+#endif
+void rsi_scan_start(struct work_struct *data);
+#ifdef CONFIG_HW_SCAN_OFFLOAD
+int rsi_send_probe_request(struct rsi_common *common, 
+			   struct cfg80211_scan_request *scan_req, u8 n_ssid,
+			   u8 channel, u8 scan_type);
+#endif
+#ifdef CONFIG_CARACALLA_BOARD
+void rsi_apply_carcalla_power_values(struct rsi_hw *adapter,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_channel *channel);
+#endif
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_ps.h b/drivers/net/wireless/rsi/rsi_ps.h
new file mode 100644
index 0000000..e10082c
--- /dev/null
+++ b/drivers/net/wireless/rsi/rsi_ps.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RSI_PS_H__
+#define __RSI_PS_H__
+
+#define PS_CONFIRM_INDEX	12
+
+enum ps_state {
+	PS_NONE = 0,
+	PS_ENABLE_REQ_SENT = 1,
+	PS_DISABLE_REQ_SENT = 2,
+	PS_ENABLED = 3
+};
+
+struct ps_sleep_params {
+	u8 enable;
+	u8 sleep_type; //LP or ULP type
+	u8 connected_sleep;
+	u8 reserved1;
+	u16 num_bcns_per_lis_int;
+	u16 wakeup_type;
+	u32 sleep_duration;
+} __packed;
+
+struct rsi_ps_info {
+	u8 enabled;
+	u8 sleep_type;
+	u8 tx_threshold;
+	u8 rx_threshold;
+	u8 tx_hysterisis;
+	u8 rx_hysterisis;
+	u16 monitor_interval;
+	u32 listen_interval;
+	u16 num_bcns_per_lis_int;
+	u32 dtim_interval_duration;
+	u16 num_dtims_per_sleep;
+	u32 deep_sleep_wakeup_period;
+} __packed;
+
+char *str_psstate(enum ps_state state);
+void rsi_enable_ps(struct rsi_hw *adapter);
+void rsi_disable_ps(struct rsi_hw *adapter);
+int rsi_handle_ps_confirm(struct rsi_hw *adapter, u8 *msg);
+void rsi_default_ps_params(struct rsi_hw *hw);
+int rsi_send_ps_request(struct rsi_hw *adapter, bool enable);
+void rsi_conf_uapsd(struct rsi_hw *adapter);
+
+#endif
diff --git a/drivers/net/wireless/rsi/rsi_sdio.h b/drivers/net/wireless/rsi/rsi_sdio.h
index c7e8f2b..4f17d64 100644
--- a/drivers/net/wireless/rsi/rsi_sdio.h
+++ b/drivers/net/wireless/rsi/rsi_sdio.h
@@ -1,19 +1,31 @@
-/**
- * @section LICENSE
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
  *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_SDIO_INTF__
@@ -28,38 +40,39 @@
 #include <linux/mmc/sdio_ids.h>
 #include "rsi_main.h"
 
-enum sdio_interrupt_type {
-	BUFFER_FULL         = 0x0,
-	BUFFER_AVAILABLE    = 0x2,
-	FIRMWARE_ASSERT_IND = 0x3,
-	MSDU_PACKET_PENDING = 0x4,
-	UNKNOWN_INT         = 0XE
-};
-
 /* Buffer status register related info */
-#define PKT_BUFF_SEMI_FULL                      0
-#define PKT_BUFF_FULL                           1
-#define PKT_MGMT_BUFF_FULL                      2
-#define MSDU_PKT_PENDING                        3
+#define PKT_BUFF_SEMI_FULL		0
+#define PKT_BUFF_FULL			1
+#define PKT_MGMT_BUFF_FULL		2
+#define MSDU_PKT_PENDING		3
+
 /* Interrupt Bit Related Macros */
-#define PKT_BUFF_AVAILABLE                      1
-#define FW_ASSERT_IND                           2
+#define PKT_BUFF_AVAILABLE		1
+#define FW_ASSERT_IND			2
 
-#define RSI_DEVICE_BUFFER_STATUS_REGISTER       0xf3
-#define RSI_FN1_INT_REGISTER                    0xf9
-#define RSI_SD_REQUEST_MASTER                   0x10000
+#define RSI_DEVICE_BUFFER_STATUS_REGISTER 0xf3
+#define RSI_FN1_INT_REGISTER		0xf9
+#define SD_REQUEST_MASTER		0x10000
 
 /* FOR SD CARD ONLY */
-#define SDIO_RX_NUM_BLOCKS_REG                  0x000F1
-#define SDIO_FW_STATUS_REG                      0x000F2
-#define SDIO_NXT_RD_DELAY2                      0x000F5
-#define SDIO_MASTER_ACCESS_MSBYTE               0x000FA
-#define SDIO_MASTER_ACCESS_LSBYTE               0x000FB
-#define SDIO_READ_START_LVL                     0x000FC
-#define SDIO_READ_FIFO_CTL                      0x000FD
-#define SDIO_WRITE_FIFO_CTL                     0x000FE
-#define SDIO_FUN1_INTR_CLR_REG                  0x0008
-#define SDIO_REG_HIGH_SPEED                     0x0013
+#define SDIO_RX_NUM_BLOCKS_REG		0x000F1
+#define SDIO_FW_STATUS_REG		0x000F2
+#define SDIO_NXT_RD_DELAY2		0x000F5
+#define SDIO_MASTER_ACCESS_MSBYTE	0x000FA
+#define SDIO_MASTER_ACCESS_LSBYTE	0x000FB
+#define SDIO_READ_START_LVL		0x000FC
+#define SDIO_READ_FIFO_CTL		0x000FD
+#define SDIO_WRITE_FIFO_CTL		0x000FE
+#define SDIO_WAKEUP_REG			0x000FF
+
+#define SDIO_FUN1_INTR_CLR_REG		0x0008
+#define SDIO_REG_HIGH_SPEED		0x0013
+#define TA_SOFT_RESET_REG		0x0004
+#define TA_TH0_PC_REG			0x0400
+#define TA_HOLD_THREAD_REG		0x0844       
+#define TA_RELEASE_THREAD_REG		0x0848
+#define TA_POLL_BREAK_STATUS_REG	0x085C
+
 
 #define RSI_GET_SDIO_INTERRUPT_TYPE(_I, TYPE)      \
 	{					   \
@@ -73,18 +86,26 @@ enum sdio_interrupt_type {
 	}
 
 /* common registers in SDIO function1 */
-#define TA_SOFT_RESET_REG            0x0004
-#define TA_TH0_PC_REG                0x0400
-#define TA_HOLD_THREAD_REG           0x0844
-#define TA_RELEASE_THREAD_REG        0x0848
+#define TA_SOFT_RESET_REG		0x0004
+#define TA_TH0_PC_REG			0x0400
+#define TA_HOLD_THREAD_REG		0x0844
+#define TA_RELEASE_THREAD_REG		0x0848
+
+#define TA_SOFT_RST_CLR			0
+#define TA_SOFT_RST_SET			BIT(0)
+#define TA_PC_ZERO			0
+#define TA_HOLD_THREAD_VALUE		cpu_to_le32(0xF)
+#define TA_RELEASE_THREAD_VALUE		cpu_to_le32(0xF)
+#define TA_BASE_ADDR			0x2200
+#define MISC_CFG_BASE_ADDR		0x4105
 
-#define TA_SOFT_RST_CLR              0
-#define TA_SOFT_RST_SET              BIT(0)
-#define TA_PC_ZERO                   0
-#define TA_HOLD_THREAD_VALUE         cpu_to_le32(0xF)
-#define TA_RELEASE_THREAD_VALUE      cpu_to_le32(0xF)
-#define TA_BASE_ADDR                 0x2200
-#define MISC_CFG_BASE_ADDR           0x4105
+enum sdio_interrupt_type {
+	BUFFER_FULL		= 0x0,
+	BUFFER_AVAILABLE	= 0x2,
+	FIRMWARE_ASSERT_IND	= 0x3,
+	MSDU_PACKET_PENDING	= 0x4,
+	UNKNOWN_INT		= 0XE
+};
 
 struct receive_info {
 	bool buffer_full;
@@ -103,7 +124,7 @@ struct receive_info {
 
 struct rsi_91x_sdiodev {
 	struct sdio_func *pfunction;
-	struct task_struct *in_sdio_litefi_irq;
+	struct task_struct *sdio_irq_task;
 	struct receive_info rx_info;
 	u32 next_read_delay;
 	u32 sdio_high_speed_enable;
@@ -112,18 +133,34 @@ struct rsi_91x_sdiodev {
 	u8 prev_desc[16];
 	u32 tx_blk_size;
 	u8 write_fail;
+	u8 buff_status_updated;
 };
 
 void rsi_interrupt_handler(struct rsi_hw *adapter);
 int rsi_init_sdio_slave_regs(struct rsi_hw *adapter);
 int rsi_sdio_device_init(struct rsi_common *common);
 int rsi_sdio_read_register(struct rsi_hw *adapter, u32 addr, u8 *data);
-int rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter, u8 *pkt, u32 length);
 int rsi_sdio_write_register(struct rsi_hw *adapter, u8 function,
 			    u32 addr, u8 *data);
+int rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter, u8 *pkt, u32 length);
+int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter, u8 *pkt, u32 len);
+int rsi_sdio_read_register_multiple(struct rsi_hw *adapter, u32 addr,
+				    u8 *data, u16 count);
 int rsi_sdio_write_register_multiple(struct rsi_hw *adapter, u32 addr,
-				     u8 *data, u32 count);
+				     u8 *data, u16 count);
+int rsi_sdio_master_access_msword(struct rsi_hw *adapter,
+				  u16 ms_word);
+int rsi_sdio_load_data_master_write(struct rsi_hw *adapter,
+				    u32 base_address, u32 instructions_sz,
+				    u16 block_size, u8 *ta_firmware);
+int rsi_sdio_master_reg_read(struct rsi_hw *adapter, u32 addr,
+			     u32 *read_buf, u16 size);
+int rsi_sdio_master_reg_write(struct rsi_hw *adapter,
+			      unsigned long addr,
+			      unsigned long data,
+			      u16 size);
 void rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit);
 int rsi_sdio_determine_event_timeout(struct rsi_hw *adapter);
 int rsi_sdio_read_buffer_status_register(struct rsi_hw *adapter, u8 q_num);
+int rsi_read_intr_status_reg(struct rsi_hw *adapter);
 #endif
diff --git a/drivers/net/wireless/rsi/rsi_usb.h b/drivers/net/wireless/rsi/rsi_usb.h
index ebea0c4..ef95473 100644
--- a/drivers/net/wireless/rsi/rsi_usb.h
+++ b/drivers/net/wireless/rsi/rsi_usb.h
@@ -1,18 +1,31 @@
-/**
- * @section LICENSE
- * Copyright (c) 2014 Redpine Signals Inc.
+/*
+ * Copyright (c) 2017 Redpine Signals Inc. All rights reserved.
  *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 	1. Redistributions of source code must retain the above copyright
+ * 	   notice, this list of conditions and the following disclaimer.
+ *
+ * 	2. Redistributions in binary form must reproduce the above copyright
+ * 	   notice, this list of conditions and the following disclaimer in the
+ * 	   documentation and/or other materials provided with the distribution.
+ *
+ * 	3. Neither the name of the copyright holder nor the names of its
+ * 	   contributors may be used to endorse or promote products derived from
+ * 	   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __RSI_USB_INTF__
@@ -22,28 +35,42 @@
 #include "rsi_main.h"
 #include "rsi_common.h"
 
-#define USB_INTERNAL_REG_1           0x25000
-#define RSI_USB_READY_MAGIC_NUM      0xab
 #define FW_STATUS_REG                0x41050012
 
 #define USB_VENDOR_REGISTER_READ     0x15
 #define USB_VENDOR_REGISTER_WRITE    0x16
 #define RSI_USB_TX_HEAD_ROOM         128
 
+#define MAX_TX_URBS                  1
+#if defined (CONFIG_RSI_BT_ALONE) || defined(CONFIG_RSI_COEX)
+#define MAX_RX_URBS                  2
+#else
 #define MAX_RX_URBS                  1
+#endif
 #define MAX_BULK_EP                  8
 #define MGMT_EP                      1
 #define DATA_EP                      2
 
+struct rx_usb_ctrl_block {
+	u8 *data;
+	struct urb *rx_urb;
+	u8 *rx_buffer;
+	u8 *orig_rx_buffer;
+	u8 ep_num;
+	u8 pend;
+};
+
 struct rsi_91x_usbdev {
+	void *priv;
 	struct rsi_thread rx_thread;
 	u8 endpoint;
 	struct usb_device *usbdev;
 	struct usb_interface *pfunction;
-	struct urb *rx_usb_urb[MAX_RX_URBS];
+	struct rx_usb_ctrl_block rx_cb[MAX_RX_URBS];
 	u8 *tx_buffer;
-	__le16 bulkin_size;
-	u8 bulkin_endpoint_addr;
+	u8 *saved_tx_buffer;
+	__le16 bulkin_size[MAX_BULK_EP];
+	u8 bulkin_endpoint_addr[MAX_BULK_EP];
 	__le16 bulkout_size[MAX_BULK_EP];
 	u8 bulkout_endpoint_addr[MAX_BULK_EP];
 	u32 tx_blk_size;
@@ -62,7 +89,19 @@ static inline int rsi_usb_event_timeout(struct rsi_hw *adapter)
 }
 
 int rsi_usb_device_init(struct rsi_common *common);
+int rsi_usb_read_register_multiple(struct rsi_hw *adapter, u32 addr,
+				   u8 *data, u16 count);
 int rsi_usb_write_register_multiple(struct rsi_hw *adapter, u32 addr,
-				    u8 *data, u32 count);
+				    u8 *data, u16 count);
 void rsi_usb_rx_thread(struct rsi_common *common);
+
+int rsi_usb_host_intf_write_pkt(struct rsi_hw *adapter, u8 *pkt, u32 len);
+int rsi_usb_master_reg_read(struct rsi_hw *adapter, u32 reg,
+			    u32 *value, u16 len);
+int rsi_usb_master_reg_write(struct rsi_hw *adapter, unsigned long reg,
+			     unsigned long value, u16 len);
+int rsi_usb_load_data_master_write(struct rsi_hw *adapter, u32 base_address,
+				   u32 instructions_sz,
+				   u16 block_size,
+				   u8 *ta_firmware);
 #endif
-- 
2.7.4

